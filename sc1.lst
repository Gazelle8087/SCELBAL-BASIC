 AS V1.42 Beta [Bld 271] - Source File sc1.asm - Page 1 - 6/7/2025 16:50:52


    1/   0 :                            ;	SCELBAL BASIC i8008 program loader for generic MS-DOS
    2/   0 :                            ;
    3/   0 :                            ;Gazelle states the copyright about;
    4/   0 :                            ;Converted old 8008 mnemonics to new 8008 mnemonics.
    5/   0 :                            ;Added IO routines to match the specifications of the DOS loader.
    6/   0 :                            ;Added startup and IO routines to run on CP/M.
    7/   0 :                            ;
    8/   0 :                            ;	Copyright (C) 2025 by Gazelle
    9/   0 :                            ;
   10/   0 :                            ;Permission is hereby granted, free of charge, to any person
   11/   0 :                            ;obtaining a copy of this software and associated documentation
   12/   0 :                            ;files (the "Software"), to deal in the Software without
   13/   0 :                            ;restriction, including without limitation the rights to use,
   14/   0 :                            ;copy, modify, merge, publish, distribute, sublicense, and/or sell
   15/   0 :                            ;copies of the Software, and to permit persons to whom the
   16/   0 :                            ;Software is furnished to do so, subject to the following
   17/   0 :                            ;conditions:
   18/   0 :                            ;
   19/   0 :                            ;The above copyright notice and this permission notice shall be
   20/   0 :                            ;included in all copies or substantial portions of the Software.
   21/   0 :                            ;
   22/   0 :                            ;THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
   23/   0 :                            ;EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
   24/   0 :                            ;OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
   25/   0 :                            ;NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
   26/   0 :                            ;HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
   27/   0 :                            ;WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
   28/   0 :                            ;FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
   29/   0 :                            ;OTHER DEALINGS IN THE SOFTWARE.
   30/   0 :                            ;
   31/   0 :                            ;Repository https://github.com/Gazelle8087/SCELVAL-BASIC
   32/   0 :                            ;original source for SVELVAL BASIC is available here under
   33/   0 :                            ;https://www.willegal.net/scelbi/the8008andScelbi.html
   34/   0 :                            ;
   35/   0 :                            ;2025/6/5 Rev. 1.00 Initial release
   36/   0 :                            ;2025/6/7 Rev. 1.01 added exit messege on 8080code
   37/   0 :                            ;
   38/   0 :                            ;;; This is the Scelbi Basic Program from 1974 known as
   39/   0 :                            ;;; SCELBAL by Mark G. Arnold (MGA) and Nat Wadsworth  
   40/   0 :                            ;;;
   41/   0 :                            ;;;  Copyright 1975 Scelbi Computer Consulting, Inc.
   42/   0 :                            ;;;  All rights reserved
   43/   0 :                            ;;;
   44/   0 :                            ;;; MGA gives permission to use SCELBAL for 
   45/   0 :                            ;;; educational, historical, non-commercial purposes.
   46/   0 :                            ;;; Versions of this have been circulating on the web since
   47/   0 :                            ;;; about 2000; this version is authorized by MGA (Mar 2012)
   48/   0 :                            ;;; with the understanding no warranty is expressed or implied.
   49/   0 :                            ;;; As stated in the original, "no responsibility is assumed for
   50/   0 :                            ;;; for inaccuracies or for the success or failure of
   51/   0 :                            ;;; various applications to which the information herein
   52/   0 :                            ;;; may be applied."
   53/   0 :                            ;;; 
   54/   0 :                            ;;; SCELBAL is the only open-source, floating-point 
   55/   0 :                            ;;; high-level language ever implemented on Intel's first
   56/   0 :                            ;;; general-purpose microprocessor, the 8008.  It was
   57/   0 :                            ;;; published in book form:
   58/   0 :                            ;;;
   59/   0 :                            ;;;  SCELBAL: A Higher-Level Language for 8008/8080 Systems
   60/   0 :                            ;;;
 AS V1.42 Beta [Bld 271] - Source File sc1.asm - Page 2 - 6/7/2025 16:50:52


   61/   0 :                            ;;; (Tiny BASIC only used 16-bit integers; the MCM\70
   62/   0 :                            ;;; was a closed system; calculators implemented with 8008
   63/   0 :                            ;;; were floating-point, but not high-level.)
   64/   0 :                            ;;;
   65/   0 :                            ;;; This version is modified to assemble with the
   66/   0 :                            ;;; as8 assembler (using the -octal option) 
   67/   0 :                            ;;; for the Intel 8008 by Thomas E. Jones.
   68/   0 :                            ;;; This current form is made up non-relocatable so that
   69/   0 :                            ;;; locations of all code and data is identical to the
   70/   0 :                            ;;; original SCELBAL documents and patches.  It should be
   71/   0 :                            ;;; reasonable after debugging code to convert this to a
   72/   0 :                            ;;; relocatable and ROMable code with variables in RAM.
   73/   0 :                            ;;; This code originates from a version made by 
   74/   0 :                            ;;;
   75/   0 :                            ;;;    Steve Loboyko in 2001.
   76/   0 :                            ;;;
   77/   0 :                            ;;; This version has all 3 patches for SCELBAL (the two
   78/   0 :                            ;;; pasted in the original manual, and a third which was
   79/   0 :                            ;;; written in SCELBAL UPDATE publication, as well as
   80/   0 :                            ;;; a couple changes to constants which didn't actually
   81/   0 :                            ;;; require a patch, just changes to bytes of data or
   82/   0 :                            ;;; arguments to an instruction--one of these (Tucker) was 
   83/   0 :                            ;;; incorrect and restored to original by MGA March 2012).
   84/   0 :                            ;;; 
   85/   0 :                            ;;; This comment must be incorporated with any version of SCELBAL
   86/   0 :                            ;;; downloaded, distributed, posted or disemenated.
   87/   0 :                            
   88/   0 : =$0                        FOR8080	EQU	0		;switch to 1 for 8080CPU and CP/M
   89/   0 :                            
   90/   0 : =>FALSE                     IF FOR8080
   91/   0 :                            		CPU	8080
   92/   0 :                            FOR8008		EQU	0
   93/   0 : =>TRUE                      ELSE
   94/   0 :                            		CPU	8008new
   95/   0 : =1H                        FOR8008		EQU	1
   96/   0 : [90]                        ENDIF
   97/   0 :                            		page	0,100
   98/   0 :                            
   99/   0 : =2DH                       ENDPGRAM	EQU	055o	;MGA 4/10/12 as in orig; for his ROMable Loboyko said 077       [077]
  100/   0 : =1BH                       BGNPGRAM	EQU	033o	;MGA 4/10/12 as in orig; for his ROMable Loboyko said 044       [044]
  101/   0 :                            
  102/   0 :                            ;;; Here are labels originally attempting to make the code
  103/   0 :                            ;;; relocatable.  These 4 pages contain variable data
  104/   0 :                            ;;; which needs to be relocated from ROM to RAM.
  105/   0 :                            ;;; I can't vouch for ALL references to these pages in
  106/   0 :                            ;;; the code being switched to these labels, but they
  107/   0 :                            ;;; seem to be.
  108/   0 :                            
  109/   0 : =1H                        PG01		EQU	1	;OLDPG1:	EQU	001#000
  110/   0 : =16H                       PG26		EQU	026o	;OLDPG26:	EQU	026#000
  111/   0 : =17H                       PG27		EQU	027o	;OLDPG27:	EQU	027#000
  112/   0 : =2FH                       PG57		EQU	057o	;OLDPG57:	EQU	057#000
  113/   0 :                            
  114/   0 :                            ;;; Page zero will contain the I/O Routines.  These are actually
  115/   0 :                            ;;; just as suggested by Scelbal Manual for Serial I/O.
  116/   0 :                            
  117/   0 : =>TRUE                      IF FOR8008
  118/   0 :                            		ORG	0
  119/   0 : 44 42 30                   		JMP	START3000
  120/   3 : [117]                       ENDIF
  121/   3 :                            
  122/   3 :                            ;;; THE ABOVE MUST CONCLUDE BEFORE BY PAGE 1 STARTS
  123/   3 :                            
  124/   3 :                            ;;; Page one has many constants and variables.
  125/   3 :                            
  126/ 100 :                            		ORG	0100h		;001#000
  127/ 100 : 44 42 30                   		JMP	START3000
  128/ 103 : 00                         		db	0
  129/ 104 :                            ;		db	0,0,0,0		;DATA *4
  130/ 104 : 00 00 40 01                		db	0,0,100o,1	;DATA 000,000,100,001	; STORES FLOATING POINT CONSTANT +1.0
  131/ 108 : 00 00 00                   		db	0,0,0		;DATA *3
  132/ 10B : 00                         		db	0		;DATA 000		; EXPONENT COUNTER
  133/ 10C : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000	; STORES FLOATING POINT NUMBER TEMPORARILLY
  134/ 110 : 00 00 00 00                		db	0,0,0,0		;DATA *4
  135/ 114 : 00 00 C0 01                		db	0,0,300o,1	;DATA 000,000,300,001	; STORES FLOATING POINT CONSTANT -1.0
  136/ 118 : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000	; SCRATCH PAD AREA (16 BYTES)
  137/ 11C : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000
  138/ 120 : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000
  139/ 124 : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000
  140/ 128 : 01 50 72 02                		db	1,120o,162o,2o	;DATA 001,120,162,002	; STORES RANDOM NUMBER GENERATOR CONSTANT VALUE
  141/ 12C : 00 00 00 00                		db	0,0,0,0		;DATA *4
  142/ 130 : 03 68 6F 0C                		db	3,150o,157o,14o	;DATA 003,150,157,014	; STORES RANDOM NUMBER GENERATOR CONSTANT VALUE
  143/ 134 : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000	; SCRATCH PAD AREA (12 BYTES) (01 064-077)
  144/ 138 : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000
  145/ 13C : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000
  146/ 140 : 00 00                      		db	0,0		;DATA 000,000		; SIGN INDICATOR
  147/ 142 : 00                         		db	0		;DATA 000		; BITS COUNTER
  148/ 143 : 00 00                      		db	0,0		;DATA 000,000		; SIGN INDICATOR
  149/ 145 : 00                         IN_DIGIT_CC_L0	db	0		;DATA 000		; INPUT DIGIT COUNTER
  150/ 146 : =45H                       IN_DIGIT_CC_L	equ	105o
  151/ 146 : 00                         		db	0		;DATA 000		; TEMP STORATE
  152/ 147 : 00                         		db	0		;DATA 000		; OUTPUT DIGIT COUNTER
  153/ 148 : 00                         		db	0		;DATA 000 		; FP MODE INDICATOR
  154/ 149 : 00 00 00 00 00 00 00       		db	0,0,0,0,0,0,0	;DATA *7		; NOT ASSIGNED (SHOULD BE 01 111-117)
  155/ 150 : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000	; FPACC EXTENSION
  156/ 154 : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000	; FPACC LSW, NSW, MSW, EXPONENT
  157/ 158 : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000	; FPOP  Extension
  158/ 15C : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000	; FPOP  LSW, NSW, MSW, EXPONENT
  159/ 160 : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000	; FLOATING POINT WORKING AREA
  160/ 164 : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000	; (SHOULD BE AT 01 140-01-167)
  161/ 168 : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000
  162/ 16C : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000
  163/ 170 : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000
  164/ 174 : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000
  165/ 178 : 00 00 00 00 00 00 00 00    		db	0,0,0,0,0,0,0,0	;DATA *8		; NOT ASSIGNED (SHOULD BE 01 170-01 177)
  166/ 180 : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000	; TEMPORARY REGISTER STORAGE AREA (D,E,H&L)
  167/ 184 : 00 00 00 00                		db	0,0,0,0		;DATA *4		; NOT ASSIGNED (01 204-01 207)
  168/ 188 : 00 00 50 04                		db	0,0,120o,4	;DATA 000,000,120,004	; STORES FLOATING POINT CONSTANT +10.0
  169/ 18C : 67 66 66 FD                		db	147o,146o,146o,375o	;DATA 147,146,146,375	; STORES FLOATING POINT CONSTANT +0.1
  170/ 190 : 00                         		db	0		;DATA 000		; GETINP COUNTER
  171/ 191 : 00 00 00 00 00 00          		db	0,0,0,0,0,0	;DATA *6		; NOT ASSIGNED (01 221-01 226)
  172/ 197 : 00                         		db	0		;DATA 000		; ARITHMETIC STACK POINTER (01 227)
  173/ 198 : 00                         		db	0		;DATA 000		; ARITHMETIC STACK (NOT CLEAR HOW LONG)
  174/ 199 :                            
  175/ 199 :                            ;		db	(1bah-$) dup 0	
  176/ 199 :                            
  177/ 1BA :                            		ORG 	01bah		;001#272
  178/ 1BA : 04                         		db	4		;DATA 004		; CC FOR SAVE
  179/ 1BB :                            ;		db	"SAVE"		;DATA "SAVE"
  180/ 1BB : D3                         		db	"S"+80h
  181/ 1BC : C1                         		db	"A"+80h
  182/ 1BD : D6                         		db	"V"+80h
  183/ 1BE : C5                         		db	"E"+80h
  184/ 1BF : 04                         		db	4		;DATA 004		; CC FOR LOAD
  185/ 1C0 :                            ;		db	"LOAD"		;DATA "LOAD"
  186/ 1C0 : CC                         		db	"L"+80h
  187/ 1C1 : CF                         		db	"O"+80h
  188/ 1C2 : C1                         		db	"A"+80h
  189/ 1C3 : C4                         		db	"D"+80h
  190/ 1C4 : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000	; UNCLEAR WHAT THIS IS (01 304-01 317) ZEROS
  191/ 1C8 : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000	; (PROBABLY STEP, FOR/NEXT, AND ARRAY PTR TEMP)
  192/ 1CC : 00 00 00 00                		db	0,0,0,0		;DATA 000,000,000,000
  193/ 1D0 :                            					;; AT THIS POINT WE SHOULD BE AT LOCATION 01 320 01d0h
  194/ 1D0 : 04                         		db	4		;DATA 4
  195/ 1D1 :                            ;		db	"THEN"		;DATA "THEN"
  196/ 1D1 : D4                         		db	"T"+80h
  197/ 1D2 : C8                         		db	"H"+80h
  198/ 1D3 : C5                         		db	"E"+80h
  199/ 1D4 : CE                         		db	"N"+80h
  200/ 1D5 : 02                         		db	2		;DATA 2
  201/ 1D6 :                            ;		db	"TO"		;DATA "TO"
  202/ 1D6 : D4                         		db	"T"+80h
  203/ 1D7 : CF                         		db	"O"+80h
  204/ 1D8 : 04                         		db	4		;DATA 4
  205/ 1D9 :                            ;		db	"STEP"		;DATA "STEP"
  206/ 1D9 : D3                         		db	"S"+80h
  207/ 1DA : D4                         		db	"T"+80h
  208/ 1DB : C5                         		db	"E"+80h
  209/ 1DC : D0                         		db	"P"+80h
  210/ 1DD : 04                         		db	4		;DATA 4
  211/ 1DE :                            ;		db	"LIST"		;DATA "LIST"
  212/ 1DE : CC                         		db	"L"+80h
  213/ 1DF : C9                         		db	"I"+80h
  214/ 1E0 : D3                         		db	"S"+80h
  215/ 1E1 : D4                         		db	"T"+80h
  216/ 1E2 : 03                         		db	3		;DATA 3
  217/ 1E3 :                            ;		db	"RUN"		;DATA "RUN"
  218/ 1E3 : D2                         		db	"R"+80h
  219/ 1E4 : D5                         		db	"U"+80h
  220/ 1E5 : CE                         		db	"N"+80h
  221/ 1E6 : 03                         		db	3		;DATA 3
  222/ 1E7 :                            ;		db	"SCR"		;DATA "SCR
  223/ 1E7 : D3                         		db	"S"+80h
  224/ 1E8 : C3                         		db	"C"+80h
  225/ 1E9 : D2                         		db	"R"+80h
  226/ 1EA : 0B                         		db	013o		;DATA 013		; CC FOR "READY" MESSAGE
  227/ 1EB : 94 8D 8A                   		db	224o,215o,212o	;DATA 224,215,212	; CTRL-T, CARRIAGE RETURN, LINE FEED
  228/ 1EE :                            ;		db	"READY"		;DATA "READY"
  229/ 1EE : D2                         		db	"R"+80h
  230/ 1EF : C5                         		db	"E"+80h
  231/ 1F0 : C1                         		db	"A"+80h
  232/ 1F1 : C4                         		db	"D"+80h
  233/ 1F2 : D9                         		db	"Y"+80h
  234/ 1F3 : 8D 8A 8A                   		db	215o,212o,212o	;DATA 215,212,212	; CARRIAGE RETURN, LINE FEED, LINE FEED;
  235/ 1F6 : 09                         		db	011o		;DATA 011
  236/ 1F7 :                            ;		db	" AT LINE "	;DATA " AT LINE "
  237/ 1F7 : A0                         		db	" "+80h
  238/ 1F8 : C1                         		db	"A"+80h
  239/ 1F9 : D4                         		db	"T"+80h
  240/ 1FA : A0                         		db	" "+80h
  241/ 1FB : CC                         		db	"L"+80h
  242/ 1FC : C9                         		db	"I"+80h
  243/ 1FD : CE                         		db	"N"+80h
  244/ 1FE : C5                         		db	"E"+80h
  245/ 1FF : A0                         		db	" "+80h
  246/ 200 :                            
  247/ 200 :                            	;; THIS SHOULD BE THE END OF PAGE 01
  248/ 200 :                            
  249/ 200 :                            ;	db	(200h-$) dup 0
  250/ 200 :                            
  251/ 200 :                                       ORG	0200h		;002#000		; START PAGE 02, THE CODE
  252/ 200 : 46 AD 02                   SYNTAX:    CALL	CLESYM             ;Clear the SYMBOL BUFFER area
  253/ 203 : 36 E0                                 MVI	L, 340o               ;Set L to start of LINE NUMBER BUFFER
  254/ 205 : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of LINE NUMBER BUFFER
  255/ 207 : 3E 00                                 MVI	M, 000o               ;Initialize line number buff by placing zero as (cc)
  256/ 209 : 36 81                                 MVI	L, 201o               ;Change pointer to syntax counter/pointer storage loc.
  257/ 20B : 3E 01                                 MVI	M, 001o               ;Set pointer to first character (after cc) in line buffer
  258/ 20D : 36 81                      SYNTX1:    MVI	L, 201o               ;Set pointer to syntax cntr/pntr storage location
  259/ 20F : 46 A0 02                              CALL	GETCHR             ;Fetch the character pointed to by contents of syntax
  260/ 212 : 68 24 02                              JZ	SYNTX2             ;Cntr/pntr from the line input buffer. If character was
  261/ 215 : 3C B0                                 CPI	260o               ;A space, ignore. Else, test to see if character was ASCII
  262/ 217 : 70 31 02                              JM	SYNTX3             ;Code for a decimal digit. If not a decimal digit, consider
  263/ 21A : 3C BA                                 CPI	272o               ;Line number to have been processed by jumping
  264/ 21C : 50 31 02                              JP	SYNTX3             ;Over the remainder of this SYNTX1 section.
  265/ 21F : 36 E0                                 MVI	L, 340o               ;If have decimal digit, set pointer to start of LINE
  266/ 221 : 46 CC 02                              CALL	CONCT1             ;NUMBER BUFFER and append incoming digit there.
  267/ 224 : 36 81                      SYNTX2:    MVI	L, 201o               ;Reset L to syntax cntr/pntr storage location. Call sub-
  268/ 226 : 46 03 03                              CALL	LOOP               ;Routine to advance pntr and test for end of inr)ut buffer
  269/ 229 : 48 0D 02                              JNZ	SYNTX1             ;If not end of input buffer, go back for next digit
  270/ 22C : 36 83                                 MVI	L, 203o               ;If end of buffer, only had a line number in the line.
  271/ 22E : 3E 00                                 MVI	M, 000o               ;Set pntr to TOKEN storage location. Set TOKEN = 000.
  272/ 230 : 07                                    RET                    ;Return to caller.
  273/ 231 : 36 81                      SYNTX3:    MVI	L, 201o               ;Reset pointer to syntax cntr/pntr and fetch
  274/ 233 : CF                                    MOV	B,M                    ;Position of next character after the line number
  275/ 234 : 36 82                                 MVI	L, 202o               ;Change pntr to SCAN pntr storage location
  276/ 236 : F9                                    MOV	M,B                    ;Store address when SCAN takes up after line number
  277/ 237 : 36 82                      SYNTX4:    MVI	L, 202o               ;Set pntr to SCAN pntr stomge location
  278/ 239 : 46 A0 02                              CALL	GETCHR             ;Fetch the character pointed to by contents of the SCAN
  279/ 23C : 68 54 02                              JZ	SYNTX6             ;Pointer storage location. If character was ASCII code
  280/ 23F : 3C BD                                 CPI	275o               ;For space, ignore. Else, compare character with "=" sign
  281/ 241 : 68 88 02                              JZ	SYNTX7             ;If is an equal sign, go set TOKEN for IMPLIED LET.
  282/ 244 : 3C A8                                 CPI	250o               ;Else, compare character with left parenthesis " ( "
  283/ 246 : 68 8D 02                              JZ	SYNTX8             ;If left parenthesis, go set TOKEN for implied array LET
  284/ 249 : 46 C8 02                              CALL	CONCTS             ;Otherwise, concatenate the character onto the string
  285/ 24C :                            ; MGA 4/2012 begin "fast SYNTX5" patch: 
  286/ 24C :                            ; the following patch doubles the overall speed of execution.  
  287/ 24C :                            ; It is similar to the approach taken on 8080 SCELBAL II in 1978 
  288/ 24C :                            ; it adhears to the rules for patches in issue 1 of SCELBAL update 
  289/ 24C :                            ;SYNTX6:   these four lines moved up w/o label
  290/ 24C : 36 82                                 MVI	L, 202o               ;Set L to SCAN pointer storage location
  291/ 24E :                            ;           LHI \HB\OLDPG26       ;** Set H to page of SCAN pointer stomge location
  292/ 24E :                            ;MGA 4/2012 except LHI needed at original place, not here 
  293/ 24E : 46 03 03                              CALL	LOOP               ;Call routine to advance pntr & test for end of In buffer
  294/ 251 : 48 37 02                              JNZ	SYNTX4             ;Go back and add another character to SYMBOL BUFF
  295/ 254 :                            SYNTX6:   ; MGA 4/2012 label here 
  296/ 254 :                            
  297/ 254 : 36 83                                 MVI	L, 203o               ;Being constructed in the SYMBOL BUFFER. Now set
  298/ 256 : 3E 01                                 MVI	M, 001o               ;Up TOKEN storage location to an initial value of 001.
  299/ 258 : 2E 17                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Set H to point to start of KEYWORD TABLE.
  300/ 25A : 36 00                                 MVI	L, 000o               ;Set L to point to start of KEYWORD TABLE.
  301/ 25C : 1E 16                      SYNTX5:    MVI	D,PG26 ;\HB\OLDPG26   ;** Set D to page of SYMBOL BUFFER
  302/ 25E : 26 50                                 MVI	E, 120o               ;Set E to start of SYMBOL BUFFER
  303/ 260 : 46 DA 02                              CALL	STRCP              ;Compare char string presently in SYMBOL BUFFER
  304/ 263 : 2B                                    RZ                    ;With entry in KEYWORD TABLE. Exit if match.
  305/ 264 : 46 EE 12                              CALL	SWITCH             ;TOKEN will be set to keyword found. Else, switch
  306/ 267 : 30                         SYNTXL:    INR	L                    ;Pointers to get table address back and advance pntr to
  307/ 268 : C7                                    MOV	A,M                    ;KEYWORD TABLE. Now look for start of next entry
  308/ 269 : 24 C0                                 ANI	300o               ;In KEYWORD TABLE by looking for (cc) byte which
  309/ 26B : 48 67 02                              JNZ	SYNTXL             ;Will NOT have a one in the two most sig. bits. Advance
  310/ 26E : 46 EE 12                              CALL	SWITCH             ;Pntr til next entry found. Then switch pointers apin so
  311/ 271 : 36 83                                 MVI	L, 203o               ;Table pointer is in D&E. Put addr of TOKEN in L.
  312/ 273 : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** And page of TOKEN in H. Fetch the value currently
  313/ 275 : CF                                    MOV	B,M                    ;In TOKEN and advance it to account for going on to
  314/ 276 : 08                                    INR	B                    ;The next entry in the KEYWORD TABLE.
  315/ 277 : F9                                    MOV	M,B                    ;Restore the updated TOKEN value back to storage.
  316/ 278 : 46 EE 12                              CALL	SWITCH             ;Restore the keyword table pointer back to H&L.
  317/ 27B : C1                                    MOV	A,B                    ;Put TOKEN count in ACC.
  318/ 27C : 3C 0D                                 CPI	015o               ;See if have tested all entries in the keyword table.
  319/ 27E : 48 5C 02                              JNZ	SYNTX5             ;If not, continue checking the keyword table.
  320/ 281 :                            ;MGA 4/2012 3 of 4 lines removed below (keep LHI)
  321/ 281 : 2E 16                                 MVI	H, 26o	;\HB\OLDPG26        ;** Set H to page of SCAN pointer stomge location
  322/ 283 :                            ; MGA 4/2012 end of "fast SYNTX5" patch: 
  323/ 283 : 36 83                                 MVI	L, 203o               ;And search table for KEYWORD again. Unless reach
  324/ 285 : 3E FF                                 MVI	M, 377o               ;End of line input buffer. In which case set TOKEN=377
  325/ 287 : 07                                    RET                    ;As an error indicator and exit to caMVI L,ng routine.
  326/ 288 : 36 83                      SYNTX7:    MVI	L, 203o               ;Set pointer to TOKEN storage register. Set TOKEN
  327/ 28A : 3E 0D                                 MVI	M, 015o               ;Equal to 015 when "=" sign found for IMPLIED LET.
  328/ 28C : 07                                    RET                    ;Exit to caMVI L,ng routine.
  329/ 28D : 36 83                      SYNTX8:    MVI	L, 203o               ;Set pointer to TOKEN storage register. Set TOKEN
  330/ 28F : 3E 0E                                 MVI	M, 016o               ;Equal to 016 when "(" found for IMPLIED array LET.
  331/ 291 : 07                                    RET                    ;Exit to calling routine.
  332/ 292 :                            
  333/ 292 :                                                              ;The following are subroutines used by SYNTAX and
  334/ 292 :                                                              ;other routines in SCELBAL.
  335/ 292 :                            
  336/ 292 : 06 C2                      BIGERR:    MVI	A, 302o               ;Load ASCII code for letters B and G to indicate BIG
  337/ 294 : 16 C7                                 MVI	C, 307o               ;ERROR (for when buffer, stack,etc., overflows).
  338/ 296 : 46 82 03                   ERROR:     CALL	ECHO               ;Call user provided display routine to print ASCII code
  339/ 299 : C2                                    MOV	A,C                    ;In accumulator. Transfer ASCII code from C to ACC
  340/ 29A : 46 82 03                              CALL	ECHO               ;And repeat to display error codes.
  341/ 29D : 44 D2 0A                              JMP	FINERR             ;Go cpmplete error message (AT LINE) as required.
  342/ 2A0 : C7                         GETCHR:    MOV	A,M                    ;Get pointer from memory location pointed to by H&L
  343/ 2A1 : 3C 50                                 CPI	120o               ;See if within range of line input buffer.
  344/ 2A3 : 50 92 02                              JP	BIGERR             ;If not then have an overflow condition = error.
  345/ 2A6 : F0                                    MOV	L,A                    ;Else can use it as addr of character to fetch from the
  346/ 2A7 : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** LINE INPUT BUFFER by setting up H too.
  347/ 2A9 : C7                                    MOV	A,M                    ;Fetch the character from the line input buffer.
  348/ 2AA : 3C A0                                 CPI	240o               ;See if it is ASCII code for space.
  349/ 2AC : 07                                    RET                    ;Return to caller with flags set according to comparison.
  350/ 2AD : 36 50                      CLESYM:    MVI	L, 120o               ;Set L to start of SYMBOL BUFFER.
  351/ 2AF : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of SYMBOL BUFFER.
  352/ 2B1 : 3E 00                                 MVI	M, 000o               ;Place a zero byte at start of SYMBOL BUFFER.
  353/ 2B3 : 07                                    RET                    ;To effectively clear the buffer. Then exit to caller.
  354/ 2B4 :                            
  355/ 2B4 :                            
  356/ 2B4 :                                                              ;Subroutine to concatenate (append) a character to the
  357/ 2B4 :                                                              ;SYMBOL BUFFER. Character must be alphanumeric.
  358/ 2B4 :                            
  359/ 2B4 : 3C C1                      CONCTA:    CPI	301o               ;See if character code less than that for letter A.
  360/ 2B6 : 70 BE 02                              JM	CONCTN             ;If so, go see if it is numeric.
  361/ 2B9 : 3C DB                                 CPI	333o               ;See if character code greater than that for letter Z.
  362/ 2BB : 70 C8 02                              JM	CONCTS             ;If not, have valid alphabetical character.
  363/ 2BE : 3C B0                      CONCTN:    CPI	260o               ;Else, see if character in valid numeric range.
  364/ 2C0 : 70 D7 02                              JM	CONCTE             ;If not, have an error condition.
  365/ 2C3 : 3C BA                                 CPI	272o               ;Continue to check for valid number.
  366/ 2C5 : 50 D7 02                              JP	CONCTE             ;If not, have an error condition.
  367/ 2C8 : 36 50                      CONCTS:    MVI	L, 120o               ;If character alphanumeric, can concatenate. Set pointer
  368/ 2CA : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** To starting address of SYMBOL BUFFER.
  369/ 2CC : D7                         CONCT1:    MOV	C,M                    ;Fetch old character count in SYMBOL BUFFER.
  370/ 2CD : 10                                    INR	C                    ;Increment the value to account for adding new
  371/ 2CE : FA                                    MOV	M,C                    ;Character to the buffer. Restore updated (cc).
  372/ 2CF : C8                                    MOV	B,A                    ;Save character to be appended in register B.
  373/ 2D0 : 46 1E 13                              CALL	INDEXC             ;Add (cc) to address in H & L to get new end of buffer
  374/ 2D3 : F9                                    MOV	M,B                    ;Address and append the new character to buffer
  375/ 2D4 : 06 00                                 MVI	A, 000o               ;Clear the accumulator
  376/ 2D6 : 07                                    RET                    ;Exit to caller
  377/ 2D7 : 44 6A 09                   CONCTE:    JMP	SYNERR             ;If character to be appended not alphanumeric, ERROR!
  378/ 2DA :                            
  379/ 2DA :                                                              ;Subroutine to compare
  380/ 2DA :                                                              ;character strings pointed to by
  381/ 2DA :                                                              ;register pairs D & E and H & L.
  382/ 2DA :                            
  383/ 2DA : C7                         STRCP:     MOV	A,M                    ;Fetch (cc) of first string.
  384/ 2DB : 46 EE 12                              CALL	SWITCH             ;Switch pointers and fetch length of second string (cc)
  385/ 2DE : CF                                    MOV	B,M                    ;Into register B. Compare the lengths of the two strings.
  386/ 2DF : B9                                    CMP	B                    ;If they are not the same
  387/ 2E0 : 0B                                    RNZ                    ;Return to caller with flags set to non-zero condition
  388/ 2E1 : 46 EE 12                              CALL	SWITCH             ;Else, exchange the pointers back to first string.
  389/ 2E4 : 46 FF 02                   STRCPL:    CALL	ADV                ;Advance the pointer to string number 1 and fetch a
  390/ 2E7 : C7                                    MOV	A,M                    ;Character from that string into the accumulator.
  391/ 2E8 : 46 EE 12                              CALL	SWITCH             ;Now switch the pointers to string number 2.
  392/ 2EB : 46 FF 02                              CALL	ADV                ;Advance the pointer in line number 2.
  393/ 2EE : BF                         STRCPE:    CMP	M                    ;Compare char in stxing 1 (ACC) to string 2 (memory)
  394/ 2EF : 0B                                    RNZ                    ;If not equal, return to cauer with flags set to non-zero
  395/ 2F0 : 46 EE 12                              CALL	SWITCH             ;Else, exchange pointers to restore pntr to string 1
  396/ 2F3 : 09                                    DCR	B                    ;Decrement the string length counter in register B
  397/ 2F4 : 48 E4 02                              JNZ	STRCPL             ;If not finiahed, continue testing entire string
  398/ 2F7 : 07                                    RET                    ;If complete match, return with flag in zero condition
  399/ 2F8 : C7                         STRCPC:    MOV	A,M                    ;Fetch character pointed to by pointer to string 1
  400/ 2F9 : 46 EE 12                              CALL	SWITCH             ;Exchange pointer to examine string 2
  401/ 2FC : 44 EE 02                              JMP	STRCPE             ;Continue the string comparison loop
  402/ 2FF :                            
  403/ 2FF :                                                              ;Subroutine to advance the two byte
  404/ 2FF :                                                              ;value in CPU registers H and L.
  405/ 2FF :                            
  406/ 2FF : 30                         ADV:       INR	L                    ;Advance value in register L.
  407/ 300 : 0B                                    RNZ                    ;If new value not zero, return to caller.
  408/ 301 : 28                                    INR	H                    ;Else must increment value in H
  409/ 302 : 07                                    RET                    ;Before retuming to caller
  410/ 303 :                            
  411/ 303 :                                                              ;Subroutine to advance a buffer pointer
  412/ 303 :                                                              ;and test to see if the end of the buffer
  413/ 303 :                                                              ;has been reached.
  414/ 303 :                            
  415/ 303 : CF                         LOOP:      MOV	B,M                    ;Fetch memory location pointed to by H & L into B.
  416/ 304 : 08                                    INR	B                    ;Increment the value.
  417/ 305 : F9                                    MOV	M,B                    ;Restore it back to memory.
  418/ 306 : 36 00                                 MVI	L, 000                ;Change pointer to start of INPUT LINE BUFFER
  419/ 308 : C7                                    MOV	A,M                    ;Fetch buffer length (cc) value into the accumulator
  420/ 309 : 09                                    DCR	B                    ;Make value in B original value
  421/ 30A : B9                                    CMP	B                    ;See if buffer length same as that in B
  422/ 30B : 07                                    RET                    ;Return with flags yielding results of the comparison
  423/ 30C :                            
  424/ 30C :                                                              ;The following subroutine is used to
  425/ 30C :                                                              ;input characters from the system's
  426/ 30C :                                                              ;input device (such as a keyboard)
  427/ 30C :                                                              ;into the LINE INPUT BUFFER. Routine has limited
  428/ 30C :                                                              ;editing capability included.
  429/ 30C :                                                              ;(Rubout = delete previous character(s) entered.)
  430/ 30C :                            ;;; This label, STRIN:	should be location 03 014 030ch
  431/ 30C : 16 00                      STRIN:     MVI	C, 000                ;Initialize register C to zero.
  432/ 30E : 46 91 03                   STRIN1:    CALL	CINPUT             ;Call user provided device input subroutine to fetch one
  433/ 311 : 3C FF                                 CPI	0FFH	;modifiedby gazelle 2025/6/1 ;377o  ;Character from the input device. Is it ASCII code for
  434/ 313 : 48 25 03                              JNZ	NOTDEL             ;Rubout? Skip to next section if not rubout.
  435/ 316 :                            ;          MVI	A, 0DCH	;modified by Gazelle 2025/6/1 ;334o ;Else, load ASCII code for backslash into ACC.
  436/ 316 :                            ;          CALL	ECHO	;modified by gazelle 2025/6/1 ;Call user display driver to present backslash as a delete
  437/ 316 : 11                                    DCR	C                    ;Indicator. Now decrement the input character counter.
  438/ 317 : 70 0C 03                              JM	STRIN              ;If at beginning of line do NOT decrement H and L.
  439/ 31A : 46 74 03                              CALL	DEC                ;Else, decrement H & L line pointer to erase previous
  440/ 31D : 06 DC                                 MVI	A, 0DCH	;modified by gazelle 2025/6/1
  441/ 31F : 46 82 03                              CALL	ECHO	;modified by gazelle 2025/6/1
  442/ 322 :                            
  443/ 322 : 44 0E 03                              JMP	STRIN1             ;Entry, then go back for a new input.
  444/ 325 : 3C 83                      NOTDEL:    CPI	203o               ;See if character inputted was'CONTROL C'
  445/ 327 : 68 CB 0A                              JZ	CTRLC              ;If so, stop inputting and go back to the EXECutive
  446/ 32A : 3C 8D                                 CPI	215o               ;If not, see if character was carriage-return
  447/ 32C : 68 42 03                              JZ	STRINF             ;If so, have end of line of input
  448/ 32F : 3C 8A                                 CPI	212o               ;If not, see if character was line-feed
  449/ 331 : 68 0E 03                              JZ	STRIN1             ;If so, ignore the input, get another character
  450/ 334 : 46 FF 02                              CALL	ADV                ;If none of the above, advance contents of H & L
  451/ 337 : 10                                    INR	C                    ;Increment the character counter
  452/ 338 : F8                                    MOV	M,A                    ;Store the new character in the line input buffer
  453/ 339 : C2                                    MOV	A,C                    ;Put new character count in the accumulator
  454/ 33A : 3C 50                                 CPI	120o               ;Make sure maximum buffer size not exceeded
  455/ 33C : 50 92 02                              JP	BIGERR             ;If buffer size exceeded, go display BG error message
  456/ 33F : 44 0E 03                              JMP	STRIN1             ;Else can go back to look for next input
  457/ 342 : CA                         STRINF:    MOV	B,C                    ;Transfer character count from C to B
  458/ 343 : 46 4B 03                              CALL	SUBHL              ;Subtract B from H & L to get starting address of
  459/ 346 : FA                                    MOV	M,C                    ;The string and place the character count (cc) there
  460/ 347 : 46 61 03                              CALL	CRLF               ;Provide a line ending CR & LF combination on the
  461/ 34A : 07                                    RET                    ;Display device. Then exit to caller.
  462/ 34B :                            
  463/ 34B :                                                              ;Subroutine to subtract contents of CPU register B from
  464/ 34B :                                                              ;the two byte value in CPU registers H & L.
  465/ 34B :                            
  466/ 34B : C6                         SUBHL:     MOV	A,L                    ;Load contents of register L into the accumulator
  467/ 34C : 91                                    SUB	B                    ;Subtract the contents of register B
  468/ 34D : F0                                    MOV	L,A                    ;Restore the new value back to L
  469/ 34E : 03                                    RNC                    ;If no carry, then no underflow. Exit to caller.
  470/ 34F : 29                                    DCR	H                    ;Else must also decrement contents of H.
  471/ 350 : 07                                    RET                    ;Before retuming to caller.
  472/ 351 :                            
  473/ 351 :                                                              ;Subroutine to display a character string on the system's
  474/ 351 :                                                              ;display device.
  475/ 351 :                            
  476/ 351 : D7                         TEXTC:     MOV	C,M                    ;Fetch (cc) from the first location in the buffer (H & L
  477/ 352 : C7                                    MOV	A,M                    ;Pointing there upon entry) into register B and ACC.
  478/ 353 : A0                                    ANA	A                    ;Test the character count value.
  479/ 354 : 2B                                    RZ                    ;No display if (cc) is zero.
  480/ 355 : 46 FF 02                   TEXTCL:    CALL	ADV                ;Advance pointer to next location in buffer
  481/ 358 : C7                                    MOV	A,M                    ;Fetch a character from the buffer into ACC
  482/ 359 : 46 82 03                              CALL	ECHO               ;Call the user's display driver subroutine
  483/ 35C : 11                                    DCR	C                    ;Decrement the (cc)
  484/ 35D : 48 55 03                              JNZ	TEXTCL             ;If character counter not zero, continue display
  485/ 360 : 07                                    RET                    ;Exit to caller when (cc) is zero.
  486/ 361 :                            
  487/ 361 :                                                              ;Subroutine to provide carriage-return and line-feed
  488/ 361 :                                                              ;combination to system's display device. Routine also
  489/ 361 :                                                              ;initializes a column counter to zero. Column counter
  490/ 361 :                                                              ;is used by selected output routines to count the num-
  491/ 361 :                                                              ;ber of characters that have been displayed on a line.
  492/ 361 :                            
  493/ 361 : 06 8D                      CRLF:      MVI	A, 215o               ;Load ASCII code for carriage-return into ACC
  494/ 363 : 46 82 03                              CALL	ECHO               ;Call user provided display driver subroutine
  495/ 366 : 06 8A                                 MVI	A, 212o               ;Load ASCII code for line-feed into ACC
  496/ 368 : 46 82 03                              CALL	ECHO               ;Call user provided display driver subroutine
  497/ 36B : 36 23                                 MVI	L, 043o               ;Set L to point to COLUMN COUNTER storage location
  498/ 36D : 2E 01                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to page of COLUMN COUNTER
  499/ 36F : 3E 01                                 MVI	M, 001o               ;Initialize COLUMN COUNTER to a value of one
  500/ 371 : EB                                    MOV	H,D                    ;Restore H from D (saved by ECHO subroutine)
  501/ 372 : F4                                    MOV	L,E                    ;Restore L from E (saved by ECHO subroutine)
  502/ 373 : 07                                    RET                    ;Then exit to calling routine
  503/ 374 :                            
  504/ 374 :                                                              ;Subroutine to decrement double-byte value in CPU
  505/ 374 :                                                              ;registers H and L.
  506/ 374 :                            
  507/ 374 : 31                         DEC:       DCR	L                    ;Decrement contents of L
  508/ 375 : 30                                    INR	L                    ;Now increment to exercise CPU flags
  509/ 376 : 48 7A 03                              JNZ	DECNO              ;If L not presently zero, skip decrementing H
  510/ 379 : 29                                    DCR	H                    ;Else decrement H
  511/ 37A : 31                         DECNO:     DCR	L                    ;Do the actual decrement of L
  512/ 37B : 07                                    RET                    ;Return to caller
  513/ 37C :                            
  514/ 37C :                            
  515/ 37C :                                                              ;Subroutine to index the value in CPU registers H and L
  516/ 37C :                                                              ;by the contents of CPU register B.
  517/ 37C :                            
  518/ 37C : C6                         INDEXB:    MOV	A,L                    ;Load L into the accumulator
  519/ 37D : 81                                    ADD	B                    ;Add B to that value
  520/ 37E : F0                                    MOV	L,A                    ;Restore the new value to L
  521/ 37F : 03                                    RNC                    ;If no carry,  return to caller
  522/ 380 : 28                                    INR	H                    ;Else, increment value in H
  523/ 381 : 07                                    RET                    ;Before returning to caller
  524/ 382 :                            
  525/ 382 :                                                              ;The following subroutine is used to
  526/ 382 :                                                              ;display the ASCII encoded character in the ACC on the
  527/ 382 :                                                              ;system's display device. This routine calls a routine
  528/ 382 :                                                              ;labeled CINPUT which must be provided by the user to
  529/ 382 :                                                              ;actually drive the system's output device. The subroutine
  530/ 382 :                                                              ;below also increments an output column counter each time
  531/ 382 :                                                              ;it is used.
  532/ 382 :                            
  533/ 382 : DD                         ECHO:      MOV	D,H                    ;Save entry value of H in register D
  534/ 383 : E6                                    MOV	E,L                    ;And save entry value of L in register E
  535/ 384 : 36 23                                 MVI	L, 043o               ;Set L to point to COLUMN COUNTER storage location
  536/ 386 : 2E 01                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to page of COLUMN COUNTER
  537/ 388 : CF                                    MOV	B,M                    ;Fetch the value in the COLUMN COUNTER
  538/ 389 : 08                                    INR	B                    ;And increment it for each character displayed
  539/ 38A : F9                                    MOV	M,B                    ;Restore the updated count in memory
  540/ 38B : 46 64 30                              CALL	CPRINT             ;tt Call the user's device driver subroutine
  541/ 38E : EB                                    MOV	H,D                    ;Restore entry value of H from D
  542/ 38F : F4                                    MOV	L,E                    ;Restore entry value of L from E
  543/ 390 : 07                                    RET                    ;Return to calling routine
  544/ 391 : 44 57 30                   CINPUT:	   JMP	CINP               ;Reference to user defined input subroutine
  545/ 394 :                            
  546/ 394 :                            ;;; The label EVAL: SHOULD BE AT 03 224 0394h
  547/ 394 : 36 97                      EVAL:      MVI	L, 227o               ;Load L with address of ARITHMETIC STACK pointer
  548/ 396 : 2E 01                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to page of ARITHMETIC STACK pointer
  549/ 398 : 3E 94                                 MVI	M, 224o               ;Initialize ARITH STACK pointer value to addr minus 4
  550/ 39A : 30                                    INR	L                    ;Advance memory pointer to FUN/ARRAY STACK pntr
  551/ 39B : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of FUN/ARRAY STACK pointer
  552/ 39D : 3E 00                                 MVI	M, 000o               ;Initialize FUNIARRAY STACK pointer to start of stack
  553/ 39F : 46 AD 02                              CALL	CLESYM             ;Initialize the SYMBOL BUFFER to empty condition
  554/ 3A2 : 36 88                                 MVI	L, 210o               ;Load L with address of OPERATOR STACK pointer
  555/ 3A4 : 3E 00                                 MVI	M, 000                ;Initialize OPERATOR STACK pointer value
  556/ 3A6 : 36 BE                                 MVI	L, 276o               ;Set L to address of EVAL pointer (start of expression)
  557/ 3A8 : CF                                    MOV	B,M                    ;Fetch the EVAL pointer value into register B
  558/ 3A9 : 36 80                                 MVI	L, 200o               ;Set up a working pointer register in this location
  559/ 3AB : F9                                    MOV	M,B                    ;And initialize EVAL CURRENT pointer
  560/ 3AC : 36 80                      SCAN1:     MVI	L, 200o               ;Load L with address of EVAL CURRENT pointer
  561/ 3AE : 46 A0 02                              CALL	GETCHR             ;Fetch a character in the expression being evaluated
  562/ 3B1 : 68 C1 04                              JZ	SCAN10             ;If character is a space, jump out of this section
  563/ 3B4 : 3C AB                                 CPI	253o               ;See if character is a "+" sign
  564/ 3B6 : 48 C0 03                              JNZ	SCAN2              ;If not, continue checking for an operator
  565/ 3B9 : 36 7E                                 MVI	L, 176o               ;If yes, set pointer to PARSER TOKEN storage location
  566/ 3BB : 3E 01                                 MVI	M, 001                ;Place TOKEN value for "+" sign in PARSER TOKEN
  567/ 3BD : 44 E9 03                              JMP	SCANFN             ;Go to PARSER subroutine entry point
  568/ 3C0 : 3C AD                      SCAN2:     CPI	255o               ;See if character is a minus ("-") sign
  569/ 3C2 : 48 EF 03                              JNZ	SCAN4              ;If not, continue checking for an operator
  570/ 3C5 : 36 50                                 MVI	L, 120o               ;If yes, check the length of the symbol stored in the
  571/ 3C7 : C7                                    MOV	A,M                    ;SYMBOL BUFFER by fetching the (cc) byte
  572/ 3C8 : A0                                    ANA	A                    ;And testing to see if (cc) is zero
  573/ 3C9 : 48 E5 03                              JNZ	SCAN3              ;If length not zero, then not a unary minus indicator
  574/ 3CC : 36 7E                                 MVI	L, 176o               ;Else, check to see if last operator was a right parenthesi
  575/ 3CE : C7                                    MOV	A,M                    ;By fetching the value in the PARSER TOKEN storage
  576/ 3CF : 3C 07                                 CPI	007                ;Location and seeing if it is token value for ")"
  577/ 3D1 : 68 E5 03                              JZ	SCAN3              ;If last operator was I')" then do not have a unary minus
  578/ 3D4 : 3C 03                                 CPI	003                ;Check to see if last operator was C4*~2
  579/ 3D6 : 68 6A 09                              JZ	SYNERR             ;If yes, then have a syntax error
  580/ 3D9 : 3C 05                                 CPI	005                ;Check to see if last operator was exponentiation
  581/ 3DB : 68 6A 09                              JZ	SYNERR             ;If yes, then have a syntax error
  582/ 3DE : 36 50                                 MVI	L, 120o               ;If none of the above, then minus sign is unary, put
  583/ 3E0 : 3E 01                                 MVI	M, 001                ;Character string representing the
  584/ 3E2 : 30                                    INR	L                    ;Value zero in the SYMBOL BUFFER in string format
  585/ 3E3 : 3E B0                                 MVI	M, 260o               ;(Character count (cc) followed by ASCII code for zero)
  586/ 3E5 : 36 7E                      SCAN3:     MVI	L, 176o               ;Set L to address of PARSER TOKEN storage location
  587/ 3E7 : 3E 02                                 MVI	M, 002                ;Set PARSER TOKEN value for minus operator
  588/ 3E9 : 46 D4 04                   SCANFN:    CALL	PARSER             ;Call the PARSER subroutine to process current symbol
  589/ 3EC : 44 C1 04                              JMP	SCAN10             ;And operator. Then jump to continue processing.
  590/ 3EF : 3C AA                      SCAN4:     CPI	252o               ;See if character fetched from expression is
  591/ 3F1 : 48 FB 03                              JNZ	SCAN5              ;If not, continue checking for an operator
  592/ 3F4 : 36 7E                                 MVI	L, 176o               ;If yes, set pointer to PARSER TOKEN storage location
  593/ 3F6 : 3E 03                                 MVI	M, 003                ;Place TOKEN value for "*" (multiplication) operator in
  594/ 3F8 : 44 E9 03                              JMP	SCANFN             ;PARSER TOKEN and go to PARSER subroutine entry
  595/ 3FB : 3C AF                      SCAN5:     CPI	257o               ;See if character fetched from expression is
  596/ 3FD : 48 07 04                              JNZ	SCAN6              ;If not, continue checking for an operator
  597/ 400 : 36 7E                                 MVI	L, 176o               ;If yes, set pointer to PARSER TOKEN storage location
  598/ 402 : 3E 04                                 MVI	M, 004                ;Place TOKEN value for "/" (division) operator in
  599/ 404 : 44 E9 03                              JMP	SCANFN             ;PARSER TOKEN and go to PARSER subroutine entry
  600/ 407 : 3C A8                      SCAN6:     CPI	250o               ;See if character fetched from expression is
  601/ 409 : 48 1B 04                              JNZ	SCAN7              ;If not, continue checking for an operator
  602/ 40C : 36 98                                 MVI	L, 230o               ;If yes, load L with address of FUN/ARRAY STACK
  603/ 40E : CF                                    MOV	B,M                    ;Pointer. Fetch the value in the stack pointer. Increment
  604/ 40F : 08                                    INR	B                    ;It to indicate number of "(" operators encountered.
  605/ 410 : F9                                    MOV	M,B                    ;Restore the updated stack pointer back to memory
  606/ 411 : 46 40 07                              CALL	FUNARR             ;Call subroutine to process possible FUNCTION or
  607/ 414 : 36 7E                                 MVI	L, 176o               ;ARRAY variable subscript. Ihen set pointer to
  608/ 416 : 3E 06                                 MVI	M, 006                ;PARSER TOKEN storage and set value for operator
  609/ 418 : 44 E9 03                              JMP	SCANFN             ;Go to PARSER subroutine entry point.
  610/ 41B : 3C A9                      SCAN7:     CPI	251o               ;See if character fetched from expression is
  611/ 41D : 48 34 04                              JNZ	SCAN8              ;If not, continue checking for an operator
  612/ 420 : 36 7E                                 MVI	L, 176o               ;If yes, load L with address of PARSER TOKEN
  613/ 422 : 3E 07                                 MVI	M, 007                ;Set PARSER TOKEN value to reflect ")"
  614/ 424 : 46 D4 04                              CALL	PARSER             ;Call the  PARSER subroutine to process current symbol
  615/ 427 :                            
  616/ 427 : 46 03 07                              CALL	PRIGHT             ;Call subroutine to handle FUNCTION or ARRAY
  617/ 42A : 36 98                                 MVI	L, 230o               ;Load L with address of FUN/ARRAY STACK pointer
  618/ 42C : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of FUN/ARRAY STACK pointer
  619/ 42E : CF                                    MOV	B,M                    ;Fetch the value in the stack pointer. Decrement it
  620/ 42F : 09                                    DCR	B                    ;To account for left parenthesis just processed.
  621/ 430 : F9                                    MOV	M,B                    ;Restore the updated value back to memory.
  622/ 431 : 44 C1 04                              JMP	SCAN10             ;Jump to continue processing expression.
  623/ 434 : 3C DE                      SCAN8:     CPI	336o               ;See if character fetched from expression is " t
  624/ 436 : 48 40 04                              JNZ	SCAN9              ;If not, continue checking for an operator
  625/ 439 : 36 7E                                 MVI	L, 176o               ;If yes, load L with address of PARSER TOKEN
  626/ 43B : 3E 05                                 MVI	M, 005                ;Put in value for exponentiation
  627/ 43D : 44 E9 03                              JMP	SCANFN             ;Go to PARSER subroutine entry point.
  628/ 440 : 3C BC                      SCAN9:     CPI	274o               ;See if character fetched is the "less than" sign
  629/ 442 : 48 63 04                              JNZ	SCAN11             ;If not, continue checking for an operator
  630/ 445 : 36 80                                 MVI	L, 200o               ;If yes, set L to the EVAL CURRENT pointer
  631/ 447 : CF                                    MOV	B,M                    ;Fetch the pointer
  632/ 448 : 08                                    INR	B                    ;Increment it to point to the next character
  633/ 449 : F9                                    MOV	M,B                    ;Restore the updated pointer value
  634/ 44A : 46 A0 02                              CALL	GETCHR             ;Fetch the next character in the expression
  635/ 44D : 3C BD                                 CPI	275o               ;Is the character the "= 9 $ sign?
  636/ 44F : 68 A9 04                              JZ	SCAN13             ;If so, have 'less than or equal" combination
  637/ 452 : 3C BE                                 CPI	276o               ;Is the character the "greater than" sign?
  638/ 454 : 68 B7 04                              JZ	SCAN15             ;If so, have "less than or greater than" combination
  639/ 457 : 36 80                                 MVI	L, 200o               ;Else character is not part of the operator. Set L back
  640/ 459 : CF                                    MOV	B,M                    ;To the EVAL CURRENT pointer. Fetch the pointer
  641/ 45A : 09                                    DCR	B                    ;Value and decriment it back one character in the
  642/ 45B : F9                                    MOV	M,B                    ;Expression. Restore the original pointer value.
  643/ 45C : 36 7E                                 MVI	L, 176o               ;Have just the 'less than" operator. Set L to the
  644/ 45E : 3E 09                                 MVI	M, 011o               ;PARSER TOKEN storage location and set the value for
  645/ 460 : 44 E9 03                              JMP	SCANFN             ;The 'less than" sign then go to PARSER entry point.
  646/ 463 : 3C BD                      SCAN11:    CPI	275o               ;See if character fetched is the "= " sign
  647/ 465 : 48 86 04                              JNZ	SCAN12             ;If not, continue checking for an operator
  648/ 468 : 36 80                                 MVI	L, 200o               ;If yes, set L to the EVAL CURRENT pointer
  649/ 46A : CF                                    MOV	B,M                    ;Fetch the pointer
  650/ 46B : 08                                    INR	B                    ;Increment it to point to the next character
  651/ 46C : F9                                    MOV	M,B                    ;Restore the updated pointer value
  652/ 46D : 46 A0 02                              CALL	GETCHR             ;Fetch the next character in the expression
  653/ 470 : 3C BC                                 CPI	274o               ;Is the character the "less than" sign?
  654/ 472 : 68 A9 04                              JZ	SCAN13             ;If so, have "less than or equal" combination
  655/ 475 : 3C BE                                 CPI	276o               ;Is the character the "greater than" sign?
  656/ 477 : 68 B0 04                              JZ	SCAN14             ;If so, have "equal or greater than" combination
  657/ 47A : 36 80                                 MVI	L, 200o               ;Else character is not part of the operator. Set L back
  658/ 47C : CF                                    MOV	B,M                    ;To the EVAL CURRENT pointer. Fetch the pointer
  659/ 47D : 09                                    DCR	B                    ;Value and decrement it back one character in the
  660/ 47E : F9                                    MOV	M,B                    ;Expression. Restore the original pointer value.
  661/ 47F : 36 7E                                 MVI	L, 176o               ;Just have '~-- " operator. Set L to the PARSER TOKEN
  662/ 481 : 3E 0A                                 MVI	M, 012o               ;Storage location and set the value for the sign.
  663/ 483 : 44 E9 03                              JMP	SCANFN             ;Go to the PARSER entry point.
  664/ 486 : 3C BE                      SCAN12:    CPI	276o               ;See if character fetched is the "greater than" sign
  665/ 488 : 48 BE 04                              JNZ	SCAN16             ;If not, go append the character to the SYMBOL BUFF
  666/ 48B : 36 80                                 MVI	L, 200o               ;If so, set L to the EVAL CURRENT pointer
  667/ 48D : CF                                    MOV	B,M                    ;Fetch the pointer
  668/ 48E : 08                                    INR	B                    ;Increment it to point to the next character
  669/ 48F : F9                                    MOV	M,B                    ;Restore the updated pointer value
  670/ 490 : 46 A0 02                              CALL	GETCHR             ;Fetch the next character in the expression
  671/ 493 : 3C BC                                 CPI	274o               ;Is the character the "less than" sign?
  672/ 495 : 68 B7 04                              JZ	SCAN15             ;If so, have "less than or greater than" combination
  673/ 498 : 3C BD                                 CPI	275o               ;Is the character the "= " sign?
  674/ 49A : 68 B0 04                              JZ	SCAN14             ;If so, have the "equal to or greater than " combination
  675/ 49D : 36 80                                 MVI	L, 200o               ;Else character is not part of the operator. Set L back
  676/ 49F : CF                                    MOV	B,M                    ;To the EVAL CURRENT pointer. Fetch the pointer
  677/ 4A0 : 09                                    DCR	B                    ;Value and decrement it back one character in the
  678/ 4A1 : F9                                    MOV	M,B                    ;Expression. Restore the original pointer value.
  679/ 4A2 : 36 7E                                 MVI	L, 176o               ;Have just the "greater than" operator. Set L to the
  680/ 4A4 : 3E 0B                                 MVI	M, 013o               ;PARSER TOKEN storage location and set the value for
  681/ 4A6 : 44 E9 03                              JMP	SCANFN             ;The "greater than" sign then go to PARSER entry
  682/ 4A9 : 36 7E                      SCAN13:    MVI	L, 176o               ;When have 'less than or equal" combination set L to
  683/ 4AB : 3E 0C                                 MVI	M, 014o               ;PARSER TOKEN storage location and set the value.
  684/ 4AD : 44 E9 03                              JMP	SCANFN             ;Then go to the PARSER entry point.
  685/ 4B0 : 36 7E                      SCAN14:    MVI	L, 176o               ;When have "equal to or greater than" combination set L
  686/ 4B2 : 3E 0D                                 MVI	M, 015o               ;To PARSER TOKEN storage location and set the value.
  687/ 4B4 : 44 E9 03                              JMP	SCANFN             ;Then go to the PARSER entry point.
  688/ 4B7 : 36 7E                      SCAN15:    MVI	L, 176o               ;When have 'less than or greater than" combination set
  689/ 4B9 : 3E 0E                                 MVI	M, 016o               ;L to PARSER TOKEN storage location and set value.
  690/ 4BB : 44 E9 03                              JMP	SCANFN             ;Then go to the PARSER entry point.
  691/ 4BE : 46 C8 02                   SCAN16:    CALL	CONCTS             ;Concatenate the character to the SYMBOL BUFFER
  692/ 4C1 : 36 80                      SCAN10:    MVI	L, 200o               ;Set L to the EVAL CURRENT pointer storage location
  693/ 4C3 : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of EVAL CURRENT pointer
  694/ 4C5 : CF                                    MOV	B,M                    ;Fetch the EVAL CURRENT pointer value into B
  695/ 4C6 : 08                                    INR	B                    ;Increment the pointer value to point to next character
  696/ 4C7 : F9                                    MOV	M,B                    ;In the expression and restore the updated value.
  697/ 4C8 : 36 BF                                 MVI	L, 277o               ;Set L to EVAL FINISH storage location.
  698/ 4CA : C7                                    MOV	A,M                    ;Fetch the EVAL FINISH value into the accumulator.
  699/ 4CB : 09                                    DCR	B                    ;Set B to last character processed in the expression.
  700/ 4CC : B9                                    CMP	B                    ;See if last character was at EVAL FINISH location.
  701/ 4CD : 48 AC 03                              JNZ	SCAN1              ;If not, continue processing the expression. Else, jump
  702/ 4D0 : 44 C0 19                              JMP	PARSEP             ;To final evaluation procedure and test.  (Directs routine
  703/ 4D3 : 00                                    HLT             ;To a dislocated section.) Safety Halt in unused byte.
  704/ 4D4 : 36 50                      PARSER:    MVI	L, 120o               ;Load L with starting address of SYMBOL BUFFER
  705/ 4D6 : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of SYMBOL BUFFER
  706/ 4D8 : C7                                    MOV	A,M                    ;Fetch the (cc) for  contents of SYMBOL BUFFER
  707/ 4D9 : A0                                    ANA	A                    ;Into the ACC and see if buffer is  empty
  708/ 4DA : 68 99 05                              JZ	PARSE              ;If empty then no need to convert contents
  709/ 4DD : 30                                    INR	L                    ;If not empty, advance buffer pointer
  710/ 4DE : C7                                    MOV	A,M                    ;Fetch the first character in the buffer
  711/ 4DF : 3C AE                                 CPI	256o               ;See if it is ASCII code for decimal sign
  712/ 4E1 : 68 EE 04                              JZ	PARNUM             ;If yes, consider contents of buffer to be a number
  713/ 4E4 : 3C B0                                 CPI	260o               ;If not decimal sign, see if first character represents
  714/ 4E6 : 70 1B 05                              JM	LOOKUP             ;A deciinal digit, if not, should have a variable
  715/ 4E9 : 3C BA                                 CPI	272o               ;Continue to test for a decimal digit
  716/ 4EB : 50 1B 05                              JP	LOOKUP             ;If not, go look up the variable nwne
  717/ 4EE : 31                         PARNUM:    DCR	L                    ;If SYMBOL BUFFER contains number, decrement
  718/ 4EF : C7                                    MOV	A,M                    ;Buffer pointer back to (cc) and fetch it to ACC
  719/ 4F0 : 3C 01                                 CPI	001o               ;See if length of string in buffer is just one
  720/ 4F2 : 68 05 05                              JZ	NOEXPO             ;If so, cannot have number with scientific notation
  721/ 4F5 : 86                                    ADD	L                    ;If not, add length to buffer pointer to
  722/ 4F6 : F0                                    MOV	L,A                    ;Point to last character in the buffer
  723/ 4F7 : C7                                    MOV	A,M                    ;Fetch the last character in buffer and see if it
  724/ 4F8 : 3C C5                                 CPI	305o               ;Represents letter E for Exponent
  725/ 4FA : 48 05 05                              JNZ	NOEXPO             ;If not, cannot have number with scientific notation
  726/ 4FD : 36 80                                 MVI	L, 200o               ;If yes, have part of a scientific number, set pointer to
  727/ 4FF : 46 A0 02                              CALL	GETCHR             ;Get the operator that follows the E and append it to
  728/ 502 : 44 C8 02                              JMP	CONCTS             ;The SYMBOL BUFFER and return to EVAL routine
  729/ 505 : 36 97                      NOEXPO:    MVI	L, 227o               ;Load L with address of ARITHMETIC STACK pointer
  730/ 507 : 2E 01                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Load H with page of ARITHMETIC STACK pointer
  731/ 509 : C7                                    MOV	A,M                    ;Fetch AS pointer value to ACC and add four to account
  732/ 50A : 04 04                                 ADI	004o               ;For the number of bytes required to store a number in
  733/ 50C : F8                                    MOV	M,A                    ;Floating point format. Restore pointer to mernory.
  734/ 50D : F0                                    MOV	L,A                    ;Then, change L to point to entry position in the AS
  735/ 50E : 46 AD 12                              CALL	FSTORE             ;Place contents of the FPACC onto top of the AS
  736/ 511 : 36 50                                 MVI	L, 120o               ;Change L to point to start of the SYMBOL BUFFER
  737/ 513 : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of the SYMBOL BUFFER
  738/ 515 : 46 24 13                              CALL	DINPUT             ;Convert number in the buffer to floating point format
  739/ 518 : 44 99 05                              JMP	PARSE              ;In the FPACC then jump to check operator sign.
  740/ 51B : 36 F8                      LOOKUP:    MVI	L, 370o               ;Load L with address of LOOK-UP COUNTER
  741/ 51D : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of the counter
  742/ 51F : 3E 00                                 MVI	M, 000                ;Initialize the counter to zero
  743/ 521 : 36 50                                 MVI	L, 120o               ;Load L with starting address of the SYMBOL BUFFER
  744/ 523 : 1E 17                                 MVI	D,PG27 ;\HB\OLDPG27   ;** Load D with page of the VARIABLES TABLE
  745/ 525 : 26 88                                 MVI	E, 210o               ;Load E with start of the VARL433LES TABLE
  746/ 527 : C7                                    MOV	A,M                    ;Fetch the (cc) for the string in the SYMBOL BUFFER
  747/ 528 : 3C 01                                 CPI	001                ;See if the name length is just one character. If not,
  748/ 52A : 48 31 05                              JNZ	LOOKU1             ;Should be two so proceed to look-up routine. Else,
  749/ 52D : 36 52                                 MVI	L, 122o               ;Change L to second character byte in the buffer and set
  750/ 52F : 3E 00                                 MVI	M, 000                ;It to zero to provide compatibility with entries in table
  751/ 531 : 36 51                      LOOKU1:    MVI	L, 121o               ;Load L with addr of first character in the SYMBOL
  752/ 533 : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** BUFFER. Set H to page of the SYMBOL BUFFER.
  753/ 535 : 46 EE 12                              CALL	SWITCH             ;Exchange contents of D&E with H&L so that can
  754/ 538 : C7                                    MOV	A,M                    ;Fetch the first character of a name in the VARIABLES
  755/ 539 : 30                                    INR	L                    ;TABLE. Advance the table pointer and save the
  756/ 53A : CF                                    MOV	B,M                    ;Second byte of name in B. Then advance the pointer
  757/ 53B : 30                                    INR	L                    ;Again to reach first bvte of floating point forrnatted
  758/ 53C : 46 EE 12                              CALL	SWITCH             ;Number in table. Now exchange D&E with H&L and
  759/ 53F : BF                                    CMP	M                    ;Compare first byte in table against first char in buffer
  760/ 540 : 48 49 05                              JNZ	LOOKU2             ;If not the same, go try next entry in table. If same,
  761/ 543 : 30                                    INR	L                    ;Advance pointer to next char in buffer. Transfer the
  762/ 544 : C1                                    MOV	A,B                    ;Character in B (second byte in table entry) to the ACC
  763/ 545 : BF                                    CMP	M                    ;Compare it against second character in the buffer.
  764/ 546 : 68 81 05                              JZ	LOOKU4             ;If match, have found the name in the VARIABLES tbl.
  765/ 549 : 46 AE 06                   LOOKU2:    CALL	AD4DE              ;Call subroutine to add four to the pointer in D&E to
  766/ 54C : 36 F8                                 MVI	L, 370o               ;Advance the table pointer over value bytes. Then set
  767/ 54E : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Up H and L to point to LOOK-UP COUNTER.
  768/ 550 : CF                                    MOV	B,M                    ;Fetch counter value (counts number of entries tested
  769/ 551 : 08                                    INR	B                    ;In the VARIABLES TABLE), increment it
  770/ 552 : F9                                    MOV	M,B                    ;And restore it back to meynory
  771/ 553 : 36 3F                                 MVI	L, 077o               ;Load L with address of SYMBOL VARIABLES counter
  772/ 555 : 2E 17                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Do same for H. (Counts number of names in table.)
  773/ 557 : C1                                    MOV	A,B                    ;Place LOOK-UP COUNTER value in the accumulator.
  774/ 558 : BF                                    CMP	M                    ;Compare it with number of entries in the table.
  775/ 559 : 48 31 05                              JNZ	LOOKU1             ;If have not reached end of table, keep looking for name.
  776/ 55C : 36 3F                                 MVI	L, 077o               ;If reach end of table without match, need to add name
  777/ 55E : 2E 17                                 MVI	H,PG27 ;\HB\OLDPG27   ;** To table. First set H & L to the SYMBOL
  778/ 560 : CF                                    MOV	B,M                    ;VARIABLES counter. Fetch the counter value and
  779/ 561 : 08                                    INR	B                    ;Increment to account for new name being added to the
  780/ 562 : F9                                    MOV	M,B                    ;Table. Restore the updated count to meinory. Also,
  781/ 563 : C1                                    MOV	A,B                    ;Move the new counter value to the accumulator and
  782/ 564 : 3C 15                                 CPI	025o               ;Check to see that table size is not exceeded. If try to
  783/ 566 : 50 92 02                              JP	BIGERR             ;Go over 20 (decirnal) entries then have BIG error.
  784/ 569 : 36 51                                 MVI	L, 121o               ;Else, set L to point to first character in the SYMBOL
  785/ 56B : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** BUFFER and set H to proper page. Set the number
  786/ 56D : 0E 02                                 MVI	B, 002                ;Of bytes to be transferred into register B as a counter.
  787/ 56F : 46 0B 11                              CALL	MOVEIT             ;Move the symbol name from the buffer to the
  788/ 572 : F4                                    MOV	L,E                    ;VARIABLES TABLE. Now set up H & L with value
  789/ 573 : EB                                    MOV	H,D                    ;Contained in D & E after moving ops (points to first
  790/ 574 : A8                                    XRA	A                    ;Byte of the value to be associated with the symbol
  791/ 575 : F8                                    MOV	M,A                    ;Name.) Clear the accumulator and place zero in all four
  792/ 576 : 30                                    INR	L                    ;Bytes associated with the variable name entered
  793/ 577 : F8                                    MOV	M,A                    ;In the VARIABLES TABLE
  794/ 578 : 30                                    INR	L                    ;In order to
  795/ 579 : F8                                    MOV	M,A                    ;Assign an
  796/ 57A : 30                                    INR	L                    ;Initial value
  797/ 57B : F8                                    MOV	M,A                    ;To the variable narne
  798/ 57C : C6                                    MOV	A,L                    ;Then transfer the address in L to the acc'umulator
  799/ 57D : 14 04                                 SUI	004                ;Subtract four to reset the pointer to start of zeroing ops
  800/ 57F : E0                                    MOV	E,A                    ;Restore the address in D & E to be in same state as if
  801/ 580 : DD                                    MOV	D,H                    ;Name was found in the table in the LOOKUP routine
  802/ 581 : 46 CF 12                   LOOKU4:    CALL	SAVEHL             ;Save current address to VARIABLES TABLE
  803/ 584 : 36 97                                 MVI	L, 227o               ;Load L with address of ARITHMETIC STACK pointer
  804/ 586 : 2E 01                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Load H with page of the pointer
  805/ 588 : C7                                    MOV	A,M                    ;Fetch the AS pointer value to the accumulator
  806/ 589 : 04 04                                 ADI	004                ;Add four to account for next floating point forrnatted
  807/ 58B : F8                                    MOV	M,A                    ;Number to be stored in the stack. Restore the stack
  808/ 58C : F0                                    MOV	L,A                    ;Pointer to memory and set it up in register L too.
  809/ 58D : 46 AD 12                              CALL	FSTORE             ;Place the value in the FPACC on the top of the
  810/ 590 : 46 DF 12                              CALL	RESTHL             ;ARITHMETIC STACK. Restore the VARIABLES
  811/ 593 : 46 EE 12                              CALL	SWITCH             ;TABLE pointer to H&L and move it to D&E. Now load
  812/ 596 : 46 A4 12                              CALL	FLOAD              ;The VARIABLE value from the table to the FPACC.
  813/ 599 : 46 AD 02                   PARSE:     CALL	CLESYM             ;Clear the SYMBOL BUFFER
  814/ 59C : 36 7E                                 MVI	L, 176o               ;Load L with address of PARSER TOKEN VALUE
  815/ 59E : C7                                    MOV	A,M                    ;And fetch the token value into the accumulator
  816/ 59F : 3C 07                                 CPI	007                ;Is it token value for right parenthesis ")" ? If so, have
  817/ 5A1 : 68 DA 05                              JZ	PARSE2             ;Special case where must perforin ops til find a "(" !
  818/ 5A4 : 04 A0                                 ADI	240o               ;Else, fon-n address to HEIRARCHY IN table and
  819/ 5A6 : F0                                    MOV	L,A                    ;Set L to point to HEIRARCHY IN VALUE in the table
  820/ 5A7 : CF                                    MOV	B,M                    ;Fetch the heirarchy value from the table to register B
  821/ 5A8 : 36 88                                 MVI	L, 210o               ;Set L to OPERATOR STACK pointer storage location
  822/ 5AA : D7                                    MOV	C,M                    ;Fetch the OS pointer into CPU register C
  823/ 5AB : 46 1E 13                              CALL	INDEXC             ;Add OS pointer to address of OS pointer storage loc
  824/ 5AE : C7                                    MOV	A,M                    ;Fetch the token value for the operator at top of the OS
  825/ 5AF : 04 AF                                 ADI	257o               ;And form address to HEIRARCHY OUT table
  826/ 5B1 : F0                                    MOV	L,A                    ;Set L to point to HEIRARCHY OUT VALUE in the
  827/ 5B2 : C1                                    MOV	A,B                    ;Table. Move the HEIRARCHY IN value to the ACC.
  828/ 5B3 : BF                                    CMP	M                    ;Compare the HEIRARCHY IN with the HEIRARCHY
  829/ 5B4 : 68 C7 05                              JZ	PARSE1             ;OUT value. If heirarchy of current operator equal to or
  830/ 5B7 : 70 C7 05                              JM	PARSE1             ;Less than operator on top of OS stack, perfo
  831/ 5BA : 36 7E                                 MVI	L, 176o               ;Operation indicated in top of OS stack. Else, fetch the
  832/ 5BC : CF                                    MOV	B,M                    ;Current operator token value into register B.
  833/ 5BD : 36 88                                 MVI	L, 210o               ;Load L with address of the OPERATOR STACK pntr
  834/ 5BF : D7                                    MOV	C,M                    ;Fetch the stack pointer value
  835/ 5C0 : 10                                    INR	C                    ;Increment it to account for new entry on the stack
  836/ 5C1 : FA                                    MOV	M,C                    ;Restore the stack pointer value to memory
  837/ 5C2 : 46 1E 13                              CALL	INDEXC             ;For in pointer to next entry in OPERATOR STACK
  838/ 5C5 : F9                                    MOV	M,B                    ;Place the current operator token value on top of the OS
  839/ 5C6 : 07                                    RET                    ;Exit back to the EVAL routine.
  840/ 5C7 : 36 88                      PARSE1:    MVI	L, 210o               ;Load L with address of the OPERATOR STACK pntr
  841/ 5C9 : C7                                    MOV	A,M                    ;Fetch the stack pointer value to the accumulator
  842/ 5CA : 86                                    ADD	L                    ;Add in the value of the stack pointer address to form
  843/ 5CB : F0                                    MOV	L,A                    ;Address that points to top entry in the OS
  844/ 5CC : C7                                    MOV	A,M                    ;Fetch the token value at the top of the OS to the ACC
  845/ 5CD : A0                                    ANA	A                    ;Check to see if the token value is zero for end of stack
  846/ 5CE : 2B                                    RZ                    ;Exit back to the EVAL routine if stack empty
  847/ 5CF : 36 88                                 MVI	L, 210o               ;Else, reset L to the OS pointer storage location
  848/ 5D1 : D7                                    MOV	C,M                    ;Fetch the pointer value
  849/ 5D2 : 11                                    DCR	C                    ;Decrement it to account for operator rernoved from
  850/ 5D3 : FA                                    MOV	M,C                    ;The OPERATOR STACK and restore the pointer value
  851/ 5D4 : 46 F4 05                              CALL	FPOPER             ;Perform the operation obtained from the top of the OS
  852/ 5D7 : 44 99 05                              JMP	PARSE              ;Continue to compare current operator against top of OS
  853/ 5DA : 36 88                      PARSE2:    MVI	L, 210o               ;Load L with address of the OPERATOR STACK pntr
  854/ 5DC : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of the pointer
  855/ 5DE : C7                                    MOV	A,M                    ;Fetch the stack pointer value to the accumulator
  856/ 5DF : 86                                    ADD	L                    ;Add in the value of the stack pointer address to form
  857/ 5E0 : F0                                    MOV	L,A                    ;Address that points to top entry in the OS
  858/ 5E1 : C7                                    MOV	A,M                    ;Fetch the token value at the top of the 0 S to the ACC
  859/ 5E2 : A0                                    ANA	A                    ;Check to see if the token value is zero for end of stack
  860/ 5E3 : 68 44 06                              JZ	PARNER             ;If end of stack, then have a parenthesis error condx
  861/ 5E6 : 36 88                                 MVI	L, 210o               ;Else, reset L to the OS pointer storage location
  862/ 5E8 : D7                                    MOV	C,M                    ;Fetch the pointer value
  863/ 5E9 : 11                                    DCR	C                    ;Decrement it to account for operator removed from
  864/ 5EA : FA                                    MOV	M,C                    ;The OPERATOR STACK and restore the pointer value
  865/ 5EB : 3C 06                                 CPI	006                ;Check to see if token value is "(" to close parenthesis
  866/ 5ED : 2B                                    RZ                    ;If so, exit back to EVAL routine.
  867/ 5EE : 46 F4 05                              CALL	FPOPER             ;Else, perforin the op obtained from the top of the OS
  868/ 5F1 : 44 DA 05                              JMP	PARSE2             ;Continue to process data in parenthesis
  869/ 5F4 : 36 F9                      FPOPER:    MVI	L, 371o               ;Load L with address of TEMP OP storage location
  870/ 5F6 : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of TEMP OP storage location
  871/ 5F8 : F8                                    MOV	M,A                    ;Store OP (from top of OPERATOR STACK)
  872/ 5F9 : 36 97                                 MVI	L, 227o               ;Change L to address of ARff HMETIC STACK pointer
  873/ 5FB : 2E 01                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Load H with page of AS pointer
  874/ 5FD : C7                                    MOV	A,M                    ;Fetch AS pointer value into ACC
  875/ 5FE : F0                                    MOV	L,A                    ;Set L to top of ARITHMETIC STACK
  876/ 5FF : 46 B6 12                              CALL	OPLOAD             ;Transfer number from ARffHMETIC STACK to FPOP
  877/ 602 : 36 97                                 MVI	L, 227o               ;Restore pointer to AS pointer
  878/ 604 : C7                                    MOV	A,M                    ;Fetch the pointer value to the ACC and subtract four
  879/ 605 : 14 04                                 SUI	004                ;To remove top value from the ARITHMETIC STACK
  880/ 607 : F8                                    MOV	M,A                    ;Restore the updated AS pointer to memory
  881/ 608 : 36 F9                                 MVI	L, 371o               ;Set L to address of TEMP OP storage location
  882/ 60A : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of TEMP OP storage location
  883/ 60C : C7                                    MOV	A,M                    ;Fetch the operator token value to the ACC
  884/ 60D : 3C 01                                 CPI	001                ;Find out which kind of operation indicated
  885/ 60F : 68 89 10                              JZ	FPADD              ;Perforn addition if have plus operator
  886/ 612 : 3C 02                                 CPI	002                ;If not plus, see if minus
  887/ 614 : 68 1A 11                              JZ	FPSUB              ;Perform subtraction if have minus operator
  888/ 617 : 3C 03                                 CPI	003                ;If not minus, see if multiplication
  889/ 619 : 68 26 11                              JZ	FPMULT             ;Perform multiplication if have multiplication operator
  890/ 61C : 3C 04                                 CPI	004                ;If not multiplication, see if division
  891/ 61E : 68 D2 11                              JZ	FPDIV              ;Perform division if have division operator
  892/ 621 : 3C 05                                 CPI	005                ;If not division, see if exponentiation
  893/ 623 : 68 B3 06                              JZ	INTEXP             ;Perform exponentiation if have exponentiation operator
  894/ 626 : 3C 09                                 CPI	011o               ;If not exponentiation, see if "less than" operator
  895/ 628 : 68 51 06                              JZ	LT                 ;Perform compaison for "less than" op if indicated
  896/ 62B : 3C 0A                                 CPI	012o               ;If not 'less than" see if have "equal" operator
  897/ 62D : 68 5E 06                              JZ	EQ                 ;Perforin comparison for "equal" op if indicated
  898/ 630 : 3C 0B                                 CPI	013o               ;If not "equal" see if have "greater than" operator
  899/ 632 : 68 6B 06                              JZ	GT                 ;Perform comparison for "greater than" op if indicated
  900/ 635 : 3C 0C                                 CPI	014o               ;If not "'greater than" see if have 'less than or equal" op
  901/ 637 : 68 7B 06                              JZ	LE                 ;Perform comparison for the combination op if indicated
  902/ 63A : 3C 0D                                 CPI	015o               ;See if have "equal to or greater than" operator
  903/ 63C : 68 8B 06                              JZ	GE                 ;Perform comparison for the combination op if indicated
  904/ 63F : 3C 0E                                 CPI	016o               ;See if have "less than or greater than" operator
  905/ 641 : 68 98 06                              JZ	NE                 ;Perform comparison for the combination op if indicated
  906/ 644 : 36 98                      PARNER:    MVI	L, 230o               ;If cannot find operator, expression is not balanced
  907/ 646 : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H and L to address of F/A STACK pointer
  908/ 648 : 3E 00                                 MVI	M, 000                ;Clear the F/A STACK pointer to re-initialize
  909/ 64A : 06 C9                                 MVI	A, 311o               ;Load ASCII code for letter I into the accumulator
  910/ 64C : 16 A8                                 MVI	C, 250o               ;And code for "(" character into register C
  911/ 64E : 44 96 02                              JMP	ERROR              ;Go display 1( for "Imbalanced Parenthesis") error msg
  912/ 651 : 46 1A 11                   LT:        CALL	FPSUB              ;Subtract contents of FPACC from FPOP to compare
  913/ 654 : 36 56                                 MVI	L, 126o               ;Set L to point to the MSW of the FPACC (Contains
  914/ 656 : C7                                    MOV	A,M                    ;Result of the subtraction.) Fetch the MSW of the
  915/ 657 : A0                                    ANA	A                    ;FPACC to the accumulator and test to see if result is
  916/ 658 : 70 A2 06                              JM	CTRUE              ;Positive or negative. Set up the FPACC as a function
  917/ 65B : 44 A7 06                              JMP	CFALSE             ;Of the result obtained.
  918/ 65E : 46 1A 11                   EQ:        CALL	FPSUB              ;Subtract contents of FPACC from FPOP to compare
  919/ 661 : 36 56                                 MVI	L, 126o               ;Set L to point to the MSW of the FPACC (Contains
  920/ 663 : C7                                    MOV	A,M                    ;Result of the subtraction.) Fetch the MSW of the
  921/ 664 : A0                                    ANA	A                    ;FPACC to the accumulator and test to see if result is
  922/ 665 : 68 A2 06                              JZ	CTRUE              ;Equal. Set up the FPACC as a function
  923/ 668 : 44 A7 06                              JMP	CFALSE             ;Of the result obtained.
  924/ 66B : 46 1A 11                   GT:        CALL	FPSUB              ;Subtract contents of FPACC from FPOP to compare
  925/ 66E : 36 56                                 MVI	L, 126o               ;Set L to point to the MSW of the FPACC (Contains
  926/ 670 : C7                                    MOV	A,M                    ;Result of the subtraction.) Fetch the MSW of the
  927/ 671 : A0                                    ANA	A                    ;FPACC to the accumulator and test to see if result is
  928/ 672 : 68 A7 06                              JZ	CFALSE             ;Positive, Negative, or Equal. Set up the FPACC
  929/ 675 : 50 A2 06                              JP	CTRUE              ;As a function
  930/ 678 : 44 A7 06                              JMP	CFALSE             ;Of the result obtained.
  931/ 67B : 46 1A 11                   LE:        CALL	FPSUB              ;Subtract contents of FPACC from FPOP to compare
  932/ 67E : 36 56                                 MVI	L, 126o               ;Set L to point to the MSW of the FPACC (Contains
  933/ 680 : C7                                    MOV	A,M                    ;Result of the subtraction.) Fetch the MSW of the
  934/ 681 : A0                                    ANA	A                    ;FPACC to the accumulator and test to see if result is
  935/ 682 : 68 A2 06                              JZ	CTRUE              ;Positive, Negative, or Equal. Set up the FPACC
  936/ 685 : 70 A2 06                              JM	CTRUE              ;As a function
  937/ 688 : 44 A7 06                              JMP	CFALSE             ;Of the result obtained
  938/ 68B : 46 1A 11                   GE:        CALL	FPSUB              ;Submit contents of FPACC from FPOP to compare
  939/ 68E : 36 56                                 MVI	L, 126o               ;Set L to point to the MSW of the FPACC (Contains
  940/ 690 : C7                                    MOV	A,M                    ;Result of the subtraction.) Fetch the MSW of the
  941/ 691 : A0                                    ANA	A                    ;FPACC to the accumulator and test to see if result is
  942/ 692 : 50 A2 06                              JP	CTRUE              ;Positive or Negative. Set up the FPACC
  943/ 695 : 44 A7 06                              JMP	CFALSE             ;As a function of the result obtained
  944/ 698 : 46 1A 11                   NE:        CALL	FPSUB              ;Subtract contents of FPACC from FPOP to compare
  945/ 69B : 36 56                                 MVI	L, 126o               ;Set L to point to the MSW of the FPACC (Contains
  946/ 69D : C7                                    MOV	A,M                    ;Result of the subtraction.) Fetch the MSW of the
  947/ 69E : A0                                    ANA	A                    ;FPACC to the accumulator and test to see if result is
  948/ 69F : 68 A7 06                              JZ	CFALSE             ;Equal. Set up the FPACC as a function of the result.
  949/ 6A2 :                            CTRUE:
  950/ 6A2 : 36 04                      FPONE:     MVI	L, 004                ;Load L with address of floating point value +1.0
  951/ 6A4 : 44 A4 12                              JMP	FLOAD              ;Load FPACC with value +1.0 and exit to caller
  952/ 6A7 : 36 57                      CFALSE:    MVI	L, 127o               ;Load L with address of FPACC Exponent register
  953/ 6A9 : 3E 00                                 MVI	M, 000                ;Set the FPACC Exponent to zero and then set the
  954/ 6AB : 44 29 10                              JMP	FPZERO             ;Mantissa portion of the FPACC to zero. Exit to caller.
  955/ 6AE : C4                         AD4DE:     MOV	A,E                    ;Subroutine to add four to the value in register E.
  956/ 6AF : 04 04                                 ADI	004                ;Move contents of E to the ACC and add four.
  957/ 6B1 : E0                                    MOV	E,A                    ;Restore the updated value back to register E.
  958/ 6B2 : 07                                    RET                    ;Return to the caMVI L,ng routine.
  959/ 6B3 : 36 56                      INTEXP:    MVI	L, 126o               ;Load L with address of WSW of FPACC (Floating Point
  960/ 6B5 : 2E 01                                 MVI	H,PG01 ;\HB\OLDPG1    ;** ACCumulator). Load H with page of FPACC.
  961/ 6B7 : C7                                    MOV	A,M                    ;Fetch MSW of the FPACC into the accumulator.
  962/ 6B8 : 36 03                                 MVI	L, 003                ;Load L with address of EXP TEMP storage location
  963/ 6BA : F8                                    MOV	M,A                    ;Store the FPACC MSW value in EXP TEMP location
  964/ 6BB : A0                                    ANA	A                    ;Test contents of the MSW of the FPACC. ff zero, then
  965/ 6BC : 68 A2 06                              JZ	FPONE              ;Set FPACC equal to +1.0 (any nr to zero power = 1.0!)
  966/ 6BF : 72 82 10                              CM	 FPCOMP             ;If MSW indicates negative number, complement
  967/ 6C2 : 46 00 10                              CALL	FPFIX              ;The FPACC. Then convert floating point number to
  968/ 6C5 : 36 54                                 MVI	L, 124o               ;Fixed point. Load L with address of LSW of fixed nr
  969/ 6C7 : CF                                    MOV	B,M                    ;Fetch the LSW into CPU register B.
  970/ 6C8 : 36 0B                                 MVI	L, 013o               ;Set L to address of EXPONENT COUNTER
  971/ 6CA : F9                                    MOV	M,B                    ;Place the fixed value in the EXP CNTR to indicate
  972/ 6CB : 36 5C                                 MVI	L, 134o               ;Number of multiplications needed (power). Now set L
  973/ 6CD : 26 0C                                 MVI	E, 014o               ;To LSW of FPOP and E to address of FP TEMP (LSW)
  974/ 6CF : 2E 01                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to floating point working area page.
  975/ 6D1 : DD                                    MOV	D,H                    ;Set D to same page address.
  976/ 6D2 : 0E 04                                 MVI	B, 004o               ;Set transfer (precision) counter. Call subroutine to move
  977/ 6D4 : 46 0B 11                              CALL	MOVEIT             ;Contents of FPOP into FP TEMP registers to save
  978/ 6D7 : 46 A2 06                              CALL	FPONE              ;Original value of FPOP. Now set FPACC to +1.0.
  979/ 6DA : 36 03                                 MVI	L, 003                ;Load L with pointer to original value of FPACC
  980/ 6DC : C7                                    MOV	A,M                    ;(Stored in FP TEMP) MSW and fetch contents to ACC.
  981/ 6DD : A0                                    ANA	A                    ;Test to see if raising to a negative power. If so, divide
  982/ 6DE : 70 F2 06                              JM	DVLOOP             ;Instead of multiply!
  983/ 6E1 : 36 0C                      MULOOP:    MVI	L, 014o               ;Load L with address of LSW of FP TEMP (original
  984/ 6E3 : 46 BF 12                              CALL	FACXOP             ;Value in FPOP). Move FP TEMP into FPOP.
  985/ 6E6 : 46 26 11                              CALL	FPMULT             ;Multiply FPACC by FPOP. Result left in FPACC.
  986/ 6E9 : 36 0B                                 MVI	L, 013o               ;Load L with address of EXPONENT COUNTER.
  987/ 6EB : CF                                    MOV	B,M                    ;Fetch the counter value
  988/ 6EC : 09                                    DCR	B                    ;Decrement it
  989/ 6ED : F9                                    MOV	M,B                    ;Restore it to memory
  990/ 6EE : 48 E1 06                              JNZ	MULOOP             ;If counter not zero, continue exponentiation process
  991/ 6F1 : 07                                    RET                    ;When have raised to proper power, return to caller.
  992/ 6F2 : 36 0C                      DVLOOP:    MVI	L, 014o               ;Load L with address of LSW of FP TEMP (original
  993/ 6F4 : 46 BF 12                              CALL	FACXOP             ;Value in FPOP). Move FP TEMP into FPOP.
  994/ 6F7 : 46 D2 11                              CALL	FPDIV              ;Divide FPACC by FPOP. Result left in FPACC.
  995/ 6FA : 36 0B                                 MVI	L, 013o               ;Load L with address of EXPONENT COUNTER
  996/ 6FC : CF                                    MOV	B,M                    ;Fetch the counter value
  997/ 6FD : 09                                    DCR	B                    ;Decrement it
  998/ 6FE : F9                                    MOV	M,B                    ;Restore to memory
  999/ 6FF : 48 F2 06                              JNZ	DVLOOP             ;If counter not zero, continue exponentiation process
 1000/ 702 : 07                                    RET                    ;When have raised to proper power, return to caller.
 1001/ 703 :                            
 1002/ 703 :                            ;;; The label PRIGHT: SHOULD BE UP TO 07 003 0703h
 1003/ 703 : 36 98                      PRIGHT:    MVI	L, 230o               ;Load L with address of F/A STACK pointer
 1004/ 705 : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of F/A STACK pointer
 1005/ 707 : C7                                    MOV	A,M                    ;Fetch the pointer value into the ACC
 1006/ 708 : 86                                    ADD	L                    ;Form pointer to top of the F/A STACK
 1007/ 709 : F0                                    MOV	L,A                    ;Set L to point to top of the F/A STACK
 1008/ 70A : C7                                    MOV	A,M                    ;Fetch the contents of the top of the F/A STACK into
 1009/ 70B : 3E 00                                 MVI	M, 000                ;The ACC then clear the top of the F/A STACK
 1010/ 70D : 36 83                                 MVI	L, 203o               ;Load L with address of F /A STACK TEMP storage
 1011/ 70F : 2E 17                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Location. Set H to page of F/A STACK TEMP
 1012/ 711 : F8                                    MOV	M,A                    ;Store value from top of F/A STACK into temp loc.
 1013/ 712 : A0                                    ANA	A                    ;Test to see if token value in top of stack was zero
 1014/ 713 : 2B                                    RZ                    ;If so, just had simple grouping parenthesis!
 1015/ 714 : 70 00 2D                              JM	PRIGH1             ;@@ If token value minus, indicates array subscript
 1016/ 717 : 3C 01                                 CPI	001                ;For positive token value, look for appropriate function
 1017/ 719 : 68 A3 07                              JZ	INTX               ;If token value for INTeger function, go do it.
 1018/ 71C : 3C 02                                 CPI	002                ;Else, see if token value for SIGN function.
 1019/ 71E : 68 F0 07                              JZ	SGNX               ;If so, go do it.
 1020/ 721 : 3C 03                                 CPI	003                ;Else, see if token value for ABSolute function
 1021/ 723 : 68 E6 07                              JZ	ABSX               ;If so, go do it.
 1022/ 726 : 3C 04                                 CPI	004                ;If not, see if token value for SQuare Root function
 1023/ 728 : 68 00 1A                              JZ	SQRX               ;If so, go do it.
 1024/ 72B : 3C 05                                 CPI	005                ;If not, see if token value for TAB function
 1025/ 72D : 68 0F 08                              JZ	TABX               ;If so, go do it.
 1026/ 730 : 3C 06                                 CPI	006                ;If not, see if token value for RaNDom function
 1027/ 732 : 68 A0 1A                              JZ	RNDX               ;If so, go find a random number.
 1028/ 735 : 3C 07                                 CPI	007                ;If not, see if token value for CHaRacter function
 1029/ 737 : 68 FF 07                              JZ	CHRX               ;If so, go perform the function.
 1030/ 73A : 3C 08                                 CPI	010o               ;Else, see if token for user defined machine language
 1031/ 73C : 68 55 30                              JZ	UDEFX              ;# Function. If so, perform the User DEfined Function
 1032/ 73F : 00                                    HLT             ;Safety halt. Program should not reach this location!
 1033/ 740 :                            
 1034/ 740 :                            ;;; The label FUNARR SHOULD BE AT 07 100 0740h
 1035/ 740 : 36 50                      FUNARR:    MVI	L, 120o               ;Load L with starting address of SYMBOL BUFFER
 1036/ 742 : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of SYMBOL BUFFER
 1037/ 744 : C7                                    MOV	A,M                    ;Fetch the (cc) for contents of buffer to the ACC
 1038/ 745 : A0                                    ANA	A                    ;See if (cc) is zero, if so buffer is empty, return to
 1039/ 746 : 2B                                    RZ                    ;Caller as have simple grouping parenthesis sign
 1040/ 747 : 36 82                                 MVI	L, 202o               ;Else set L to TEMP COUNTER location
 1041/ 749 : 2E 17                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Set H to TEMP COUNTER page
 1042/ 74B : 3E 00                                 MVI	M, 000                ;Initialize TEMP COUNTER to zero
 1043/ 74D : 36 82                      FUNAR1:    MVI	L, 202o               ;Load L with address of TEMP COUNTER
 1044/ 74F : 2E 17                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Load H with page of TEMP COUNTER
 1045/ 751 : CF                                    MOV	B,M                    ;Fetch the counter value to register B
 1046/ 752 : 08                                    INR	B                    ;Increment the counter
 1047/ 753 : F9                                    MOV	M,B                    ;Restore the updated value to memory
 1048/ 754 : 16 02                                 MVI	C, 002                ;Initialize C to a value of two for future ops
 1049/ 756 : 36 BC                                 MVI	L, 274o               ;Load L with starting address (less four) of FUNCTION
 1050/ 758 : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** LOOK-UP TABLE. Set H to table page.
 1051/ 75A : 46 98 07                              CALL	TABADR             ;Find address of next entry in the table
 1052/ 75D : 1E 16                                 MVI	D,PG26 ;\HB\OLDPG26   ;** Load D with page of SYMBOL BUFFER
 1053/ 75F : 26 50                                 MVI	E, 120o               ;Load E with starting address of SYMBOL BUFFER
 1054/ 761 : 46 DA 02                              CALL	STRCP              ;Compare entry in FUNCTION LOOK-UP TABLE with
 1055/ 764 : 68 87 07                              JZ	FUNAR4             ;Contents of SYMBOL BUFFER. If find match, go set
 1056/ 767 : 36 82                                 MVI	L, 202o               ;Up the function token value. Else, set L to the TEMP
 1057/ 769 : 2E 17                                 MVI	H,PG27 ;\HB\OLDPG27   ;** COUNTER and set H to the proper page. Fetch the
 1058/ 76B : C7                                    MOV	A,M                    ;Current counter value and see if have tried all eight
 1059/ 76C : 3C 08                                 CPI	010o               ;Possible functions in the table.
 1060/ 76E : 48 4D 07                              JNZ	FUNAR1             ;If not, go back and check the next entry.
 1061/ 771 : 36 82                                 MVI	L, 202o               ;If have tried all of the entries in the table, set L
 1062/ 773 : 2E 17                                 MVI	H,PG27 ;\HB\OLDPG27   ;** As well as H to the address of the TEMP COUI,.7ER
 1063/ 775 : 3E 00                                 MVI	M, 000                ;And reset it to zero. Now go see if have subscripted
 1064/ 777 : 44 2C 2D                              JMP	FUNAR2             ;@@ Array (unless array capability not in program).
 1065/ 77A : 36 98                      FAERR:     MVI	L, 230o               ;Load L with address of F/A STACK pointer
 1066/ 77C : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of F/A STACK pointer
 1067/ 77E : 3E 00                                 MVI	M, 000                ;Clear the F/A STACK pointer to reset on an error
 1068/ 780 : 06 C6                                 MVI	A, 306o               ;Load the ASCII code for letter F into the ACC
 1069/ 782 : 16 C1                                 MVI	C, 301o               ;Load the ASCII code for letter A into register C
 1070/ 784 : 44 96 02                              JMP	ERROR              ;Go display the FA error message
 1071/ 787 : 36 82                      FUNAR4:    MVI	L, 202o               ;Load L with address of TEMP COUNTER
 1072/ 789 : 2E 17                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Set H to page of TEMP COUNTER
 1073/ 78B : CF                                    MOV	B,M                    ;Load value in counter to register B. This is FUNCTION
 1074/ 78C : 36 98                                 MVI	L, 230o               ;TOKEN VALUE. Cbange- L to F/A STACK pointer.
 1075/ 78E : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of F/A STACK pointer.
 1076/ 790 : D7                                    MOV	C,M                    ;Fetch the F/A STACK pointer value into register C.
 1077/ 791 : 46 1E 13                              CALL	INDEXC             ;Form the address to the top of the F/A STACK.
 1078/ 794 : F9                                    MOV	M,B                    ;Store the FUNCTION TOKEN VALUE in the F/A
 1079/ 795 : 44 AD 02                              JMP	CLESYM             ;STACK. Then exit by clearing the SYMBOL BUFFER.
 1080/ 798 : C1                         TABADR:    MOV	A,B                    ;Move the TEMP COUNTER value from B to ACC
 1081/ 799 : 02                         TABAD1:    RLC                    ;Multiply by four using this loop to form value equal
 1082/ 79A : 11                                    DCR	C                    ;To number of bytes per entry (4) times current entry
 1083/ 79B : 48 99 07                              JNZ	TABAD1             ;In the FUNCTION LOOK-UP TABLE.
 1084/ 79E : 86                                    ADD	L                    ;Add this value to the starting address of the table.
 1085/ 79F : F0                                    MOV	L,A                    ;Form pointer to next entry in table
 1086/ 7A0 : 03                                    RNC                    ;If no carry return to caller
 1087/ 7A1 : 28                                    INR	H                    ;Else, increment H before
 1088/ 7A2 : 07                                    RET                    ;Returning to caller
 1089/ 7A3 :                            
 1090/ 7A3 :                            ;;; The label INTX SHOULD BE AT 07 243 07a3h
 1091/ 7A3 : 36 56                      INTX:      MVI	L, 126o               ;Load L with address of MSW of the FPACC
 1092/ 7A5 : 2E 01                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Load H with the page of the PPACC
 1093/ 7A7 : C7                                    MOV	A,M                    ;Fetch the MSW of the FPACC into the accumulator
 1094/ 7A8 : A0                                    ANA	A                    ;Test the sign of the number in the FPACC. If
 1095/ 7A9 : 50 D7 07                              JP	INT1               ;Positive jump ahead to integerize
 1096/ 7AC : 36 0C                                 MVI	L, 014o               ;If negative, load L with address of FP TEMP registers
 1097/ 7AE : 46 AD 12                              CALL	FSTORE             ;Store the value in the FPACC in FP TEMP
 1098/ 7B1 : 46 00 10                              CALL	FPFIX              ;Convert the value in FPACC from floating point to
 1099/ 7B4 : 36 53                                 MVI	L, 123o               ;Fixed point. Load L with address of FPACC
 1100/ 7B6 : 3E 00                                 MVI	M, 000                ;Extension register and clear it.
 1101/ 7B8 : 46 34 10                              CALL	FPFLT              ;Convert fixed binary back to FP to integerize
 1102/ 7BB : 36 0C                                 MVI	L, 014o               ;Load L with address of FP TEMP registers
 1103/ 7BD : 46 B6 12                              CALL	OPLOAD             ;Load the value in FP TEMP into FPOP
 1104/ 7C0 : 46 1A 11                              CALL	FPSUB              ;Subtract integerized value from original
 1105/ 7C3 : 36 56                                 MVI	L, 126o               ;Set L to address of MSW of FPACC
 1106/ 7C5 : C7                                    MOV	A,M                    ;Fetch the MSW of the FPACC into the accumulator
 1107/ 7C6 : A0                                    ANA	A                    ;See if original value and integerized value the same
 1108/ 7C7 : 68 E1 07                              JZ	INT2               ;If so, have integer value in FP TEMP
 1109/ 7CA : 36 0C                                 MVI	L, 014o               ;Else, load L with address of FP TEMP registers
 1110/ 7CC : 46 A4 12                              CALL	FLOAD              ;Restore FPACC to original (non-integerized) value
 1111/ 7CF : 36 14                                 MVI	L, 024o               ;Set L to register containing small value
 1112/ 7D1 : 46 BF 12                              CALL	FACXOP             ;Set up to add small value to original value in FPACC
 1113/ 7D4 : 46 89 10                              CALL	FPADD              ;Perform the addition
 1114/ 7D7 : 46 00 10                   INT1:      CALL	FPFIX              ;Convert the number in FPACC from floating point
 1115/ 7DA : 36 53                                 MVI	L, 123o               ;To fixed point. Load L with address of FPACC
 1116/ 7DC : 3E 00                                 MVI	M, 000                ;Extension register and clear it. Now convert the number
 1117/ 7DE : 44 34 10                              JMP	FPFLT              ;Back to floating point to integerize it and exit to caller
 1118/ 7E1 : 36 0C                      INT2:      MVI	L, 014o               ;Load L with address of FP TEMP registers. Transfer
 1119/ 7E3 : 44 A4 12                              JMP	FLOAD              ;Number from FP TEMP (orig) to FPACC and return.
 1120/ 7E6 : 36 56                      ABSX:      MVI	L, 126o               ;Load L with address of MSW of the FPACC
 1121/ 7E8 : 2E 01                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to page of the FPACC
 1122/ 7EA : C7                                    MOV	A,M                    ;Fetch the MSW of the FPACC into the accumulator
 1123/ 7EB : A0                                    ANA	A                    ;Test the sign of the number to see if it is positive.
 1124/ 7EC : 70 82 10                              JM	FPCOMP             ;If negative, complement the number before returning.
 1125/ 7EF : 07                                    RET                    ;Else, just return with absolute value in the FPACC.
 1126/ 7F0 : 36 56                      SGNX:      MVI	L, 126o               ;Load L with address of MSW of the FPACC
 1127/ 7F2 : 2E 01                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Load H with the page of the FPACC
 1128/ 7F4 : C7                                    MOV	A,M                    ;Fetch the MSW of the FPACC into the accumulator
 1129/ 7F5 : A0                                    ANA	A                    ;Test to see if the FPACC is zero
 1130/ 7F6 : 2B                                    RZ                    ;Return to caller if FPACC is zero
 1131/ 7F7 : 50 A2 06                              JP	FPONE              ;If FPACC is positive, load +1.0 into FPACC and exit
 1132/ 7FA : 36 14                                 MVI	L, 024o               ;If FPACC is negative, set up to load -1.0 into the
 1133/ 7FC : 44 A4 12                              JMP	FLOAD              ;FPACC and exit to caller
 1134/ 7FF : 46 00 10                   CHRX:      CALL	FPFIX              ;Convert contents of FPACC from floating point to
 1135/ 802 : 36 54                                 MVI	L, 124o               ;Fixed point. Load L with address of LSW of fixed
 1136/ 804 : C7                                    MOV	A,M                    ;Value. Fetch this byte into the accumulator.
 1137/ 805 : 46 82 03                              CALL	ECHO               ;Display the value.
 1138/ 808 : 36 7F                                 MVI	L, 177o               ;Set L to address of the TAB FLAG
 1139/ 80A : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of the TAB FLAG
 1140/ 80C : 3E FF                                 MVI	M, 377o               ;Set TAB FLAG (to inhibit display of FP value)
 1141/ 80E : 07                                    RET                    ;Exit to caller.
 1142/ 80F : 46 00 10                   TABX:      CALL	FPFIX              ;Convert contents of FPACC from floating point to
 1143/ 812 : 36 54                      TAB1:      MVI	L, 124o               ;Fixed point. Load L with address of 1,SW of fixed
 1144/ 814 : C7                                    MOV	A,M                    ;Value. Fetch this byte into the accumulator.
 1145/ 815 : 36 23                                 MVI	L, 043o               ;Load L with address of COLUMN COUNTER
 1146/ 817 : 97                                    SUB	M                    ;Subtract value in C-OLUMN COUNTER from desired
 1147/ 818 : 36 7F                                 MVI	L, 177o               ;TAB position. Load L with address of the TAB FLAG.
 1148/ 81A : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of the TAB FLAG.
 1149/ 81C : 3E FF                                 MVI	M, 377o               ;Set TAB FLAG (to inhibit display of FP value)
 1150/ 81E : 70 8F 19                              JM	BACKSP             ;If beyond TAB point desired, simulate back spacing
 1151/ 821 : 2B                                    RZ                    ;Return to caller if at desired TAB location
 1152/ 822 : D0                         TABC:      MOV	C,A                    ;Else, put difference count in register C
 1153/ 823 : 06 A0                                 MVI	A, 240o               ;Place ASCII code for space in ACC
 1154/ 825 : 46 82 03                   TABLOP:    CALL	ECHO               ;Display space on output device
 1155/ 828 : 11                                    DCR	C                    ;Decrement displacement counter
 1156/ 829 : 48 25 08                              JNZ	TABLOP             ;If have not reached TAB position, continue to space
 1157/ 82C : 07                                    RET                    ;Else, return to calling routine.
 1158/ 82D :                            
 1159/ 82D :                            ;;; The label STOSYM should be AT 10 055 082dh
 1160/ 82D : 36 81                      STOSYM:    MVI	L, 201o               ;Load L with address of ARRAY FLAG
 1161/ 82F : 2E 17                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Load H with page of ARRAY FLAG
 1162/ 831 : C7                                    MOV	A,M                    ;Fetch the value of the ARRAY FLAG into the ACC
 1163/ 832 : A0                                    ANA	A                    ;Check to see if the flag is set indicating processing an
 1164/ 833 : 68 40 08                              JZ	STOSY1             ;Array variable value. Jump ahead if flag not set.
 1165/ 836 : 3E 00                                 MVI	M, 000                ;If ARRAY FLAG was set, clear it for next time.
 1166/ 838 : 36 84                                 MVI	L, 204o               ;Then load L with address of array address storage loc
 1167/ 83A : F7                                    MOV	L,M                    ;Fetch the array storage address as new pointer
 1168/ 83B : 2E 2F                                 MVI	H,PG57 ;\HB\OLDPG57   ;tt Set H to ARRAY VALUES page   ****************
 1169/ 83D : 44 AD 12                              JMP	FSTORE             ;Store the array variable value and exit to caller.
 1170/ 840 : 36 F8                      STOSY1:    MVI	L, 370o               ;Load L with address of TEMP CNTR
 1171/ 842 : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of TEMP CNTR
 1172/ 844 : 3E 00                                 MVI	M, 000                ;Initialize the TEMP CNTR by clearing it
 1173/ 846 : 36 50                                 MVI	L, 120o               ;Load L with starting address of SYMBOL BUFFER
 1174/ 848 : 1E 17                                 MVI	D,PG27 ;\HB\OLDPG27   ;** Load D with page of VARIABLES LOOK-UP table
 1175/ 84A : 26 88                                 MVI	E, 210o               ;Load E with starting addr of VARIABLES LOOK-UP
 1176/ 84C : C7                                    MOV	A,M                    ;Table. Fetch the (cc) for the SYMBOL BUFFER into
 1177/ 84D : 3C 01                                 CPI	001                ;The ACC and see if length of variable name is just one
 1178/ 84F : 48 56 08                              JNZ	STOSY2             ;Character. If not, skip next couple of instructions.
 1179/ 852 : 36 52                                 MVI	L, 122o               ;Else, set pointer to second character location in the
 1180/ 854 : 3E 00                                 MVI	M, 000                ;SYMBOL BUFFER and set it to zero
 1181/ 856 : 36 51                      STOSY2:    MVI	L, 121o               ;load L with address of first character in the SYMBOL
 1182/ 858 : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** BUFFER. Load H with page of the buffer.
 1183/ 85A : 46 EE 12                              CALL	SWITCH             ;Exchange pointer to buffer for pointer to VARIABLES
 1184/ 85D : C7                                    MOV	A,M                    ;LOOK-UP table. Fetch first char in a name from the
 1185/ 85E : 30                                    INR	L                    ;Table. Advance the pointer to second char in a name.
 1186/ 85F : CF                                    MOV	B,M                    ;Fetch the second character into register B.
 1187/ 860 : 30                                    INR	L                    ;Advance the pointer to first byte of a value in the table.
 1188/ 861 : 46 EE 12                              CALL	SWITCH             ;Exchange table pointer for pointer to SYMBOL BUFF
 1189/ 864 : BF                                    CMP	M                    ;Compare first character in buffer against first character
 1190/ 865 : 48 6E 08                              JNZ	STOSY3             ;In table entry. If no match, try next entry in the table.
 1191/ 868 : 30                                    INR	L                    ;If match, advance pointer to second character in buffer.
 1192/ 869 : C1                                    MOV	A,B                    ;Move second character obtained from table into ACC.
 1193/ 86A : BF                                    CMP	M                    ;Compare second characters in table and buffer.
 1194/ 86B : 68 97 08                              JZ	STOSY5             ;If same, have found the variable name in the table.
 1195/ 86E : 46 AE 06                   STOSY3:    CALL	AD4DE              ;Add four to pointer in registers D&E to skip over value
 1196/ 871 : 36 F8                                 MVI	L, 370o               ;Portion of entry in table. Load L with address of TEMP
 1197/ 873 : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** CNTR. Load H with page of TEMP CNTR.
 1198/ 875 : CF                                    MOV	B,M                    ;Fetch the counter
 1199/ 876 : 08                                    INR	B                    ;Increment the counter
 1200/ 877 : F9                                    MOV	M,B                    ;Restore it to storage
 1201/ 878 : 36 3F                                 MVI	L, 077o               ;Set L to address of VARIABLES CNTR (indicates
 1202/ 87A : 2E 17                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Number of variables currently in table.) Set H too
 1203/ 87C : C1                                    MOV	A,B                    ;Move the TEMP CNTR value into the ACC. (Number of
 1204/ 87D : BF                                    CMP	M                    ;Entries checked.) Compare with number of entries in
 1205/ 87E : 48 56 08                              JNZ	STOSY2             ;The table. If have not checked all entries, try next one.
 1206/ 881 : 36 3F                                 MVI	L, 077o               ;If have checked all entries, load L with address of the
 1207/ 883 : 2E 17                                 MVI	H,PG27 ;\HB\OLDPG27   ;** VARIABLES CNTR. Set H too. Fetch the counter
 1208/ 885 : CF                                    MOV	B,M                    ;Value and incrernent it to account for
 1209/ 886 : 08                                    INR	B                    ;New variable nwne that will now be
 1210/ 887 : F9                                    MOV	M,B                    ;Added to the table. Save the new value.
 1211/ 888 : C1                                    MOV	A,B                    ;Place the new counter value into the accumulator
 1212/ 889 : 3C 15                                 CPI	025o               ;And check to see that adding new variable name to the
 1213/ 88B : 50 92 02                              JP	BIGERR             ;Table will not cause table overflow. Big Error if it does!
 1214/ 88E : 36 51                                 MVI	L, 121o               ;If room available in table, set L to address of first
 1215/ 890 : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Caracter in the SYMBOL BUFFER. Set H too.
 1216/ 892 : 0E 02                                 MVI	B, 002                ;Set a counter for number of characters to transfer.
 1217/ 894 : 46 0B 11                              CALL	MOVEIT             ;Move the variable name from buffer to table.
 1218/ 897 : 46 EE 12                   STOSY5:    CALL	SWITCH             ;Exchange buffer pointer for table pointer.
 1219/ 89A : 46 AD 12                              CALL	FSTORE             ;Transfer new mathematical value into the table.
 1220/ 89D : 44 AD 02                              JMP	CLESYM             ;Clear the SYMBOL BUFFER and exit to calling routine.
 1221/ 8A0 :                            
 1222/ 8A0 :                                                              ;The subroutines below are used by some of the routines
 1223/ 8A0 :                                                              ;in this chapter as well as other parts of the program.
 1224/ 8A0 :                            
 1225/ 8A0 : 36 50                      SAVESY:    MVI	L, 120o               ;Load L with the address of the start of the SYMBOL
 1226/ 8A2 : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** BUFFER. Load H with the page of the buffer.
 1227/ 8A4 : DD                                    MOV	D,H                    ;Load register D with the page of the AUX SYMBOL
 1228/ 8A5 : 26 64                                 MVI	E, 144o               ;BUFFER and set register E to start of that buffer.
 1229/ 8A7 : 44 B1 08                              JMP	MOVECP             ;Transfer SYMBOL BF contents to AUX SYMBOL BF
 1230/ 8AA :                            
 1231/ 8AA : 36 64                      RESTSY:    MVI	L, 144o               ;Load L with address of start of AUX SYMBOL BUFF
 1232/ 8AC : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of AUX SYMBOL BUFFER
 1233/ 8AE : DD                                    MOV	D,H                    ;Set D to page of SYMBOL BUFFER (same as H)
 1234/ 8AF : 26 50                                 MVI	E, 120o               ;Load E with start of SYMBOL BUFFER
 1235/ 8B1 : CF                         MOVECP:    MOV	B,M                    ;Load (cc) for source string (first byte in source buffer)
 1236/ 8B2 : 08                                    INR	B                    ;Add one to (cc) to include (cc) byte itself
 1237/ 8B3 : 44 0B 11                              JMP	MOVEIT             ;Move the source string to destination buffer
 1238/ 8B6 :                            
 1239/ 8B6 :                            ;;; The label Exec SHOULD BE AT 10 266 (This is the start of the code) 08b6h
 1240/ 8B6 : 36 EA                      EXEC:      MVI	L, 352o               ;Load L with address of READY message
 1241/ 8B8 : 2E 01                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Load H with page of READY message
 1242/ 8BA : 46 51 03                              CALL	TEXTC              ;Call subroutine to display the READY message
 1243/ 8BD :                            
 1244/ 8BD : 36 00                      EXEC1:     MVI	L, 000                ;Load L with starting address of INPUT LINE BUFFER
 1245/ 8BF : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of INPUT LINE BUFFER
 1246/ 8C1 : 46 0C 03                              CALL	STRIN              ;Call subroutine to input a line into the buffer
 1247/ 8C4 : C7                                    MOV	A,M                    ;The STRIN subroutine will exit with pointer set to the
 1248/ 8C5 : A0                                    ANA	A                    ;CHARACTER COUNT for the line inputted. Fetch the
 1249/ 8C6 : 68 BD 08                              JZ	EXEC1              ;Value of the counter, if it is zero then line was blank.
 1250/ 8C9 : 36 DD                                 MVI	L, 335o               ;Load L with address of LIST in look up table
 1251/ 8CB : 2E 01                                 MVI	H,PG01 ;\HB\OLDPG1    ;Load H with address of LIST in look up table
 1252/ 8CD : 1E 16                                 MVI	D,PG26 ;\HB\OLDPG26   ;Load D with page of line input buffer
 1253/ 8CF : 26 00                                 MVI	E, 000                ;Load E with start of line input buffer
 1254/ 8D1 : 46 DA 02                              CALL	STRCP              ;Call string compare subroutine to see if first word in
 1255/ 8D4 : 48 EC 08                              JNZ	NOLIST             ;Input buffer is LIST. Jump 3 ahead if not LIST.
 1256/ 8D7 : 36 00                                 MVI	L, 000                ;If LIST, set up pointers to start of USER PROGRAM
 1257/ 8D9 : 2E 1B                                 MVI	H, BGNPGRAM           ;BUFFER. (Note user could alter this starting addr)   *****
 1258/ 8DB :                            
 1259/ 8DB :                                                              ;Next portion of program will LIST the contents of the
 1260/ 8DB :                                                              ;USER PROGRAM BUFFER until an end of buffer
 1261/ 8DB :                                                              ;(zero byte) indicator is detected.
 1262/ 8DB :                            
 1263/ 8DB : C7                         LIST:      MOV	A,M                    ;Fetch the first byte of a line in the USER PROGRAM
 1264/ 8DC : A0                                    ANA	A                    ;BUFFER and see if it is zero. If so, have finished LIST
 1265/ 8DD : 68 B6 08                              JZ	EXEC               ;So go back to start of Executive and display READY.
 1266/ 8E0 : 46 51 03                              CALL	TEXTC              ;Else call subroutine to display a line of information
 1267/ 8E3 : 46 FF 02                              CALL	ADV                ;Now call subroutine to advance buffer pointer to
 1268/ 8E6 : 46 61 03                              CALL	CRLF               ;Character count in next line. Also display a CR & LF.
 1269/ 8E9 : 44 DB 08                              JMP	LIST               ;Continue LISTing process
 1270/ 8EC :                            
 1271/ 8EC :                                                              ;If line inputted by operator did not contain a LIST comman
 1272/ 8EC :                                                              ;continue program to see if RUN or SCRatch command.
 1273/ 8EC :                            
 1274/ 8EC : 36 E2                      NOLIST:    MVI	L, 342o               ;Load L with address of RUN in look up table
 1275/ 8EE : 2E 01                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Load H with address of RUN in look up table
 1276/ 8F0 : 26 00                                 MVI	E, 000                ;Load E with start of line input buffer
 1277/ 8F2 : 1E 16                                 MVI	D,PG26 ;\HB\OLDPG26   ;** Load D with page of line input buffer
 1278/ 8F4 : 26 00                                 MVI	E, 000                ;(Reserve 2 locs in case of patching by duplicating above)
 1279/ 8F6 : 46 DA 02                              CALL	STRCP              ;Call string compare subroutine to see if first word in
 1280/ 8F9 : 68 38 0B                              JZ	RUN                ;Input buffer is RUN. Go to RUN routine if match.
 1281/ 8FC : 1E 16                                 MVI	D,PG26 ;\HB\OLDPG26   ;** If not RUN command, reset address pointers back
 1282/ 8FE : 26 00                                 MVI	E, 000                ;To the start of the line input buffer
 1283/ 900 : 36 E6                                 MVI	L, 346o               ;Load L with address of SCR in look up table
 1284/ 902 : 2E 01                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Load H with page of SCR in look up table
 1285/ 904 : 46 DA 02                              CALL	STRCP              ;Call string compare subroutine to see if first word in
 1286/ 907 : 48 39 09                              JNZ	NOSCR              ;Input buffer is SCR. If not then jump ahead.
 1287/ 90A : 2E 16                      ENTRY_SCR: MVI	H,PG26 ;\HB\OLDPG26   ;** If found SCR command then load memory pointer
 1288/ 90C : 36 F4                                 MVI	L, 364o               ;With address of a pointer storage location. Set that
 1289/ 90E : 3E 1B                                 MVI	M, BGNPGRAM           ;tt Storage location to page of start of USER PRO-  *******
 1290/ 910 : 30                                    INR	L                    ;GRAM BUFFER. (Buffer start loc may be altered).
 1291/ 911 : 3E 00                                 MVI	M, 000                ;Then adv pntr and do same for low addr portion of pntr
 1292/ 913 : 36 3F                                 MVI	L, 077o               ;Now set pointer to address of VARIABLES counter
 1293/ 915 : 2E 17                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Storage location. Initialize this counter by placing
 1294/ 917 : 3E 01                                 MVI	M, 001                ;The count of one into it. Now change the memory pntr
 1295/ 919 :                            ;MGA 3/31/12 put it back to 001; solves nested FOR/NEXT, but limits vars to 19
 1296/ 919 :                            ;   as the letter from James Tucker (1/77) mentioned
 1297/ 919 :                            ;   apparently, James didn't test FOR/NEXT; original Loboyko didn't have this
 1298/ 919 :                            ;;;           LMI 001                ;The count of one into it. Now change the memory pntr
 1299/ 919 :                            ;;; Apparently, in Page 3 of Issue 4 of Scelbal update (1/77) they say the above should change.
 1300/ 919 :                            ;;; This makes the SCR command clear the whole variable space, otherwise one space is lost.  
 1301/ 919 : 36 3D                                 MVI	L, 075o               ;To storage location for number of dimensioned arrays
 1302/ 91B : 3E 00                                 MVI	M, 000                ;@@ And initialize to zero. (@@ = Substitute NOPs if
 1303/ 91D : 36 50                                 MVI	L, 120o               ;@@ DIMension capability not used in package.) Also
 1304/ 91F : 3E 00                                 MVI	M, 000                ;@@ Initialize l'st byte of array name table to zero.
 1305/ 921 : 36 88                                 MVI	L, 210o               ;Set pointer to storage location for the first byte of the
 1306/ 923 : 3E 00                                 MVI	M, 000                ;VARIABLES symbol table. Initialize it to zero too.
 1307/ 925 : 30                                    INR	L                    ;Advance the pointer and zero the second location
 1308/ 926 : 3E 00                                 MVI	M, 000                ;In the Variables table also.
 1309/ 928 : 2E 1B                                 MVI	H, BGNPGRAM           ;tt Load H with page of start of USER PROGRAM    **********
 1310/ 92A : 36 00                                 MVI	L, 000                ;BUFFER. (Buffer start location could be altered.)
 1311/ 92C : 3E 00                                 MVI	M, 000                ;Clear first location to indicate end of user program.
 1312/ 92E : 2E 2F                                 MVI	H,PG57 ;\HB\OLDPG57   ;@@ Load H with page of ARRAYS storage
 1313/ 930 : 3E 00                      SCRLOP:    MVI	M, 000                ;@@ And form a loop to clear out all the locations
 1314/ 932 : 30                                    INR	L                    ;@@ On the ARRAYS storage page. (@@ These become
 1315/ 933 : 48 30 09                              JNZ SCRLOP             ;@@ NOPs if DIMension capability deleted fm package.)
 1316/ 936 : 44 B6 08                              JMP EXEC               ;SCRatch operations completed, go back to EXEC.
 1317/ 939 :                            
 1318/ 939 :                                                              ;If line inputted did not contain RUN or SCRatch com-
 1319/ 939 :                                                              ;mand, program continues by testing for SAVE or LOAD
 1320/ 939 :                                                              ;commands. If it does not find either of these com-
 1321/ 939 :                                                              ;mands, then operator did not input an executive com-
 1322/ 939 :                                                              ;mand. Program then sets up to see if the first entry in
 1323/ 939 :                                                              ;the line inputted is a LINE NUMBER.
 1324/ 939 :                            
 1325/ 939 : 26 BA                      NOSCR:     MVI	E, 272o               ;Load E with address of SAVE in look up table
 1326/ 93B : 1E 01                                 MVI	D,PG01 ;\HB\OLDPG1    ;Load D with page of look up table
 1327/ 93D : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;Load H with page of input line buffer
 1328/ 93F : 36 00                                 MVI	L, 000                ;Set L to start of input line buffer
 1329/ 941 : 46 DA 02                              CALL	STRCP              ;Call string compare subroutine to see if first word in
 1330/ 944 : 68 56 30                              JZ	SAVE               ;tt Input buffer is SAVE. If so, go to user's SAVE rtn
 1331/ 947 : 36 BF                                 MVI	L, 277o               ;If not SAVE then load L with address of LOAD in look
 1332/ 949 : 2E 01                                 MVI	H,PG01 ;\HB\OLDPG1    ;Up table and load H with page of look up table
 1333/ 94B : 1E 16                                 MVI	D,PG26 ;\HB\OLDPG26   ;Load D with page of input line buffer
 1334/ 94D : 26 00                                 MVI	E, 000                ;And L to start of input line buffer
 1335/ 94F : 46 DA 02                              CALL	STRCP              ;Call string compare subroutine to see if first word in
 1336/ 952 : 68 56 30                              JZ	LOAD               ;tt Input buffer is LOAD. If so, go to user's LOAD rtn
 1337/ 955 : 36 F0                                 MVI	L, 360o               ;If not LOAD then set pointer to address of storage loc
 1338/ 957 : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** For USER PROGRAM BUFFER pointer. Initialize this
 1339/ 959 : 3E 1B                                 MVI	M, BGNPGRAM           ;tt Pointer to the starting address of the program buffer.
 1340/ 95B : 30                                    INR	L                    ;Advance memory pntr. Since pointer storage requires
 1341/ 95C : 3E 00                                 MVI	M, 000                ;Two locations, initialize the low addr portion also.
 1342/ 95E : 46 00 02                              CALL	SYNTAX             ;Call the SYNTAX subroutine to obtain a TOKEN indi-
 1343/ 961 : 36 83                                 MVI	L, 203o               ;Cator which will be stored in this location. Upon return
 1344/ 963 : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** From SYNTAX subroutine set memory pointer to
 1345/ 965 : C7                                    MOV	A,M                    ;The TOKEN indicator storage location and fetch the
 1346/ 966 : A0                                    ANA	A                    ;Value of the TOKEN. If the value of the syntax TOKEN
 1347/ 967 : 50 71 09                              JP	SYNTOK             ;Is positive then have a valid entry.
 1348/ 96A : 06 D3                      SYNERR:    MVI	A, 323o               ;However, if SYNTAX returns a negative value TOKEN
 1349/ 96C : 16 D9                                 MVI	C, 331o               ;Then have an error condition. Set up the letters SY in
 1350/ 96E : 44 96 02                              JMP	ERROR              ;ASCII code and go to display error message to operator.
 1351/ 971 : 36 E0                      SYNTOK:    MVI	L, 340o               ;Set pointer to start of LINE NUMBER storage area
 1352/ 973 : C7                                    MOV	A,M                    ;First byte there will contain the length of the line
 1353/ 974 : A0                                    ANA	A                    ;Number character string. Fetch that value (cc).
 1354/ 975 : 68 89 0B                              JZ	DIRECT             ;DIRECT If line number blank, have a DIRECT statement!
 1355/ 978 : 36 F0                                 MVI	L, 360o               ;If have a line number must get line in input buffer into
 1356/ 97A : 3E 1B                                 MVI	M, BGNPGRAM           ;tt User program buffer. Initialize pointer to user buffer.
 1357/ 97C : 30                                    INR	L                    ;This is a two byte pointer so after initializing page addr
 1358/ 97D : 3E 00                                 MVI	M, 000                ;Advance pointer and initialize location on page address
 1359/ 97F :                            
 1360/ 97F :                                                              ;If the line in the LINE INPUT BUFFER has a line num-
 1361/ 97F :                                                              ;ber then the line is to be placed in the USER PRO-
 1362/ 97F :                                                              ;GRAM BUFFER. It is now necessary to determine
 1363/ 97F :                                                              ;where the new line is to be placed in the USER PRO-
 1364/ 97F :                                                              ;GRAM BUFFER. This is dictated by the value of the
 1365/ 97F :                                                              ;new line number in relation to the line numbers cur-
 1366/ 97F :                                                              ;rently in the program buffer. The next portion of the
 1367/ 97F :                                                              ;program goes through the contents of the USER PRO-
 1368/ 97F :                                                              ;GRAM BUFFER comparing the values of the line num-
 1369/ 97F :                                                              ;bers already stored against the value of the line number
 1370/ 97F :                                                              ;currently being held in the LINE INPUT BUFFER.
 1371/ 97F :                                                              ;Appropriate action is then taken to Insert or Append,
 1372/ 97F :                                                              ;Change, or Delete a line in the program buffer.
 1373/ 97F :                            
 1374/ 97F : 36 81                      GETAUX:    MVI	L, 201o               ;Set memory pointer to line character pointer storage
 1375/ 981 : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Location and then initialize that storage location
 1376/ 983 : 3E 01                                 MVI	M, 001                ;To point to the 1'st character in a line
 1377/ 985 : 36 E8                                 MVI	L, 350o               ;Set memory pointer to addr of start of auxiliary line
 1378/ 987 : 3E 00                                 MVI	M, 000                ;Number storage area and initialize first byte to zero
 1379/ 989 : 36 81                      GETAU0:    MVI	L, 201o               ;Set memory pointer to line character pointer storage loc
 1380/ 98B : 46 53 0A                              CALL	GETCHP             ;Fetch a char in line pointed to by line pointer
 1381/ 98E : 68 A2 09                              JZ	GETAU1             ;If character is a space, skip it by going to advance pntrs
 1382/ 991 : 3C B0                                 CPI	260o               ;If not a space check to see if character represents a
 1383/ 993 : 70 B7 09                              JM	GETAU2             ;Valid decimal digit in the range 0 to 9 by testing the
 1384/ 996 : 3C BA                                 CPI	272o               ;ASCII code value obtained. If not a deciznal digit then
 1385/ 998 : 50 B7 09                              JP	GETAU2             ;Assume have obtained the line number. Go process.
 1386/ 99B : 36 E8                                 MVI	L, 350o               ;If valid decimal digit want to append the digit to the
 1387/ 99D : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Current string being built up in the auxiliary line
 1388/ 99F : 46 CC 02                              CALL	CONCT1             ;Number storage area so call sub to concat a character.
 1389/ 9A2 : 36 81                      GETAU1:    MVI	L, 201o               ;Reset memory pointer to line character pntr storage loc
 1390/ 9A4 : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;On the appropriate page.
 1391/ 9A6 : CF                                    MOV	B,M
 1392/ 9A7 : 08                                    INR	B                    ;Fetch the pointer, increment it, and restore new value
 1393/ 9A8 : F9                                    MOV	M,B
 1394/ 9A9 : 36 F0                                 MVI	L, 360o               ;Set memory pointer to pgm buff line pntr storage loc
 1395/ 9AB : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   
 1396/ 9AD : D7                                    MOV	C,M                    ;Bring the high order byte of this double byte pointer
 1397/ 9AE : 30                                    INR	L                    ;Into CPU register C. Then advance the memory pntr
 1398/ 9AF : F7                                    MOV	L,M                    ;And bring the low order byte into register L. Now trans-
 1399/ 9B0 : EA                                    MOV	H,C                    ;Fer the higher order portion into memory pointer H.
 1400/ 9B1 : C7                                    MOV	A,M                    ;Obtain the char cntr (cc) which indicates the length of
 1401/ 9B2 : 09                                    DCR	B                    ;The line being pointed to by the user program line pntr
 1402/ 9B3 : B9                                    CMP	B                    ;Compare this with the value of the chars processed so
 1403/ 9B4 : 48 89 09                              JNZ	GETAU0             ;Far in current line. If not equal, continue getting line n
 1404/ 9B7 : 36 F0                      GETAU2:    MVI	L, 360o               ;Reset mem pntr to pgm buffer line pntr storage
 1405/ 9B9 : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** On this page and place the high order byte
 1406/ 9BB : DF                                    MOV	D,M                    ;Of this pointer into CPU register D
 1407/ 9BC : 30                                    INR	L                    ;Advance the memory pointer, fetch the second
 1408/ 9BD : F7                                    MOV	L,M                    ;Byte of the pgm buffer line pointer into register L
 1409/ 9BE : EB                                    MOV	H,D                    ;Now make the memory pointer equal to this value
 1410/ 9BF : C7                                    MOV	A,M                    ;Fetch the first byte of a line in the program buffer
 1411/ 9C0 : A0                                    ANA	A                    ;Test to see if end of contents of pgm buff (zero byte)
 1412/ 9C1 : 48 DE 09                              JNZ	NOTEND             ;If not zero continue processing. If zero have reached
 1413/ 9C4 : 44 05 0A                              JMP	NOSAME             ;End of buffer contents so go APPEND line to buffer.
 1414/ 9C7 :                            ;;; there are some open addresses here.  Above JUMP starts at 11-304;
 1415/ 9C7 :                            ;;; The below label patch3 should start at 11 307 09c7h
 1416/ 9C7 : 36 81                      PATCH3:	   MVI	L, 201o               ; ptr to A/V storage
 1417/ 9C9 : 2E 17                      	   MVI	H,PG27 ;\HB\OLDPG27   ; MGA 3/31/12 make relocatable; prev: LHI 027
 1418/ 9CB : 3E 00                      	   MVI	M, 000o               ; clear A/V flag
 1419/ 9CD : 44 B6 08                   	   JMP	EXEC
 1420/ 9D0 :                            
 1421/ 9D0 :                            ;	db	(09deh-$) dup 0
 1422/ 9D0 :                            
 1423/ 9DE :                                       ORG	09deh              ;011#336
 1424/ 9DE : 36 E8                      NOTEND:    MVI	L, 350o               ;Load L with addr of auxiliary line number storage loc
 1425/ 9E0 : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;Load H with addr of aux line number storage loc
 1426/ 9E2 : 1E 16                                 MVI	D,PG26 ;\HB\OLDPG26   ;Load D with addr of line number buffer location
 1427/ 9E4 : 26 E0                                 MVI	E, 340o               ;Load E with address of line number buffer location
 1428/ 9E6 : 46 DA 02                              CALL	STRCP              ;Compare line nr in input buffer with line number in
 1429/ 9E9 : 70 3B 0A                              JM	CONTIN             ;User program buffer. If lesser in value keep looking.
 1430/ 9EC : 48 05 0A                              JNZ	NOSAME             ;If greater in value then go to Insert line in pgm buffer
 1431/ 9EF : 36 F0                                 MVI	L, 360o               ;If same values then must remove the line with the same
 1432/ 9F1 : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Line number from the user program buffer. Set up
 1433/ 9F3 : D7                                    MOV	C,M                    ;The CPU memory pointer to point to the current
 1434/ 9F4 : 30                                    INR	L                    ;Position in the user program buffer by retrieving that
 1435/ 9F5 : F7                                    MOV	L,M                    ;Pointer from its storage location. Then obtain the first
 1436/ 9F6 : EA                                    MOV	H,C                    ;Byte of data pointed to which will be the character
 1437/ 9F7 : CF                                    MOV	B,M                    ;Count for that line (cc). Add one to the cc value to take
 1438/ 9F8 : 08                                    INR	B                    ;Account of the (cc) byte itself and then remove that
 1439/ 9F9 : 46 64 0A                              CALL	REMOVE             ;Many bytes to effectively delete the line fm the user
 1440/ 9FC : 36 83                                 MVI	L, 203o               ;Program buffer. Now see if line in input buffer consists
 1441/ 9FE : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Only of a line number by checking SYNTAX
 1442/ A00 : C7                                    MOV	A,M                    ;TOKEN value. Fetch the TOKEN value from its
 1443/ A01 : A0                                    ANA	A                    ;Storage location. If it is zero then input buffer only
 1444/ A02 : 68 B6 08                              JZ	EXEC               ;Contains a line number. Action is a pure Delete.
 1445/ A05 : 36 F0                      NOSAME:    MVI	L, 360o               ;Reset memory pointer to program buffer
 1446/ A07 : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;Line pointer storage location
 1447/ A09 : DF                                    MOV	D,M                    ;Load high order byte into CPU register D
 1448/ A0A : 30                                    INR	L                    ;Advance memory pointer
 1449/ A0B : E7                                    MOV	E,M                    ;Load low order byte into CPU register E
 1450/ A0C : 36 00                                 MVI	L, 000                ;Load L with address of start of line input buffer
 1451/ A0E : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Do same for CPU register H
 1452/ A10 : CF                                    MOV	B,M                    ;Get length of line input buffer
 1453/ A11 : 08                                    INR	B                    ;Advance length by one to include (cc) byte
 1454/ A12 : 46 85 0A                              CALL	INSERT             ;Go make room to insert line into user program buffer
 1455/ A15 : 36 F0                                 MVI	L, 360o               ;Reset memory pointer to program buffer
 1456/ A17 : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Line pointer storage location
 1457/ A19 : DF                                    MOV	D,M                    ;Load higher byte into CPU register D
 1458/ A1A : 30                                    INR	L                    ;Advance memory pointer
 1459/ A1B : E7                                    MOV	E,M                    ;Load low order byte into CPU register E
 1460/ A1C : 36 00                                 MVI	L, 000                ;Load L with address of start of line input buffer
 1461/ A1E : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Do same for CPU register H
 1462/ A20 : 46 26 0A                              CALL	MOVEC              ;Call subroutine to Insert line in input buffer into the
 1463/ A23 : 44 BD 08                              JMP	EXEC1              ;User program buffer then go back to start of EXEC.
 1464/ A26 : CF                         MOVEC:     MOV	B,M                    ;Fetch length of string in line input buffer
 1465/ A27 : 08                                    INR	B                    ;Increment that value to provide for (cc)
 1466/ A28 : C7                         MOVEPG:    MOV	A,M                    ;Fetch character from line input buffer
 1467/ A29 : 46 FF 02                              CALL	ADV                ;Advance pointer for line input buffer
 1468/ A2C : 46 EE 12                              CALL	SWITCH             ;Switch memory pointer to point to user pgm buffer
 1469/ A2F : F8                                    MOV	M,A                    ;Deposit character fm input buff into user pgm buff
 1470/ A30 : 46 FF 02                              CALL	ADV                ;Advance pointer for user program buffer
 1471/ A33 : 46 EE 12                              CALL	SWITCH             ;Switch memory pntr back to point to input buffer
 1472/ A36 : 09                                    DCR	B                    ;Decrement character counter stored in CPU register B
 1473/ A37 : 48 28 0A                              JNZ	MOVEPG             ;If counter does not go to zero continue transfer ops
 1474/ A3A : 07                                    RET                    ;When counter equals zero return to caMVI L,ng routine
 1475/ A3B : 36 F0                      CONTIN:    MVI	L, 360o               ;Reset memory pointer to program buffer
 1476/ A3D : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Line pointer storage location
 1477/ A3F : DF                                    MOV	D,M                    ;Load high order byte into CPU register D
 1478/ A40 : 30                                    INR	L                    ;Advance memory pointer
 1479/ A41 : E7                                    MOV	E,M                    ;Load low order byte into CPU register E
 1480/ A42 : EB                                    MOV	H,D                    ;Now set CPU register H to high part of address
 1481/ A43 : F4                                    MOV	L,E                    ;And set CPU register L to low part of address
 1482/ A44 : CF                                    MOV	B,M                    ;Fetch the character counter (cc) byte fm line in
 1483/ A45 : 08                                    INR	B                    ;Program buffer and add one to compensate for (cc)
 1484/ A46 : 46 C5 0A                              CALL	ADBDE              ;Add length of line value to old value to get new pointer
 1485/ A49 : 36 F0                                 MVI	L, 360o               ;Reset memory pointer to program buffer
 1486/ A4B : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Line pointer storage location
 1487/ A4D : FB                                    MOV	M,D                    ;Restore new high portion
 1488/ A4E : 30                                    INR	L                    ;Advance memory pointer
 1489/ A4F : FC                                    MOV	M,E                    ;And restore new low portion
 1490/ A50 : 44 7F 09                              JMP	GETAUX             ;Continue til find point at which to enter new line
 1491/ A53 : 2E 16                      GETCHP:    MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with pointer page (low portion set upon
 1492/ A55 : CF                                    MOV	B,M                    ;Entry). Now fetch pointer into CPU register B.
 1493/ A56 : 36 F0                                 MVI	L, 360o               ;Reset pntr to pgm buffer line pointer storage location
 1494/ A58 : DF                                    MOV	D,M                    ;Load high order byte into CPU register D
 1495/ A59 : 30                                    INR	L                    ;Advance memory pointer
 1496/ A5A : E7                                    MOV	E,M                    ;Load low order byte into CPU register E
 1497/ A5B : 46 C5 0A                              CALL	ADBDE              ;Add pointer to pgm buffer pointer to obtain address of
 1498/ A5E : EB                                    MOV	H,D                    ;Desired character. Place high part of new addr in H.
 1499/ A5F : F4                                    MOV	L,E                    ;And low part of new address in E.
 1500/ A60 : C7                                    MOV	A,M                    ;Fetch character from position in line in user pgm buffer
 1501/ A61 : 3C A0                                 CPI	240o               ;See if it is the ASCII code for space
 1502/ A63 : 07                                    RET                    ;Return to caller with flags set to indicate result
 1503/ A64 : 46 7C 03                   REMOVE:    CALL	INDEXB             ;Add (cc) plus one to addr of start of line
 1504/ A67 : D7                                    MOV	C,M                    ;Obtain byte from indexed location and
 1505/ A68 : 46 4B 03                              CALL	SUBHL              ;Subtract character count to obtain old location
 1506/ A6B : FA                                    MOV	M,C                    ;Put new byte in old location
 1507/ A6C : C2                                    MOV	A,C                    ;As well as in the Accumulator
 1508/ A6D : A0                                    ANA	A                    ;Test to see if zero byte to indicate end of user pgm buff
 1509/ A6E : 68 77 0A                              JZ	REMOV1             ;If it is end of user pgm buffer, go complete process
 1510/ A71 : 46 FF 02                              CALL	ADV                ;Otherwise add one to the present pointer value
 1511/ A74 : 44 64 0A                              JMP	REMOVE             ;And continue removing chamcters from the user pgm bf
 1512/ A77 : 36 F4                      REMOV1:    MVI	L, 364o               ;Load L with end of user pgm buffer pointer storage loc
 1513/ A79 : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of that pointer storage location
 1514/ A7B : DF                                    MOV	D,M                    ;Get page portion of end of pgm buffer address
 1515/ A7C : 30                                    INR	L                    ;Advance memory pointer
 1516/ A7D : C7                                    MOV	A,M                    ;And get low portion of end of pgm buffer address into
 1517/ A7E : 91                                    SUB	B                    ;Accumulator then subtract displacement value in B
 1518/ A7F : F8                                    MOV	M,A                    ;Restore new low portion of end of pgm buffer address
 1519/ A80 : 03                                    RNC                    ;If subtract did not cause carry can return now
 1520/ A81 : 31                                    DCR	L                    ;Otherwise decrement memory pointer back to page
 1521/ A82 : 19                                    DCR	D                    ;Storage location, decrement page value to give new page
 1522/ A83 : FB                                    MOV	M,D                    ;And store new page value back in buffer pntr storage loc
 1523/ A84 : 07                                    RET                    ;Then return to calling routine
 1524/ A85 : 36 F4                      INSERT:    MVI	L, 364o               ;Load L with end of user pgm buffer pointer storage loc
 1525/ A87 : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of that pointer storage location
 1526/ A89 : C7                                    MOV	A,M                    ; Get page portion of end of program buffer address
 1527/ A8A : 30                                    INR	L                    ;Advance memory pointer
 1528/ A8B : F7                                    MOV	L,M                    ;Load low portion of end of program buffer address
 1529/ A8C : E8                                    MOV	H,A                    ;Into L and finish setting up memory pointer
 1530/ A8D : 46 7C 03                              CALL	INDEXB             ;Add (cc) of line in input buffer to form new end of
 1531/ A90 : C5                                    MOV	A,H                    ;Program buffer address. Fetch new end of buffer page
 1532/ A91 : 3C 2D                                 CPI	ENDPGRAM           ;tt Address and see if this value would exceed user's
 1533/ A93 : 50 92 02                              JP	BIGERR             ;System capabilit'y. Go display error message if so!
 1534/ A96 : 46 4B 03                              CALL	SUBHL              ;Else restore original value of end of buffer address
 1535/ A99 : D7                         INSER1:    MOV	C,M                    ;Bring byte pointed to by H & L into CPU register C
 1536/ A9A : 46 7C 03                              CALL	INDEXB             ;Add displacement value to current memory pointer
 1537/ A9D : FA                                    MOV	M,C                    ;Store the byte in the new location
 1538/ A9E : 46 4B 03                              CALL	SUBHL              ;Now subtract displacement value from H & L
 1539/ AA1 : 46 BF 0A                              CALL	CPHLDE             ;Compare this with the address stored in D & E
 1540/ AA4 : 68 AD 0A                              JZ	INSER3             ;If same then go finish up Insert operation
 1541/ AA7 : 46 74 03                              CALL	DEC                ;Else set pointer to the byte before the byte just
 1542/ AAA : 44 99 0A                              JMP	INSER1             ;Processed and continue the Insert operation
 1543/ AAD :                            INSER3:
 1544/ AAD : 36 00                      INCLIN:    MVI	L, 000                ;Load L with start of line input buffer
 1545/ AAF : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of start of line input buffer
 1546/ AB1 : CF                                    MOV	B,M                    ;Fetch length of the line in line input buffer
 1547/ AB2 : 08                                    INR	B                    ;Increment value by one to include (cc) byte
 1548/ AB3 : 36 F4                                 MVI	L, 364o               ;Set memory pointer to end of user pgrn buffer pointer
 1549/ AB5 : DF                                    MOV	D,M                    ;Storage location on same page and fetch page address
 1550/ AB6 : 30                                    INR	L                    ;Of this pointer into D. Then advance memory pointer
 1551/ AB7 : E7                                    MOV	E,M                    ;And get low part of this pointer into CPU register E.
 1552/ AB8 : 46 C5 0A                              CALL	ADBDE              ;Now add displacement (cc) of line in input buffer to
 1553/ ABB : FC                                    MOV	M,E                    ;The end of program buffer pointer. Replace the updated
 1554/ ABC : 31                                    DCR	L                    ;Low portion of the new pointer value back in stomge
 1555/ ABD : FB                                    MOV	M,D                    ;And restore the new page value back into storage
 1556/ ABE : 07                                    RET                    ;Then return to calling routine
 1557/ ABF : C5                         CPHLDE:    MOV	A,H                    ;Subroutine to compare if the contents of CPU registers
 1558/ AC0 : BB                                    CMP	D                    ;H & L are equal to registers D & E. First compare
 1559/ AC1 : 0B                                    RNZ                    ;Register H to D. Return with flags set if not equal. If
 1560/ AC2 : C6                                    MOV	A,L                    ;Equal continue by comparing register L to E.
 1561/ AC3 : BC                                    CMP	E                    ;IF L equals E then H & L equal to D & E so return to
 1562/ AC4 : 07                                    RET                    ;Calling routines with flags set to equality status
 1563/ AC5 : C4                         ADBDE:     MOV	A,E                    ;Subroutine to add the contents of CPU register B (single
 1564/ AC6 : 81                                    ADD	B                    ;Byte value) to the double byte value in registers D & E.
 1565/ AC7 : E0                                    MOV	E,A                    ;First add B to E to form new least significant byte
 1566/ AC8 : 03                                    RNC                    ;Restore new value to E and exit if no carry resulted
 1567/ AC9 : 18                                    INR	D                    ;If had a carry then must increment most significant byte
 1568/ ACA : 07                                    RET                    ;In register D before returning to calling routine
 1569/ ACB : 06 DE                      CTRLC:     MVI	A, 336o               ;Set up ASCII code for t (up arrow) in Accumulator.
 1570/ ACD : 16 C3                                 MVI	C, 303o               ;Set up ASCII code for letter 'C' in CPU register C.
 1571/ ACF : 44 96 02                              JMP	ERROR              ;Go display the 'Control C' condition message.
 1572/ AD2 : 36 E0                      FINERR:    MVI	L, 340o               ;Load L with starting address of line number storage area
 1573/ AD4 : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of line number storage area
 1574/ AD6 : C7                                    MOV	A,M                    ;Get (cc) for line number string. If length is zero meaning
 1575/ AD7 : A0                                    ANA	A                    ;There is no line number stored in the buffer then jump
 1576/ AD8 : 68 E9 0A                              JZ	FINER1             ;Ahead to avoid displaying "AT LINE" message
 1577/ ADB : 36 F6                                 MVI	L, 366o               ;Else load L with address of start of "AT LINE" message
 1578/ ADD : 2E 01                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Stored on this page
 1579/ ADF : 46 51 03                              CALL	TEXTC              ;Call subroutine to display the "AT LINE" message
 1580/ AE2 : 36 E0                                 MVI	L, 340o               ;Now reset L to starting address of line number storage
 1581/ AE4 : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Area and do same for CPU register H
 1582/ AE6 : 46 51 03                              CALL	TEXTC              ;Call subroutine to display the line number
 1583/ AE9 : 46 61 03                   FINER1:    CALL	CRLF               ;Call subroutine to provide a carriage-return and line-feed
 1584/ AEC : 44 C7 09                   	   JMP	PATCH3 
 1585/ AEF :                            ;;; The following is the old code, before patch 3
 1586/ AEF :                            ;;;        JMP	EXEC               ;To the display device then return to EXECUTIVE.
 1587/ AEF : 06 C4                      DVERR:     MVI	A, 304o               ;Set up ASCII code for letter 'D' in Accumulator
 1588/ AF1 : 16 DA                                 MVI	C, 332o               ;Set up ASCII code for letter 'Z' in CPU register C
 1589/ AF3 : 44 96 02                              JMP	ERROR              ;Go display the 'DZ' (divide by zero) error message
 1590/ AF6 : 06 C6                      FIXERR:    MVI	A, 306o               ;Set up ASCII code for letter 'F' in Accumulator
 1591/ AF8 : 16 D8                                 MVI	C, 330o               ;Set up ASCII code for letter 'X' in CPU register C
 1592/ AFA : 44 96 02                              JMP	ERROR              ;Go display the 'FX' (FiX) error message
 1593/ AFD : 06 C9                      NUMERR:    MVI	A, 311o               ;Set up ASCII code for letter 'I' in Accumulator
 1594/ AFF : 16 CE                                 MVI	C, 316o               ;Set up ASCII code for letter 'N' in CPU register C
 1595/ B01 : 36 90                                 MVI	L, 220o               ;Load L with address of pointer used by DINPUT
 1596/ B03 : 2E 01                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Routine. Do same for register H.
 1597/ B05 : 3E 00                                 MVI	M, 000                ;Clear the location
 1598/ B07 : 44 96 02                              JMP	ERROR              ;Go display the'IN'(Illegal Number) error message
 1599/ B0A :                            
 1600/ B0A :                                                              ;The following subroutine, used by various sections of
 1601/ B0A :                                                              ;SCELBAL, will search the LINE INPUT BUGGER for
 1602/ B0A :                                                              ;a character string which is contained in a buffer starting
 1603/ B0A :                                                              ;at the address pointed to by CPU registers H & L when
 1604/ B0A :                                                              ;the subroutine is entered.
 1605/ B0A :                            
 1606/ B0A : 1E 16                      INSTR:     MVI	D,PG26 ;\HB\OLDPG26   ;**Set D to starting page of LINE INPUT BUFFER
 1607/ B0C : 26 00                                 MVI	E, 000                ;Load E with starting location of LINE INPUT BUFFER
 1608/ B0E : 46 34 0B                   INSTR1:    CALL	ADVDE              ;Advancer D & E pointer to the next location (input
 1609/ B11 : 46 CF 12                              CALL	SAVEHL             ;Buffer). Now save contents of d, E, H & L vefore the
 1610/ B14 : CF                                    MOV	B,M                    ;Compare operations. Get length of TEST buffer in B.
 1611/ B15 : 46 FF 02                              CALL	ADV                ;Advance H & L buffer to first char in TEST buffer.
 1612/ B18 : 46 F8 02                              CALL	STRCPC             ;Compare contents of TEST buffer against input buffer
 1613/ B1B : 68 DF 12                              JZ	RESTHL             ;For length B. If match, restore pntrs and exit to caller.
 1614/ B1E : 46 DF 12                              CALL	RESTHL             ;If no match, restore pointers for loop test.
 1615/ B21 : 36 00                                 MVI	L, 000                ;Load L with start of input buffer (to get the char cntr).
 1616/ B23 : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;**Load H with page of input buffer.
 1617/ B25 : C7                                    MOV	A,M                    ;Get length of buffer (cc) into the accumulator.
 1618/ B26 : BC                                    CMP	E                    ;Compare with current input buffer pointer value.
 1619/ B27 : 68 31 0B                              JZ	INSTR2             ;If at end of buffer, jump ahead.
 1620/ B2A : 46 DF 12                              CALL	RESTHL             ;Else restore test string address (H&L) and input buffer
 1621/ B2D : 44 0E 0B                              JMP	INSTR1             ;Address (D&E). Look gor occurrence of test string in ln.
 1622/ B30 : 00                                    HLT             ;Safety halt. If program reaches here have system failure.
 1623/ B31 : 26 00                      INSTR2:    MVI	E, 000                ;If reach end of input buffer without finding a match
 1624/ B33 : 07                                    RET                    ;Load E with 000 as an indicator and return to caller.
 1625/ B34 : 20                         ADVDE:     INR	E                    ;Subroutine to advance the pointer in the register
 1626/ B35 : 0B                                    RNZ                    ;Pair D & E. Advance contents of E. Return if not zero.
 1627/ B36 : 18                                    INR	D                    ;If register E goes to 0 when advanced, then advance
 1628/ B37 : 07                                    RET                    ;Register D too. Exit to calling routine.
 1629/ B38 :                            
 1630/ B38 :                            ;;; The label RUN should start at 13-170 0b78h
 1631/ B38 : 36 3B                      RUN:       MVI	L, 073o               ;Load L with addr of GOSUB/RETURN stack pointer
 1632/ B3A : 2E 17                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Load H with page of same pointer
 1633/ B3C : 3E 00                                 MVI	M, 000                ;Initialize the GOSUB/RETURN stack pointer to zero
 1634/ B3E : 36 85                                 MVI	L, 205o               ;Load L with addr of FOR/NEXT stack pointer
 1635/ B40 : 3E 00                                 MVI	M, 000                ;Initialize the FOR/NEXT stack pointer to zero
 1636/ B42 : 36 F0                                 MVI	L, 360o               ;Load L with addr of user pgm buffer line pointer
 1637/ B44 : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of user pgm buffer line pointer
 1638/ B46 : 3E 1B                                 MVI	M, BGNPGRAM           ;tt Initialize pointer (may be altered by user)   *******
 1639/ B48 : 30                                    INR	L                    ;Advance memory pointer to low portion of user pgm
 1640/ B49 : 3E 00                                 MVI	M, 000                ;Buffer pointer and initialize to start of buffer
 1641/ B4B : 44 6E 0B                              JMP	SAMLIN             ;Start executing user program with first line in buffer
 1642/ B4E : 36 F0                      NXTLIN:    MVI	L, 360o               ;Load L with addr of user program buffer line pointer
 1643/ B50 : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of user pgm buffer line pointer
 1644/ B52 : DF                                    MOV	D,M                    ;Place page addr of pgm buffer line pointer in D
 1645/ B53 : 30                                    INR	L                    ;Advance the memory pointer
 1646/ B54 : E7                                    MOV	E,M                    ;Place low addr of pgm buffer line pointer in E
 1647/ B55 : EB                                    MOV	H,D                    ;Also put page addr of pgm buffer line pointer in H
 1648/ B56 : F4                                    MOV	L,E                    ;And low addr of pgm buffer line pointer in L
 1649/ B57 : CF                                    MOV	B,M                    ;Now fetch the (cc) of current line into register B
 1650/ B58 : 08                                    INR	B                    ;Add one to account for (cc) byte itself
 1651/ B59 : 46 C5 0A                              CALL	ADBDE              ;Add value in B to D&E to point to next line in
 1652/ B5C : 36 F0                                 MVI	L, 360o               ;User program buffer. Reset L to addr of user logrn
 1653/ B5E : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Buffer pointer storage location. Store the new
 1654/ B60 : FB                                    MOV	M,D                    ;Updated user pgm line pointer in pointer storage
 1655/ B61 : 30                                    INR	L                    ;Location. Store both the high portion
 1656/ B62 : FC                                    MOV	M,E                    ;And low portion. (Now points to next line to be
 1657/ B63 : 36 E0                                 MVI	L, 340o               ;Processed from user program buffer.) Change pointer
 1658/ B65 : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** To address of line number buffer. Fetch the last
 1659/ B67 : C7                                    MOV	A,M                    ;Line number (length) processed. Test to see if it was
 1660/ B68 : A0                                    ANA	A                    ;Blank. If it was blank
 1661/ B69 : 68 B6 08                              JZ	EXEC               ;Then stop processing and return to the Executive
 1662/ B6C : C0                                    MOV	A,A                    ;Insert two effective NOPs here
 1663/ B6D : C0                                    MOV	A,A                    ;In case of patching
 1664/ B6E : 36 F0                      SAMLIN:    MVI	L, 360o               ;Load L with addr of user program buffer line pointer
 1665/ B70 : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of same pointer
 1666/ B72 : D7                                    MOV	C,M                    ;Fetch the high portion of the pointer into register C
 1667/ B73 : 30                                    INR	L                    ;Advance the memory pointer
 1668/ B74 : F7                                    MOV	L,M                    ;Fetch the low portion of the pointer into register L
 1669/ B75 : EA                                    MOV	H,C                    ;Now move the high portion into register H
 1670/ B76 : 1E 16                                 MVI	D,PG26 ;\HB\OLDPG26   ;** Set D to page of line input buffer
 1671/ B78 : 26 00                                 MVI	E, 000                ;Set E to address of start of line input buffer
 1672/ B7A : 46 26 0A                              CALL	MOVEC              ;Move the line ftom the user program buffer into the
 1673/ B7D : 36 00                                 MVI	L, 000                ;Line input buffer. Now reset the pointer to the start
 1674/ B7F : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Of the line input buffer.
 1675/ B81 : C7                                    MOV	A,M                    ;Fetch the first byte of the line input buffer (cc)
 1676/ B82 : A0                                    ANA	A                    ;Test (cc) value to see if fetched a blank line
 1677/ B83 : 68 B6 08                              JZ	EXEC               ;If fetched a blank line, return to the Executive
 1678/ B86 : 46 00 02                              CALL	SYNTAX             ;Else call subrtn to strip off line nr & set statement toke
 1679/ B89 :                            
 1680/ B89 : 36 83                      DIRECT:    MVI	L, 203o               ;Load L with address of syntax TOKEN storage location
 1681/ B8B : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of syntax TOKEN location
 1682/ B8D : C7                                    MOV	A,M                    ;Fetch the TOKEN value into the accumulator
 1683/ B8E : 3C 01                                 CPI	001                ;Is it token value for REM statement? If so, ignore the
 1684/ B90 : 68 4E 0B                              JZ	NXTLIN             ;Current line and go on to the next line in pgm buffer.
 1685/ B93 : 3C 02                                 CPI	002                ;Is it token value for IF statement?
 1686/ B95 : 68 17 0E                              JZ	IF                 ;If yes, then go to the IF statement routine.
 1687/ B98 : 3C 03                                 CPI	003                ;Is it token value for LET statement? (Using keyword)
 1688/ B9A : 68 19 0D                              JZ	LET                ;If yes, then go to the LET statement routine.
 1689/ B9D : 3C 04                                 CPI	004                ;Is it token value for GOTO statement?
 1690/ B9F : 68 7C 0D                              JZ	GOTO               ;If yes, then go to the GOTO statement routine.
 1691/ BA2 : 3C 05                                 CPI	005                ;Is it token value for PRINT statement?
 1692/ BA4 : 68 E5 0B                              JZ	PRINT              ;If yes, then go to the PRINT statement routine.
 1693/ BA7 : 3C 06                                 CPI	006                ;Is it token value for INPUT statement?
 1694/ BA9 : 68 F5 0E                              JZ	INPUT              ;If yes, then go to the INPUT statement routine.
 1695/ BAC : 3C 07                                 CPI	007                ;Is it token value for FOR statement?
 1696/ BAE : 68 74 0F                              JZ	FOR                ;If yes, then go to the FOR statement routine.
 1697/ BB1 : 3C 08                                 CPI	010o               ;Is it token value for NEXT statement?
 1698/ BB3 : 68 0B 18                              JZ	NEXT               ;If yes, then go to the NEXT statement routine.
 1699/ BB6 : 3C 09                                 CPI	011o               ;Is it token value for GOSUB statement?
 1700/ BB8 : 68 9E 0E                              JZ	GOSUB              ;If yes, then go to the GOSUB statement routine.
 1701/ BBB : 3C 0A                                 CPI	012o               ;Is it token value for RETURN statement?
 1702/ BBD : 68 C4 0E                              JZ	RETURN             ;If yes, then go to the RETURN statement routine.
 1703/ BC0 : 3C 0B                                 CPI	013o               ;Is it token value for DIM statement?
 1704/ BC2 : 68 F5 2D                              JZ	DIM                ;If yes, then go to the DIM statement routine.
 1705/ BC5 : 3C 0C                                 CPI	014o               ;Is it token value for END statement?
 1706/ BC7 : 68 B6 08                              JZ	EXEC               ;If yes, then go back to the Executive, user pgm finished!
 1707/ BCA : 3C 0D                                 CPI	015o               ;Is it token value for IMPLIED LET statement?
 1708/ BCC : 68 0B 0D                              JZ	LET0               ;If yes, then go to special LET entry point.
 1709/ BCF : 3C 0E                                 CPI	016o               ;@@ Is it token value for ARRAY IMPLIED LET?
 1710/ BD1 : 48 6A 09                              JNZ	SYNERR             ;If not, then assume a syntax error condition.
 1711/ BD4 : 46 6B 2D                              CALL	ARRAY1             ;@@ Else, perform array storage set up subroutine.
 1712/ BD7 : 36 86                                 MVI	L, 206o               ;@@ Set L to array pointer storage location.
 1713/ BD9 : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;@@ * * Set H to array pointer storage location.
 1714/ BDB : CF                                    MOV	B,M                    ;@@ Fetch array pointer to register B.
 1715/ BDC : 36 82                                 MVI	L, 202o               ;@@ Change memory pointer to syntax pntr storage loc.
 1716/ BDE : F9                                    MOV	M,B                    ;@@ Save array pointer value there.
 1717/ BDF : 46 A0 08                              CALL	SAVESY             ;@@ Save array name in auxiliary symbol buffer
 1718/ BE2 : 44 22 0D                              JMP	LET1
 1719/ BE5 : 36 82                      PRINT:     MVI	L, 202o               ;Load L with address of SCAN pointer storage location
 1720/ BE7 : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of SCAN pointer
 1721/ BE9 : C7                                    MOV	A,M                    ;Fetch the pointer value (last character scanned by the
 1722/ BEA : 36 00                                 MVI	L, 000                ;SYNTAX routine). Change pointer to line buffer (cc).
 1723/ BEC : BF                                    CMP	M                    ;Compare pointer value to buffer length. If not equal
 1724/ BED : 70 F6 0B                              JM	PRINT1             ;Then line contains more than stand alone PRINT state-
 1725/ BF0 : 46 61 03                              CALL	CRLF               ;Ment. However, if just have PRINT statement then issue
 1726/ BF3 : 44 4E 0B                              JMP	NXTLIN             ;A carriage-return & line-feed combination, then exit.
 1727/ BF6 : 46 AD 02                   PRINT1:    CALL	CLESYM             ;Initialize the SYMBOL buffer for new entry.
 1728/ BF9 : 36 82                                 MVI	L, 202o               ;Load L with address of SCAN buffer pointer
 1729/ BFB : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of SCAN pointer
 1730/ BFD : CF                                    MOV	B,M                    ;Pointer points to last char scanned by SYNTAX. Need
 1731/ BFE : 08                                    INR	B                    ;To increment it to point to next char in statement line.
 1732/ BFF : 36 83                                 MVI	L, 203o               ;Load L with address of former TOKEN value. Use it as
 1733/ C01 : F9                                    MOV	M,B                    ;Storage location for a PRINT statement pointer.
 1734/ C02 : 36 83                      PRINT2:    MVI	L, 203o               ;Set memory pointer to PRINT pointer storage location
 1735/ C04 : 46 A0 02                              CALL	GETCHR             ;Fetch character in input buffer pointed to by PRINT
 1736/ C07 : 3C A7                                 CPI	247o               ;Pointer. See if it is ASCII code for single quote mark.
 1737/ C09 : 68 83 0C                              JZ	QUOTE              ;If so, go to QUOTE section to process text string.
 1738/ C0C : 3C A2                                 CPI	242o               ;If not, see if it is ASCII code for double quote mark.
 1739/ C0E : 68 83 0C                              JZ	QUOTE              ;If so, go to QUOTE section to process text string.
 1740/ C11 : 3C AC                                 CPI	254o               ;If not, see if it is ASCII code for comma sign.
 1741/ C13 : 68 23 0C                              JZ	PRINT3             ;If so, go evaluate expression.
 1742/ C16 : 3C BB                                 CPI	273o               ;If not, see if it is ASCII code for semi-colon sign.
 1743/ C18 : 68 23 0C                              JZ	PRINT3             ;If so, go evaluate expression.
 1744/ C1B : 36 83                                 MVI	L, 203o               ;Load L with address of PRINT pointer storage location.
 1745/ C1D : 46 03 03                              CALL	LOOP               ;Increment pointer and test for end of line.
 1746/ C20 : 48 02 0C                              JNZ	PRINT2             ;If not end of line, fetch the next character.
 1747/ C23 : 36 82                      PRINT3:    MVI	L, 202o               ;Load L with address of SCAN pointer storage location
 1748/ C25 : CF                                    MOV	B,M                    ;Fetch value of the pointer (last letter of KEYWORD)
 1749/ C26 : 08                                    INR	B                    ;Add one to point to first character of expression
 1750/ C27 : 36 BE                                 MVI	L, 276o               ;Load L with addr of EVAL pointer storage location
 1751/ C29 : F9                                    MOV	M,B                    ;Store addr at which EVAL should start scanning
 1752/ C2A : 36 83                                 MVI	L, 203o               ;Load L with address of PRINT pointer
 1753/ C2C : CF                                    MOV	B,M                    ;Which points to field terminator
 1754/ C2D : 09                                    DCR	B                    ;Decrement pointer value to last character of expression
 1755/ C2E : 36 BF                                 MVI	L, 277o               ;Load L with address of EVAL FINISH pntr storage loc.
 1756/ C30 : F9                                    MOV	M,B                    ;Place address value of last char in PRINT field there
 1757/ C31 : 36 F7                                 MVI	L, 367o               ;Load L with address of QUOTE flag
 1758/ C33 : C7                                    MOV	A,M                    ;Fetch the value of the QUOTE flag into the ACC
 1759/ C34 : A0                                    ANA	A                    ;Test the QUOTE flag status
 1760/ C35 : 68 3D 0C                              JZ	PRINT4             ;If field not quoted, proceed to evaluate expression
 1761/ C38 : 3E 00                                 MVI	M, 000                ;If field quoted, then clear the QUOTE flag for next field
 1762/ C3A : 44 55 0C                              JMP	PRINT6             ;And skip the evaluation procedure
 1763/ C3D : 46 94 03                   PRINT4:    CALL	EVAL               ;Evaluate the current PRINT field
 1764/ C40 : 36 7F                                 MVI	L, 177o               ;Then load L,with address of the TAB flag
 1765/ C42 : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with the page of the TAB flag
 1766/ C44 : C7                                    MOV	A,M                    ;Fetch the value of the TAB flag into the accumulator
 1767/ C45 : A0                                    ANA	A                    ;Test the TAB flag
 1768/ C46 : 36 48                                 MVI	L, 110o               ;Change L to the FIXED/FLOAT flag location
 1769/ C48 : 2E 01                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Change H to the FIXED/FLOAT flag page
 1770/ C4A : 3E FF                                 MVI	M, 377o               ;Set FIXED/FLOAT flag to fixed point
 1771/ C4C : 6A CC 0C                   PRINT5:    CZ	PFPOUT             ;If TAB flag not set, display value of expression
 1772/ C4F : 36 7F                                 MVI	L, 177o               ;Load L with address of TAB flag
 1773/ C51 : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of TAB flag
 1774/ C53 : 3E 00                                 MVI	M, 000                ;Reset TAB flag for next PRINT field
 1775/ C55 : 36 83                      PRINT6:    MVI	L, 203o               ;Load L with address of PRINT pointer stomge location
 1776/ C57 : 46 A0 02                              CALL	GETCHR             ;Fetch the character pointed to by the PRINT pointer
 1777/ C5A : 3C AC                                 CPI	254o               ;See if the last character scanned was a comma sign
 1778/ C5C : 6A EF 0C                              CZ	PCOMMA             ;If so, then display spaces to next TA.B location
 1779/ C5F : 36 83                                 MVI	L, 203o               ;Reset L to address of PRINT pointer storage location
 1780/ C61 : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Reset H to page of PRINT pointer stomge location
 1781/ C63 : CF                                    MOV	B,M                    ;Fetch the value of the pointer into register B
 1782/ C64 : 36 82                                 MVI	L, 202o               ;Change L to SCAN pointer storage location
 1783/ C66 : F9                                    MOV	M,B                    ;Place end of last field processed into SCAN pointer
 1784/ C67 : 36 00                                 MVI	L, 000                ;Change pointer to start of line input buffer
 1785/ C69 : C1                                    MOV	A,B                    ;Place pntr to last char scanned into the accumulator
 1786/ C6A : BF                                    CMP	M                    ;Compare this value to the (cc) for the line buffer
 1787/ C6B : 70 F6 0B                              JM	PRINT1             ;If not end of line, continue to process next field
 1788/ C6E : 36 00                                 MVI	L, 000                ;If end of line, fetch the last character in the line
 1789/ C70 : 46 A0 02                              CALL	GETCHR             ;And check to see if it
 1790/ C73 : 3C AC                                 CPI	254o               ;Was a comma. If it was, go on to the next line in the
 1791/ C75 : 68 4E 0B                              JZ	NXTLIN             ;User program buffer without displaying a CR & LF.
 1792/ C78 : 3C BB                                 CPI	273o               ;If not a comma, check to see if it was a semi-colon.
 1793/ C7A : 68 4E 0B                              JZ	NXTLIN             ;If so, do not provide a CR & LF combination.
 1794/ C7D : 46 61 03                              CALL	CRLF               ;If not comma or semi-colon, provide CR & LF at end
 1795/ C80 : 44 4E 0B                              JMP	NXTLIN             ;Of a PRINT statement. Go process next line of pgrm.
 1796/ C83 : 36 F7                      QUOTE:     MVI	L, 367o               ;Load L with address of QUOTE flag
 1797/ C85 : F8                                    MOV	M,A                    ;Store type of quote in flag storage location
 1798/ C86 : 46 AD 02                              CALL	CLESYM             ;Initialize the SYMBOL buffer for new entry
 1799/ C89 : 36 83                                 MVI	L, 203o               ;Load L with address of PRINT pointer
 1800/ C8B : CF                                    MOV	B,M                    ;Fetch the PRINT pointer into register B
 1801/ C8C : 08                                    INR	B                    ;Add one to advance over quote character
 1802/ C8D : 36 84                                 MVI	L, 204o               ;Load L with address of QUOTE pointer
 1803/ C8F : F9                                    MOV	M,B                    ;Store the beginning of the QUOTE field pointer
 1804/ C90 : 36 84                      QUOTE1:    MVI	L, 204o               ;Load L with address of QUOTE pointer
 1805/ C92 : 46 A0 02                              CALL	GETCHR             ;Fetch the next character in the TEXT field
 1806/ C95 : 36 F7                                 MVI	L, 367o               ;Load L with the QUOTE flag (type of quote)
 1807/ C97 : BF                                    CMP	M                    ;Compare to see if latest character this quote mark
 1808/ C98 : 68 B3 0C                              JZ	QUOTE2             ;If so, finish up this quote field
 1809/ C9B : 46 82 03                              CALL	ECHO               ;If not, display the character as part of TEXT
 1810/ C9E : 36 84                                 MVI	L, 204o               ;Reset L to QUOTE pointer storage location
 1811/ CA0 : 46 03 03                              CALL	LOOP               ;Increment QUOTE pointer and test for end of line
 1812/ CA3 : 48 90 0C                              JNZ	QUOTE1             ;If not end of line, continue processing TEXT field
 1813/ CA6 : 06 C9                      QUOTER:    MVI	A, 311o               ;If end of line before closing quote mark have an error
 1814/ CA8 : 16 D1                                 MVI	C, 321o               ;So load ACC with I and register C with Q
 1815/ CAA : 36 F7                                 MVI	L, 367o               ;Load L with the address of the QUOTE flag
 1816/ CAC : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with the page of the QUOTE flag
 1817/ CAE : 3E 00                                 MVI	M, 000                ;Clear the QUOTE flag for future use
 1818/ CB0 : 44 96 02                              JMP	ERROR              ;Go display the IQ (Illegal Quote) error message
 1819/ CB3 : 36 84                      QUOTE2:    MVI	L, 204o               ;Load L with address of QUOTE pointer
 1820/ CB5 : CF                                    MOV	B,M                    ;Fetch the QUOTE pointer into register B
 1821/ CB6 : 36 82                                 MVI	L, 202o               ;Load L with address of SCAN pointer storage location
 1822/ CB8 : F9                                    MOV	M,B                    ;Store former QUOTE vointer as start of next field
 1823/ CB9 : C1                                    MOV	A,B                    ;Place QUOTE pointer into the accumulator
 1824/ CBA : 36 00                                 MVI	L, 000                ;Change L to point to start of the input line buffer
 1825/ CBC : BF                                    CMP	M                    ;Compare QUOTE pointer value with (cc) value
 1826/ CBD : 48 F6 0B                              JNZ	PRINT1             ;If not end of line, process next PRINT field
 1827/ CC0 : 46 61 03                              CALL	CRLF               ;Else display a CR & LF combination at the end of line
 1828/ CC3 : 36 F7                                 MVI	L, 367o               ;Load L with the address of the TAB flag
 1829/ CC5 : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with the page of the TAB flag
 1830/ CC7 : 3E 00                                 MVI	M, 000                ;Clear the TAB flag for future use
 1831/ CC9 : 44 4E 0B                              JMP	NXTLIN             ;Go process next line of the program.
 1832/ CCC :                            
 1833/ CCC :                                                              ;The following subroutines are utilized by the PRINT
 1834/ CCC :                                                              ;routine.
 1835/ CCC :                            ;;; The label PFPOUT SHOULD BE AT 14 314 0ccch
 1836/ CCC : 36 56                      PFPOUT:    MVI	L, 126o               ;Load L with the address of the FPACC MSW (Floating
 1837/ CCE : 2E 01                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Point ACC). Load H with page of the FPACC MSW.
 1838/ CD0 : C7                                    MOV	A,M                    ;Fetch the FPACC MSW into the accumulator. Test to
 1839/ CD1 : A0                                    ANA	A                    ;See if the FPACC MSW is zero. If so, then simply go and
 1840/ CD2 : 68 DE 0C                              JZ	ZERO               ;Display the value "0"
 1841/ CD5 : 30                                    INR	L                    ;Else advance the pointer to the FPACC Exponent
 1842/ CD6 : C7                                    MOV	A,M                    ;Fetch the FPACC Exponent into the accumulator
 1843/ CD7 : A0                                    ANA	A                    ;See if any exponent value. If not, mantissa is in range
 1844/ CD8 : 68 E8 0C                              JZ	FRAC               ;0.5 to 1.0. Treat number as a fraction.
 1845/ CDB : 44 75 14                              JMP	FPOUT              ;Else perform regular numerical output routine.
 1846/ CDE : 06 A0                      ZERO:      MVI	A, 240o               ;Load ASCII code for space into the ACC
 1847/ CE0 : 46 82 03                              CALL	ECHO               ;Display the space
 1848/ CE3 : 06 B0                                 MVI	A, 260o               ;Load ASCII code for 0 into the ACC
 1849/ CE5 : 44 82 03                              JMP	ECHO               ;Display 0 and exit to calling routine
 1850/ CE8 : 36 48                      FRAC:      MVI	L, 110o               ;Load L with address of FIXED/FLOAT flag
 1851/ CEA : 3E 00                                 MVI	M, 000                ;Reset it to indicate floating point mode
 1852/ CEC : 44 75 14                              JMP	FPOUT              ;Display floating point number and return to caller
 1853/ CEF : 36 00                      PCOMMA:    MVI	L, 000                ;Load L with address of (cc) in line input buffer
 1854/ CF1 : C7                                    MOV	A,M                    ;Fetch the (cc) for the line into the ACC
 1855/ CF2 : 36 83                                 MVI	L, 203o               ;Change pointer to PRINT pointer storage location
 1856/ CF4 : 97                                    SUB	M                    ;Subtract value of PRINT pointer from line (cc)
 1857/ CF5 : 33                                    RM                    ;If at end of buffer, do not TAB
 1858/ CF6 : 36 23                                 MVI	L, 043o               ;If not end, load L with address of COLUMN COUNTER
 1859/ CF8 : 2E 01                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to page of COLUMN COUNTER
 1860/ CFA : C7                                    MOV	A,M                    ;Fetch COLUMN COUNTER into the accumulator
 1861/ CFB : 24 F0                                 ANI	360o               ;Find the last TAB position (multiple of 16 decimal)
 1862/ CFD : 04 10                                 ADI	020o               ;Add 16 (decimal) to get new TAB position
 1863/ CFF : 97                                    SUB	M                    ;Subtract current position from next TAB position
 1864/ D00 : D0                                    MOV	C,A                    ;Store this value in register C as a counter
 1865/ D01 : 06 A0                                 MVI	A, 240o               ;Load the ACC with the ASCII code for space
 1866/ D03 : 46 82 03                   PCOM1:     CALL	ECHO               ;Display the space
 1867/ D06 : 11                                    DCR	C                    ;Decrement the loop counter
 1868/ D07 : 48 03 0D                              JNZ	PCOM1              ;Continue displaying spaces until loop counter is zero
 1869/ D0A : 07                                    RET                    ;Then return to calling routine
 1870/ D0B : 46 A0 08                   LET0:      CALL	SAVESY             ;Entry point for IMPLIED LET statement. Save the
 1871/ D0E : 36 82                                 MVI	L, 202o               ;Variable (to left of the equal sign). Set L to the SCAN
 1872/ D10 : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Pointer. Set H to the page of the SCAN pointer.
 1873/ D12 : CF                                    MOV	B,M                    ;Fetch value of SCAN pointer. (Points to = sign in In bf)
 1874/ D13 : 36 83                                 MVI	L, 203o               ;Change pointer to LET pointer (was TOKEN value)
 1875/ D15 : F9                                    MOV	M,B                    ;Place the SCAN pointer value into the LET pointer
 1876/ D16 : 44 61 0D                              JMP	LET5               ;Continue processing the LET statement line
 1877/ D19 : 46 AD 02                   LET:       CALL	CLESYM             ;Initialize the SYMBOL BUFFER for new entry
 1878/ D1C : 36 64                                 MVI	L, 144o               ;Load L with address of start of AUX SYMBOL BUFF
 1879/ D1E : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of AUX SYMBOL BUFFER
 1880/ D20 : 3E 00                                 MVI	M, 000                ;Initialize AUX SYMBOL BUFFER
 1881/ D22 : 36 82                      LET1:      MVI	L, 202o               ;Entry point for ARRAY IMPLIED LET statement.
 1882/ D24 : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set pointer to SCAN pointer storage location
 1883/ D26 : CF                                    MOV	B,M                    ;Fetch the SCAN pointer value (last letter scanned by
 1884/ D27 : 08                                    INR	B                    ;SYNTAX subroutine) and add one to next character
 1885/ D28 : 36 83                                 MVI	L, 203o               ;Change L to LET pointer storage location
 1886/ D2A : F9                                    MOV	M,B                    ;Store former SCAN value (updated) in LET pointer
 1887/ D2B : 36 83                      LET2:      MVI	L, 203o               ;Set L to gtorage location of LET pointer
 1888/ D2D : 46 A0 02                              CALL	GETCHR             ;Fetch the character pointed to by the LET pointer
 1889/ D30 : 68 52 0D                              JZ	LET4               ;If character is a space, ignore it
 1890/ D33 : 3C BD                                 CPI	275o               ;See if character is the equal (=) sign
 1891/ D35 : 68 61 0D                              JZ	LET5               ;If so, go process other side of the statement (after
 1892/ D38 : 3C A8                                 CPI	250o               ;@@ If not, see if character is a right parenthesis
 1893/ D3A : 48 4B 0D                              JNZ	LET3               ;If not, continue looking for equal sign
 1894/ D3D : 46 65 2D                              CALL	ARRAY              ;@@ If so, have subscript. Call array set up subroutine.
 1895/ D40 : 36 86                                 MVI	L, 206o               ;@@ Load L with address of ARRAY pointer
 1896/ D42 : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;@@ ** Load H with page of ARRAY pointer
 1897/ D44 : CF                                    MOV	B,M                    ;@@ Fetch value (points to ")" character of subscript)
 1898/ D45 : 36 83                                 MVI	L, 203o               ;@@ Load L with address of LET pointer
 1899/ D47 : F9                                    MOV	M,B                    ;@@ Place ARRAY pointer value as new LET pointer
 1900/ D48 : 44 52 0D                              JMP	LET4               ;@@ Continue to look for = sign in statement line
 1901/ D4B : 36 64                      LET3:      MVI	L, 144o               ;Reset L to start of AUX SYMBOL BUFFER
 1902/ D4D : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ** Load H with page of AUX SYMBOL BUFFER
 1903/ D4F : 46 CC 02                              CALL	CONCT1             ;Concatenate character to the AUX SYMBOL BUFFER
 1904/ D52 : 36 83                      LET4:      MVI	L, 203o               ;Load L with address of LET pointer storage location
 1905/ D54 : 46 03 03                              CALL	LOOP               ;Add one to pointer and test for end of line input buffer
 1906/ D57 : 48 2B 0D                              JNZ	LET2               ;If not end of line, continue looking for the equal sign
 1907/ D5A : 06 CC                      LETERR:    MVI	A, 314o               ;If do not find an equal sign in the LET statement line
 1908/ D5C : 16 C5                                 MVI	C, 305o               ;Then have a LE (Let Error). Load the code for L and E
 1909/ D5E : 44 96 02                              JMP	ERROR              ;Into registers ACC and C and go display the error msg.
 1910/ D61 : 36 83                      LET5:      MVI	L, 203o               ;When find the equal sign, reset L to point to the LET
 1911/ D63 : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Pointer and H to the proper page. Fetch the pointer
 1912/ D65 : CF                                    MOV	B,M                    ;Value into register B and add one to advance pointer
 1913/ D66 : 08                                    INR	B                    ;Over the equal sign to first char in the expression.
 1914/ D67 : 36 BE                                 MVI	L, 276o               ;Set L to point to the address of the EVAL pointer
 1915/ D69 : F9                                    MOV	M,B                    ;Set EVAL pointer to start evaluating right after the
 1916/ D6A : 36 00                                 MVI	L, 000                ;Equal sign. Now change L to start of line input buffer.
 1917/ D6C : CF                                    MOV	B,M                    ;Fetch the (cc) value into register B. (Length of line.)
 1918/ D6D : 36 BF                                 MVI	L, 277o               ;Load L with EVAL FINISH pointer storage location.
 1919/ D6F : F9                                    MOV	M,B                    ;Set it to stop evaluating at end of the line.
 1920/ D70 : 46 94 03                              CALL	EVAL               ;Call the subroutine to evaluate the expression.
 1921/ D73 : 46 AA 08                              CALL	RESTSY             ;Restore the name of the variable to receive new value.
 1922/ D76 : 46 2D 08                              CALL	STOSYM             ;Store the new value for the variable in variables table.
 1923/ D79 : 44 4E 0B                              JMP	NXTLIN             ;Go process next line of the program.
 1924/ D7C : 36 E8                      GOTO:      MVI	L, 350o               ;Load L with start of AUX LINE NR BUFFER
 1925/ D7E : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of AUX LINE NR BUFFER
 1926/ D80 : 3E 00                                 MVI	M, 000                ;Initialize the AUX LINE NR BUFFER to zero
 1927/ D82 : 36 82                                 MVI	L, 202o               ;Load L with address of SCAN pointer storage location
 1928/ D84 : CF                                    MOV	B,M                    ;Fetch pointer value (last char scanned by SYNTAX)
 1929/ D85 : 08                                    INR	B                    ;Add one to skip over the last 0 in GOTO keyword
 1930/ D86 : 36 83                                 MVI	L, 203o               ;Change pointer to GOTO pointer (formerly TOKEN)
 1931/ D88 : F9                                    MOV	M,B                    ;Store the updated SCAN pointer as the GOTO pointer
 1932/ D89 : 36 83                      GOTO1:     MVI	L, 203o               ;Load L with address of GOTO pointer
 1933/ D8B : 46 A0 02                              CALL	GETCHR             ;Fetch the character pointed to by the GOTO pointer
 1934/ D8E : 68 A0 0D                              JZ	GOTO2              ;If character was a space, ignore it
 1935/ D91 : 3C B0                                 CPI	260o               ;See if character is in the range of a decimal digit
 1936/ D93 : 70 A8 0D                              JM	GOTO3              ;If not, must have end of the line number digit string
 1937/ D96 : 3C BA                                 CPI	272o               ;Continue to test for decitnal digit
 1938/ D98 : 50 A8 0D                              JP	GOTO3              ;If not, mugt have end of the line number digit string
 1939/ D9B : 36 E8                                 MVI	L, 350o               ;If valid decimal digit, load L with addr of AUX LINE
 1940/ D9D : 46 CC 02                              CALL	CONCT1             ;NR BUFFER and concatenate digit to the buffer.
 1941/ DA0 : 36 83                      GOTO2:     MVI	L, 203o               ;Reset pointer to GOTO pointer storage location
 1942/ DA2 : 46 03 03                              CALL	LOOP               ;Advance the pointer value and test for end of line
 1943/ DA5 : 48 89 0D                              JNZ	GOTO1              ;If not end of line, fetch next digit in GOTO line number
 1944/ DA8 : 36 F0                      GOTO3:	   MVI	L, 360o               ;Set L to user program buffer pointer storage location
 1945/ DAA : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of program buffer pointer
 1946/ DAC : 3E 1B                                 MVI	M, BGNPGRAM           ;Initialize high part of pointer to start of pgm buffer
 1947/ DAE : 30                                    INR	L                    ;Advance the memory point
 1948/ DAF : 3E 00                                 MVI	M, 000                ;Initialize the low part of pointer to start of pgm buffer
 1949/ DB1 : 46 AD 02                   GOTO4:     CALL	CLESYM             ;Clear the SYMBOL BUFFER
 1950/ DB4 : 36 84                                 MVI	L, 204o               ;Load L with address of GOTO SEARCH pointer
 1951/ DB6 : 3E 01                                 MVI	M, 001                ;Initialize to one for first char of line
 1952/ DB8 : 36 84                      GOTO5:     MVI	L, 204o               ;Load L with address of GOTO SEARCH pointer
 1953/ DBA : 46 53 0A                              CALL	GETCHP             ;Fetch character pointed to by GOTO SEARCH pointer
 1954/ DBD : 68 CD 0D                              JZ	GOTO6              ;From line pointed to in user program buffer. Ignore
 1955/ DC0 : 3C B0                                 CPI	260o               ;Spaces. Check to see if character is a decirnal digit.
 1956/ DC2 : 70 E0 0D                              JM	GOTO7              ;If not, then have processed line number at the start of
 1957/ DC5 : 3C BA                                 CPI	272o               ;The current line. Continue the check for a valid decimal
 1958/ DC7 : 50 E0 0D                              JP	GOTO7              ;Digit. If have a decirnal digit then concatenate the digit
 1959/ DCA : 46 C8 02                              CALL	CONCTS             ;Onto the current string in the SYMBOL BUFFER,
 1960/ DCD : 36 84                      GOTO6:     MVI	L, 204o               ;Change L to the address of the GOTO SEARCH pointer
 1961/ DCF : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** And H to the proper page of the pointer
 1962/ DD1 : CF                                    MOV	B,M                    ;Fetch the GOTO SEARCH pointer value
 1963/ DD2 : 08                                    INR	B                    ;Increment the GOTO SEARCH pointer
 1964/ DD3 : F9                                    MOV	M,B                    ;And restore it back to memory
 1965/ DD4 : 36 F0                                 MVI	L, 360o               ;Change L to address of user program buffer pointer
 1966/ DD6 : D7                                    MOV	C,M                    ;Save the high part of this pointer value in register C
 1967/ DD7 : 30                                    INR	L                    ;Advance L to the low part of the pgrn buffer pointer
 1968/ DD8 : F7                                    MOV	L,M                    ;Now load it into L
 1969/ DD9 : EA                                    MOV	H,C                    ;And transfer C into H to point to start of the line
 1970/ DDA : C7                                    MOV	A,M                    ;Fetch the (cc) of the current line being pointed to in the
 1971/ DDB : 09                                    DCR	B                    ;User pgm buff. Decrernent B to previous value. Compare
 1972/ DDC : B9                                    CMP	B                    ;GOTO SEARCH pointer value to length of current line.
 1973/ DDD : 48 B8 0D                              JNZ	GOTO5              ;If not end of line then continue getting current line nr.
 1974/ DE0 : 36 50                      GOTO7:     MVI	L, 120o               ;Load L with address of start of the SYMBOL BUFFER
 1975/ DE2 : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;Set H to the page of the SYMBOL BUFFER
 1976/ DE4 : 1E 16                                 MVI	D,PG26 ;\HB\OLDPG26   ;Set D to the page of the AUX LINE NR BUFFER
 1977/ DE6 : 26 E8                                 MVI	E, 350o               ;Set E to the start of the AUX LINE NR BUFFER
 1978/ DE8 : 46 DA 02                              CALL	STRCP              ;Compare GOTO line number against current line nr.
 1979/ DEB : 68 6E 0B                              JZ	SAMLIN             ;If they match, found GOTO line. Pick up ops there!
 1980/ DEE : 36 F0                                 MVI	L, 360o               ;Else, set L to user program buffer pntr storage location
 1981/ DF0 : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of user program buffer pointer
 1982/ DF2 : DF                                    MOV	D,M                    ;Fetch the high part of this pointer into register D
 1983/ DF3 : 30                                    INR	L                    ;Advance the memory pointer
 1984/ DF4 : E7                                    MOV	E,M                    ;Fetch the low part into register E
 1985/ DF5 : EB                                    MOV	H,D                    ;Transfer the pointer to H
 1986/ DF6 : F4                                    MOV	L,E                    ;And L. Fetch the (cc) of the current line into register
 1987/ DF7 : CF                                    MOV	B,M                    ;B and then add one to account for the (cc) byte to get
 1988/ DF8 : 08                                    INR	B                    ;Total length of the current line in the user pgm buffer
 1989/ DF9 : 46 C5 0A                              CALL	ADBDE              ;Add the total length to the pointer value in D & E
 1990/ DFC : 36 F0                                 MVI	L, 360o               ;To get the starting address of the next line in the user
 1991/ DFE : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** User program buffer. Place the new value for the user
 1992/ E00 : FB                                    MOV	M,D                    ;Program buffer pointer back into the user program
 1993/ E01 : 30                                    INR	L                    ;Buffer pointer storage locations so that it points to the
 1994/ E02 : FC                                    MOV	M,E                    ;Next line to be processed in the user program buffer.
 1995/ E03 : 36 F4                                 MVI	L, 364o               ;Load L with address of end of user pgm buffer storage
 1996/ E05 : C3                                    MOV	A,D                    ;Location (page address) and fetch end of buffer page.
 1997/ E06 : BF                                    CMP	M                    ;Compare this with next line pointer (updated).
 1998/ E07 : 48 B1 0D                              JNZ	GOTO4              ;If not end of buffer, keep looking for the specified line
 1999/ E0A : 30                                    INR	L                    ;If have same page addresses, check the low address
 2000/ E0B : C4                                    MOV	A,E                    ;Portions to see if
 2001/ E0C : BF                                    CMP	M                    ;Have reached end of user program buffer
 2002/ E0D : 48 B1 0D                              JNZ	GOTO4              ;If not, continue looking. If end of buffer without
 2003/ E10 : 06 D5                      GOTOER:    MVI	A, 325o               ;Finding specified line, then have an error condition.
 2004/ E12 : 16 CE                                 MVI	C, 316o               ;Load ACC and register C with code for "UN" and go
 2005/ E14 : 44 96 02                              JMP	ERROR              ;Display "Undefined Line" error message.
 2006/ E17 : 36 82                      IF:        MVI	L, 202o               ;Set L to SCAN pointer storage location.
 2007/ E19 : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H to page of SCAN pointer storage location.
 2008/ E1B : CF                                    MOV	B,M                    ;Fetch the SCAN pointer value to register B.
 2009/ E1C : 08                                    INR	B                    ;Add one to advance pointer over last char scanned.
 2010/ E1D : 36 BE                                 MVI	L, 276o               ;Change L to address of EVAL pointer. Set up EVAL
 2011/ E1F : F9                                    MOV	M,B                    ;Pointer to begin evaluation with next char in the line.
 2012/ E20 : 46 AD 02                              CALL	CLESYM             ;Clear the SYMBOL BUFFER.
 2013/ E23 : 36 D0                                 MVI	L, 320o               ;Set L to starting address of THEN in look-up table.
 2014/ E25 : 2E 01                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to page of the look-up table.
 2015/ E27 : 46 0A 0B                              CALL	INSTR              ;Search for occurrence of THEN in the line input buffer.
 2016/ E2A : C4                                    MOV	A,E                    ;Transfer register E to ACC. If THEN not found
 2017/ E2B : A0                                    ANA	A                    ;The value in E will be zero.
 2018/ E2C : 48 42 0E                              JNZ	IF1                ;If THEN found, can evaluate the IF expression.
 2019/ E2F : 36 0B                                 MVI	L, 013o               ;If THEN not found, set L to Auting address of GOTO
 2020/ E31 : 2E 17                                 MVI	H,PG27 ;\HB\OLDPG27   ;** In the KEYWORD look-up table. Set H to table
 2021/ E33 : 46 0A 0B                              CALL	INSTR              ;Search for occurrence of GOTO in the line input buffer.
 2022/ E36 : C4                                    MOV	A,E                    ;Transfer E to ACC. If GOTO not found
 2023/ E37 : A0                                    ANA	A                    ;The value in E will be zero.
 2024/ E38 : 48 42 0E                              JNZ	IF1                ;If GOTO found, can evaluate the IF expression.
 2025/ E3B : 06 C9                      IFERR:     MVI	A, 311o               ;Set ASCII code for letter I in ACC
 2026/ E3D : 16 C6                                 MVI	C, 306o               ;And code for letter F in register C
 2027/ E3F : 44 96 02                              JMP	ERROR              ;Go display the IF error message
 2028/ E42 : 36 BF                      IF1:       MVI	L, 277o               ;Load L with addr of EVAL FINISH pointer storage loc
 2029/ E44 : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of storage location
 2030/ E46 : 21                                    DCR	E                    ;Subtract one from pointer in E and set the EVAL
 2031/ E47 : FC                                    MOV	M,E                    ;FINISH pointer so that it will evaluate up to the THEN
 2032/ E48 : 46 94 03                              CALL	EVAL               ;Or GOTO directive. Evaluate the expression.
 2033/ E4B : 36 56                                 MVI	L, 126o               ;Load L with address of FPACC Most Significant Word
 2034/ E4D : 2E 01                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Load H with page of FPACC MSW
 2035/ E4F : C7                                    MOV	A,M                    ;Fetch the FPACC MSW into the accumulator
 2036/ E50 : A0                                    ANA	A                    ;Test the value of the FPACC MSW
 2037/ E51 : 68 4E 0B                              JZ	NXTLIN             ;If it is zero, IF condition failed, ignore rest of line.
 2038/ E54 : 36 BF                                 MVI	L, 277o               ;If not, load L with addr of EVAL FINISH pointer
 2039/ E56 : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to the appmpriate page
 2040/ E58 : C7                                    MOV	A,M                    ;Fetch the value in the EVAL FINISH pointer
 2041/ E59 : 04 05                                 ADI	005                ;Add five to skip over THEN or GOTO directive
 2042/ E5B : 36 82                                 MVI	L, 202o               ;Change L to SCAN pointer stomge location
 2043/ E5D : F8                                    MOV	M,A                    ;Set up the SCAN pointer to location after THEN or
 2044/ E5E : C8                                    MOV	B,A                    ;GOTO directive. Also put this value in register B.
 2045/ E5F : 08                                    INR	B                    ;Add one to the value in B to point to next character
 2046/ E60 : 36 84                                 MVI	L, 204o               ;After THEN or GOTO. Change L to addr of THEN pntr
 2047/ E62 : F9                                    MOV	M,B                    ;Storage location and store the pointer value.
 2048/ E63 : 36 84                      IF2:       MVI	L, 204o               ;Load L with the address of the THEN pointer
 2049/ E65 : 46 A0 02                              CALL	GETCHR             ;Fetch the character pointed to by the THEN pointer
 2050/ E68 : 48 76 0E                              JNZ	IF3                ;If character is not a space, exit this loop
 2051/ E6B : 36 84                                 MVI	L, 204o               ;If fetch a space, ignore. Reset L to the THEN pointer
 2052/ E6D : 46 03 03                              CALL	LOOP               ;Add one to the THEN pointer and test for end of line
 2053/ E70 : 48 63 0E                              JNZ	IF2                ;If not end of line, keep looking for a character other
 2054/ E73 : 44 3B 0E                              JMP	IFERR              ;Than a space. If reach end of line first, then error
 2055/ E76 : 3C B0                      IF3:       CPI	260o               ;When find a character see if it is numeric.
 2056/ E78 : 70 80 0E                              JM	IF4                ;If not numeric, then should have a new type of
 2057/ E7B : 3C BA                                 CPI	272o               ;Statement. If numeric, then should have a line number.
 2058/ E7D : 70 7C 0D                              JM	GOTO               ;So process as though have a GOTO statement!
 2059/ E80 : 36 00                      IF4:       MVI	L, 000                ;Load L with addr of start of line input buffer.
 2060/ E82 : C7                                    MOV	A,M                    ;Fetch the (cc) byte to get length of line value.
 2061/ E83 : 36 84                                 MVI	L, 204o               ;Change L to current value of THEN pointer (where first
 2062/ E85 : 97                                    SUB	M                    ;Non-space char. found after THEN or GOTO). Subtract
 2063/ E86 : C8                                    MOV	B,A                    ;This value from length of line to get remainder. Now
 2064/ E87 : 08                                    INR	B                    ;Have length of second statement portion. Add one for
 2065/ E88 : D7                                    MOV	C,M                    ;(cc) count. Save THEN pointer value in register C.
 2066/ E89 : 36 00                                 MVI	L, 000                ;Reset L to start of line input buffer. Now put length of
 2067/ E8B : F9                                    MOV	M,B                    ;Second statement into (cc) position of input buffer.
 2068/ E8C : F2                                    MOV	L,C                    ;Set L to where second statement starts.
 2069/ E8D : 1E 16                                 MVI	D,PG26 ;\HB\OLDPG26   ;** Set D to page of line input buffer.
 2070/ E8F : 26 01                                 MVI	E, 001                ;Set E to first character position of line input buffer.
 2071/ E91 : 46 0B 11                              CALL	MOVEIT             ;Move the second statement up in line to become first!
 2072/ E94 : 36 82                                 MVI	L, 202o               ;Load L with address of new SCAN pointer. Load
 2073/ E96 : 3E 01                                 MVI	M, 001                ;It with starting position for SYNTAX scan.
 2074/ E98 : 46 37 02                              CALL	SYNTX4             ;Use special entry to SYNTAX to get new TOKEN value.
 2075/ E9B : 44 89 0B                              JMP	DIRECT             ;Process the second statement in the original line.
 2076/ E9E : 36 E0                      GOSUB:     MVI	L, 340o               ;Load L with start of LINE NUMBER BUFFER
 2077/ EA0 : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;Fetch (cc) of cuffent line number into register D
 2078/ EA2 : DF                                    MOV	D,M                    ;Fetch high value (page) of pgm line pointer to D
 2079/ EA3 : 18                                    INR	D                    ;Test contents of register by first incrementing
 2080/ EA4 : 19                                    DCR	D                    ;And then decrementing the value in the register
 2081/ EA5 : 68 AD 0E                              JZ	GOSUB1             ;If no line number, then processing a DIRECT statement
 2082/ EA8 : 36 F0                                 MVI	L, 360o               ;Else, load L with address of user pgm buff line pointer
 2083/ EAA : DF                                    MOV	D,M                    ;Fetch high value (page) of pgm line pointer to D
 2084/ EAB : 30                                    INR	L                    ;Advance the memory pointer
 2085/ EAC : E7                                    MOV	E,M                    ;Fetch the low part of pgm line pointer to E
 2086/ EAD : 36 3B                      GOSUB1:    MVI	L, 073o               ;Set L to address of GOSUB STACK POINTER
 2087/ EAF : 2E 17                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Set H to page of GOSUB STACK POINTER
 2088/ EB1 : C7                                    MOV	A,M                    ;Fetch value in GOSUB stack pointer to ACC
 2089/ EB2 : 04 02                                 ADI	002                ;Add two to current stack pointer for new data to be
 2090/ EB4 : 3C 11                                 CPI	021o               ;Placed on the stack and see if stack overflows
 2091/ EB6 : 50 E7 0E                              JP	GOSERR             ;If stack filled, have an error condition
 2092/ EB9 : F8                                    MOV	M,A                    ;Else, store updated stack pointer
 2093/ EBA : 36 3E                                 MVI	L, 076o               ;Load L with address of start of stack less offset (2)
 2094/ EBC : 86                                    ADD	L                    ;Add GOSUB stack pointer to base address
 2095/ EBD : F0                                    MOV	L,A                    ;To get pointer to top of stack (page byte)
 2096/ EBE : FB                                    MOV	M,D                    ;Store page part of pgm buffer line pointer in stack
 2097/ EBF : 30                                    INR	L                    ;Advance pointer to next byte in stack
 2098/ EC0 : FC                                    MOV	M,E                    ;Store low part of pgm buffer line pointer in stack
 2099/ EC1 : 44 7C 0D                              JMP	GOTO               ;Proceed from here as though processing a GOTO
 2100/ EC4 : 36 3B                      RETURN:    MVI	L, 073o               ;Set L to address of GOSUB STACK POINTER
 2101/ EC6 : 2E 17                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Set H to page of GOSUB STACK POINTER
 2102/ EC8 : C7                                    MOV	A,M                    ;Fetch the value of GOSUB stack pointer to ACC
 2103/ EC9 : 14 02                                 SUI	002                ;Subtract two for data to be removed from stack
 2104/ ECB : 70 EE 0E                              JM	RETERR             ;If stack underflow, then have an error condition
 2105/ ECE : F8                                    MOV	M,A                    ;Restore new stack pointer to memory
 2106/ ECF : 04 02                                 ADI	002                ;Add two to point to previous top of stack
 2107/ ED1 : 36 3E                                 MVI	L, 076o               ;Load L with address of start of GOSUB stack less two
 2108/ ED3 : 86                                    ADD	L                    ;Add address of previous top of stack to base value
 2109/ ED4 : F0                                    MOV	L,A                    ;Set pointer to high address value in the stack
 2110/ ED5 : DF                                    MOV	D,M                    ;Fetch the high address value from stack to register D
 2111/ ED6 : 18                                    INR	D                    ;Exercise the register contents to see if high address
 2112/ ED7 : 19                                    DCR	D                    ;Obtained is zero. If so, original GOSUB statement was
 2113/ ED8 : 68 B6 08                              JZ	EXEC               ;A DIRECT statement. Must return to Executive!
 2114/ EDB : 30                                    INR	L                    ;Else, advance pointer to get low address value from the
 2115/ EDC : E7                                    MOV	E,M                    ;Stack into CPU register E.
 2116/ EDD : 36 F0                                 MVI	L, 360o               ;Load L with address of user pgm line pointer storage
 2117/ EDF : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Location. Load H with page of user pgm line pntr.
 2118/ EE1 : FB                                    MOV	M,D                    ;Put high address from stack into pgm line pointer.
 2119/ EE2 : 30                                    INR	L                    ;Advance the memory pointer
 2120/ EE3 : FC                                    MOV	M,E                    ;Put low address from stack into pgrn line pointer.
 2121/ EE4 : 44 4E 0B                              JMP	NXTLIN             ;Execute the next line after originating GOSUB line!
 2122/ EE7 : 06 C7                      GOSERR:    MVI	A, 307o               ;Load ASCII code for letter G into accumulator
 2123/ EE9 : 16 D3                                 MVI	C, 323o               ;Load ASCII code for letter S into register C
 2124/ EEB : 44 96 02                              JMP	ERROR              ;Go display GoSub (GS) error message.
 2125/ EEE : 06 D2                      RETERR:    MVI	A, 322o               ;Load ASCII code for letter R into accumulator
 2126/ EF0 : 16 D4                                 MVI	C, 324o               ;Load ASCII code for letter T into register C
 2127/ EF2 : 44 96 02                              JMP	ERROR              ;Go display ReTurn (RT) error message.
 2128/ EF5 : 46 AD 02                   INPUT:     CALL	CLESYM             ;Clear the SYMBOL BUFFER
 2129/ EF8 : 36 82                                 MVI	L, 202o               ;Load L with address of SCAN pointer storage location
 2130/ EFA : CF                                    MOV	B,M                    ;Fetch value of SCAN pointer to register B
 2131/ EFB : 08                                    INR	B                    ;Increment value to point to next chamcter
 2132/ EFC : 36 83                                 MVI	L, 203o               ;Change L to point to INPUT pointer (formerly TOKEN)
 2133/ EFE : F9                                    MOV	M,B                    ;Updated SCAN pointer becomes INPUT pointer
 2134/ EFF : 36 83                      INPUT1:    MVI	L, 203o               ;Load L with address of INPUT pointer
 2135/ F01 : 46 A0 02                              CALL	GETCHR             ;Fetch a character from the line input buffer
 2136/ F04 : 68 22 0F                              JZ	INPUT3             ;If character is a space, ignore it. Else,
 2137/ F07 : 3C AC                                 CPI	254o               ;See if character is a comma. If so, process the
 2138/ F09 : 68 33 0F                              JZ	INPUT4             ;Variable that preceeds the comma.
 2139/ F0C : 3C A8                                 CPI	250o               ;If not, see if character is a left parenthesis.
 2140/ F0E : 48 1F 0F                              JNZ	INPUT2             ;If not, continue processing to build up symbolic variable
 2141/ F11 : 46 70 2D                              CALL	ARRAY2             ;@@ If so, call array subscripting subroutine
 2142/ F14 : 36 86                                 MVI	L, 206o               ;@@ Load L with address of array set up pointer
 2143/ F16 : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;@@ ** Load H with page of array set up pointer
 2144/ F18 : CF                                    MOV	B,M                    ;@@ Fetch pointer value (point to ")" of subscript)
 2145/ F19 : 36 83                                 MVI	L, 203o               ;@@ Change pointer to address of INPUT pointer
 2146/ F1B : F9                                    MOV	M,B                    ;@@ Update INPUT pointer
 2147/ F1C : 44 22 0F                              JMP	INPUT3             ;@@ Jump over concatenate instruction below
 2148/ F1F : 46 C8 02                   INPUT2:    CALL	CONCTS             ;Concatenate character to SYMBOL BUFFER
 2149/ F22 : 36 83                      INPUT3:    MVI	L, 203o               ;Load L with address of INPUT pointer
 2150/ F24 : 46 03 03                              CALL	LOOP               ;Increment INPUT pointer and test for end of line
 2151/ F27 : 48 FF 0E                              JNZ	INPUT1             ;If not end of line, go get next character
 2152/ F2A : 46 44 0F                              CALL	INPUTX             ;If end of buffer, get input for variable in the SYMBOL
 2153/ F2D : 46 2D 08                              CALL	STOSYM             ;BUFFER and store the value in the VARIABLES table
 2154/ F30 : 44 4E 0B                              JMP	NXTLIN             ;Then continue to interpret next statement line
 2155/ F33 : 46 44 0F                   INPUT4:    CALL	INPUTX             ;Get input from user for variable in SYMBOL BUFFER
 2156/ F36 : 46 2D 08                              CALL	STOSYM             ;Store the inputted value in the VARIABLES table
 2157/ F39 : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of INPUT pointer
 2158/ F3B : 36 83                                 MVI	L, 203o               ;Set L to location of INPUT pointer
 2159/ F3D : CF                                    MOV	B,M                    ;Fetch pointer value for last character examined
 2160/ F3E : 36 82                                 MVI	L, 202o               ;Change L to point to SCAN pointer storage location
 2161/ F40 : F9                                    MOV	M,B                    ;Update the SCAN pointer
 2162/ F41 : 44 F5 0E                              JMP	INPUT              ;Continue processing statement line for next variable
 2163/ F44 : 36 50                      INPUTX:    MVI	L, 120o               ;Load L with start of SYMBOL BUFFER (contains cc)
 2164/ F46 : C7                                    MOV	A,M                    ;Fetch the (cc) (length of symbol in the buffer) to ACC
 2165/ F47 : 86                                    ADD	L                    ;Add (cc) to base address to set up
 2166/ F48 : F0                                    MOV	L,A                    ;Pointer to last character in the SYMBOL BUFFER
 2167/ F49 : C7                                    MOV	A,M                    ;Fetch the last character in the SYMBOL BUFFER
 2168/ F4A : 3C A4                                 CPI	244o               ;See if the last chamcter was a $ sign
 2169/ F4C : 48 60 0F                              JNZ	INPUTN             ;If not a $ sign, get variable value as a numerical entry
 2170/ F4F : 36 50                                 MVI	L, 120o               ;If $ sign, reset L to start of the SYMBOL BUFFER
 2171/ F51 : CF                                    MOV	B,M                    ;Fetch the (cc) for the variable in the SYMBOL BUFF
 2172/ F52 : 09                                    DCR	B                    ;Subtract one from (cc) to chop off the $ sign
 2173/ F53 : F9                                    MOV	M,B                    ;Restore the new (cc) for the SYMBOL BUFFER
 2174/ F54 : 46 6F 0F                              CALL	FP0                ;Call subroutine to zero the floating point accumulator
 2175/ F57 : 46 91 03                              CALL	CINPUT             ;Input one character from system input device
 2176/ F5A : 36 54                                 MVI	L, 124o               ;Load L with address of the LSW of the FPACC
 2177/ F5C : F8                                    MOV	M,A                    ;Place the ASCII code for the character inputted there
 2178/ F5D : 44 34 10                              JMP	FPFLT              ;Convert value to floating point format in FPACC
 2179/ F60 : 36 64                      INPUTN:    MVI	L, 144o               ;Load L with address of start of AUX SYMBOL BUFF
 2180/ F62 : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of AUX SYMBOL BUFFER
 2181/ F64 : 06 BF                                 MVI	A, 277o               ;Load accumulator with ASCII code for ? mark
 2182/ F66 : 46 82 03                              CALL	ECHO               ;Call output subroutine to display the ? mark
 2183/ F69 : 46 0C 03                              CALL	STRIN              ;Input string of characters (number) fm input device
 2184/ F6C : 44 24 13                              JMP	DINPUT             ;Convert decimal string into binary floating point nr.
 2185/ F6F : 2E 01                      FP0:       MVI	H,PG01 ;\HB\OLDPG1    ;** Load H with floating point working registers page
 2186/ F71 : 44 A7 06                              JMP	CFALSE             ;Zero the floating point accumulator & exit to caller
 2187/ F74 : 36 64                      FOR:       MVI	L, 144o               ;Load L with address of AUX SYMBOL BUFFER
 2188/ F76 : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of AUX SYMBOL BUFFER
 2189/ F78 : 3E 00                                 MVI	M, 000                ;Initialize buffer by clearing first byte
 2190/ F7A : 36 66                                 MVI	L, 146o               ;Load L with location of second character in buffer
 2191/ F7C : 3E 00                                 MVI	M, 000                ;Clear that location in case of single character variable
 2192/ F7E : 36 85                                 MVI	L, 205o               ;Load L with address of FOR/NEXT STACK pointer
 2193/ F80 : 2E 17                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Load H with page of FOR/NEXT STACK pointer
 2194/ F82 : CF                                    MOV	B,M                    ;Fetch the FOR/NEXT STACK pointer
 2195/ F83 : 08                                    INR	B                    ;Increment it in preparation for pushing operation
 2196/ F84 : F9                                    MOV	M,B                    ;Restore it back to its storage location
 2197/ F85 : 36 F0                                 MVI	L, 360o               ;Load L with address of user pgrn buffer line pointer
 2198/ F87 : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of line pointer
 2199/ F89 : DF                                    MOV	D,M                    ;Fetch page address of pgm buffer line pntr into D
 2200/ F8A : 30                                    INR	L                    ;Advance the memory pointer to pick up low part
 2201/ F8B : E7                                    MOV	E,M                    ;Fetch low address of pgm buffer line pntr into E
 2202/ F8C : C1                                    MOV	A,B                    ;Restore updated FOR/NEXT STACK pointer to ACC
 2203/ F8D : 02                                    RLC                    ;Rotate it left to multiply by two, then rotate it again to
 2204/ F8E : 02                                    RLC                    ;Multiply by four. Add this value to the base address of
 2205/ F8F : 04 5C                                 ADI	134o               ;The FOR/NEXT STACK to point to the new top of
 2206/ F91 : F0                                    MOV	L,A                    ;The FOR/NEXT STACK and set up to point to stack
 2207/ F92 : 2E 17                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Set H for page of the FOR/NEXT STACK
 2208/ F94 : FB                                    MOV	M,D                    ;Store the page portion of the user pgrn buffer line pntr
 2209/ F95 : 30                                    INR	L                    ;In the FORINEXT STACK, advance register 4 then
 2210/ F96 : FC                                    MOV	M,E                    ;Store the low portion of the pgrn line pntr on the stack
 2211/ F97 : 36 D5                                 MVI	L, 325o               ;Change L to point to start of TO string which is stored
 2212/ F99 : 2E 01                                 MVI	H,PG01 ;\HB\OLDPG1    ;** In a text strings storage area on this page
 2213/ F9B : 46 0A 0B                              CALL	INSTR              ;Search the statement line for the occurrence of TO
 2214/ F9E : C4                                    MOV	A,E                    ;Register E wiU be zero if TO not found. Move E to ACC
 2215/ F9F : A0                                    ANA	A                    ;To make a test
 2216/ FA0 : 48 AA 0F                              JNZ	FOR1               ;If TO found then proceed with FOR statement
 2217/ FA3 : 06 C6                      FORERR:    MVI	A, 306o               ;Else have a For Error. Load ACC with ASCII code for
 2218/ FA5 : 16 C5                                 MVI	C, 305o               ;Letter F and register C with code for letter E.
 2219/ FA7 : 44 96 02                              JMP	ERROR              ;Then go display the FE message.
 2220/ FAA : 36 82                      FOR1:      MVI	L, 202o               ;Load L with address of SCAN pointer storage location
 2221/ FAC : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of the SCAN pointer
 2222/ FAE : CF                                    MOV	B,M                    ;Fetch pointer value to ACC (points to letter R in the
 2223/ FAF : 08                                    INR	B                    ;For directive). Increment it to point to next character
 2224/ FB0 : 36 84                                 MVI	L, 204o               ;In the line. Change register L and set this value up
 2225/ FB2 : F9                                    MOV	M,B                    ;As an updated FOR pointer.
 2226/ FB3 : 36 83                                 MVI	L, 203o               ;Set L to address of TO pointer (formerly TOKEN)
 2227/ FB5 : FC                                    MOV	M,E                    ;Save pointer to TO in the TO pointer!
 2228/ FB6 : 36 84                      FOR2:      MVI	L, 204o               ;Load L with address of the FOR pointer
 2229/ FB8 : 46 A0 02                              CALL	GETCHR             ;Fetch a character from the statement line
 2230/ FBB : 68 C8 0F                              JZ	FOR3               ;If it is a space, ignore it
 2231/ FBE : 3C BD                                 CPI	275o               ;Test to see if character is the "=" sign
 2232/ FC0 : 68 D3 0F                              JZ	FOR4               ;If so, variable name is in the AUX SYMBOLBUFFER
 2233/ FC3 : 36 64                                 MVI	L, 144o               ;If not, then set L to point to start of the AUX SYMBOL
 2234/ FC5 : 46 CC 02                              CALL	CONCT1             ;BUFFER and concatenate the character onto the buffer
 2235/ FC8 : 36 84                      FOR3:      MVI	L, 204o               ;Reset L to address of the FOR pointer
 2236/ FCA : 46 03 03                              CALL	LOOP               ;Increment the pointer and see if end of line
 2237/ FCD : 48 B6 0F                              JNZ	FOR2               ;If not end of line, continue looking for the "=" sign
 2238/ FD0 : 44 A3 0F                              JMP	FORERR             ;If reach end of line before "=" sign, then have error
 2239/ FD3 : 36 84                      FOR4:      MVI	L, 204o               ;Set L with address of the FOR pointer
 2240/ FD5 : CF                                    MOV	B,M                    ;Fetch pointer value to ACC (pointing to sign)
 2241/ FD6 : 08                                    INR	B                    ;Increment it to skip over the "=" sign
 2242/ FD7 : 36 BE                                 MVI	L, 276o               ;Set L to address of the EVAL pointer
 2243/ FD9 : F9                                    MOV	M,B                    ;Restore the updated pointer to storage
 2244/ FDA : 36 83                                 MVI	L, 203o               ;Set L to the address of the TO pointer
 2245/ FDC : CF                                    MOV	B,M                    ;Fetch pointer value to ACC (pointing to letter T in TO)
 2246/ FDD : 09                                    DCR	B                    ;Decrement it to point to character before the T in TO
 2247/ FDE : 36 BF                                 MVI	L, 277o               ;Set L to EVAL FINISH pointer storage location
 2248/ FE0 : F9                                    MOV	M,B                    ;Store the EVAL FINISH pointer value
 2249/ FE1 : 46 94 03                              CALL	EVAL               ;Evaluate the expression between the "=" sign and TO
 2250/ FE4 : 46 AA 08                              CALL	RESTSY             ;Directive. Place the variable name in the variables table.
 2251/ FE7 : 36 64                                 MVI	L, 144o               ;Load L with starting address of the AUX SYMBOL BF
 2252/ FE9 : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with the page of the AUX SYMBOL BUFF
 2253/ FEB : C7                                    MOV	A,M                    ;Fetch the (cc) for the name in the buffer
 2254/ FEC : 3C 01                                 CPI	001o               ;See if the symbol (name) length is just one character
 2255/ FEE : 48 A6 19                              JNZ	FOR5               ;If not, go directly to place name in FOR/NEXT STACK
 2256/ FF1 : 36 66                                 MVI	L, 146o               ;If so, set L to point to second character location in the
 2257/ FF3 : 3E 00                                 MVI	M, 000                ;AUX SYMBOL BUFFER and set it equal to zero.
 2258/ FF5 : 44 A6 19                              JMP	FOR5               ;This jump directs program over ontrs/cntrs/table area
 2259/ FF8 :                            ;;; LAST LINE SHOULD START AT 17 365 0ff5h
 2260/ FF8 :                            ;;; PATCH AREA FOLLOWS THIS
 2261/ FF8 :                            
 2262/ FF8 :                            ;	db	(1000h-$) dup 0
 2263/ FF8 :                            
 2264/1000 :                                       ORG	1000h              ;020#000
 2265/1000 :                            
 2266/1000 : 36 56                      FPFIX:     MVI	L, 126o               ;Set L to point to MSW of FPACC
 2267/1002 : 2E 01                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to point to page of FPACC
 2268/1004 : C7                                    MOV	A,M                    ;Fetch MSW of FPACC
 2269/1005 : 36 40                                 MVI	L, 100o               ;Change pointer to SIGN indicator on same page
 2270/1007 : F8                                    MOV	M,A                    ;Place MSW of FPACC into SIGN indicator
 2271/1008 : A0                                    ANA	A                    ;Now test sign bit of MSW of FPACC
 2272/1009 : 72 82 10                              CM	FPCOMP             ;Two's complement value in FPACC if negative
 2273/100C : 36 57                                 MVI	L, 127o               ;Change pointer to FPACC Exponent register
 2274/100E : 06 17                                 MVI	A, 027o               ;Set accumulator to 23 (decimal) for number of bits
 2275/1010 : CF                                    MOV	B,M                    ;Load FPACC Exponent into CPU register B
 2276/1011 : 08                                    INR	B                    ;Exercise the value in register B
 2277/1012 : 09                                    DCR	B                    ;To set CPU flags
 2278/1013 : 70 29 10                              JM	FPZERO             ;If FPACC Exponent is negative set FPACC to zero
 2279/1016 : 91                                    SUB	B                    ;Subtract value of FPACC Exponent from 23 decimal
 2280/1017 : 70 F6 0A                              JM	FIXERR             ;If Exp larger than 23 decimal cannot convert
 2281/101A : D0                                    MOV	C,A                    ;Else place result in register C as counter for number
 2282/101B : 36 56                      FPFIXL:    MVI	L, 126o               ;Of rotate ops. Set pointer to MSW of FPACC
 2283/101D : 0E 03                                 MVI	B, 003                ;Set precision counter (number of bytes in mantissa)
 2284/101F : 46 89 12                              CALL	ROTATR             ;Rotate FPACC right the number of places indicated
 2285/1022 : 11                                    DCR	C                    ;By count in register C to effectively rotate all the
 2286/1023 : 48 1B 10                              JNZ	FPFIXL             ;Significant bits to the left of the floating point decimal
 2287/1026 : 44 7D 10                              JMP	RESIGN             ;Point. Go check original sign & negate answer if req'd.
 2288/1029 :                            
 2289/1029 :                                                              ;Following subroutine clears the FPACC to the zero
 2290/1029 :                                                              ;condition.
 2291/1029 :                            
 2292/1029 : 36 56                      FPZERO:    MVI	L, 126o               ;Set L to point to MSW of FPACC
 2293/102B : A8                                    XRA	A                    ;Clear the accumulator
 2294/102C : F8                                    MOV	M,A                    ;Set the MSW of FPACC to zero
 2295/102D : 31                                    DCR	L                    ;Decrement the pointer
 2296/102E : F8                                    MOV	M,A                    ;Set the next significant word of FPACC to zero
 2297/102F : 31                                    DCR	L                    ;Decrement the pointer
 2298/1030 : F8                                    MOV	M,A                    ;Set the LSW of FPACC to zero
 2299/1031 : 31                                    DCR	L                    ;Decrement the pointer
 2300/1032 : F8                                    MOV	M,A                    ;Set the auxiliary FPACC byte to zero
 2301/1033 : 07                                    RET                    ;Exit to calling routine
 2302/1034 :                            
 2303/1034 :                                                              ;The next instruction is a special entry point to
 2304/1034 :                                                              ;the FPNORM subroutine that is used when a number is
 2305/1034 :                                                              ;converted from fixed to floating point. The FPNORM
 2306/1034 :                                                              ;label is the entry point when a number already in float-
 2307/1034 :                                                              ;ing point fonnat is to be normalized.
 2308/1034 :                            
 2309/1034 : 0E 17                      FPFLT:     MVI	B, 027o               ;For fixed to float set CPU register B to 23 decimal
 2310/1036 : C1                         FPNORM:    MOV	A,B                    ;Get CPU register B into ACC to check for special case
 2311/1037 : 2E 01                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to page of FPACC
 2312/1039 : 36 57                                 MVI	L, 127o               ;Set L to FPACC Exponent byte
 2313/103B : A0                                    ANA	A                    ;Set CPU flags to test what was in CPU register B
 2314/103C : 68 40 10                              JZ	NOEXC0             ;If B was zero then do standard normalization
 2315/103F : F9                                    MOV	M,B                    ;Else set Exponent of FPACC to 23 decimal
 2316/1040 : 31                         NOEXC0:    DCR	L                    ;Change pointer to MSW of FPACC
 2317/1041 : C7                                    MOV	A,M                    ;Fetch MSW of FPACC into accumulator
 2318/1042 : 36 40                                 MVI	L, 100o               ;Change pointer to SIGN indicator storage location
 2319/1044 : F8                                    MOV	M,A                    ;Place the MSW of FPACC there for future reference
 2320/1045 : A0                                    ANA	A                    ;Set CPU flags to test MSW of FPACC
 2321/1046 : 50 50 10                              JP	ACZERT             ;If sign bit not set then jump ahead to do next test
 2322/1049 : 0E 04                                 MVI	B, 004                ;If sign bit set, number in FPACC is negative. Set up
 2323/104B : 36 53                                 MVI	L, 123o               ;For two's complement operation
 2324/104D : 46 68 12                              CALL	COMPLM             ;And negate the value in the FPACC to make it positive
 2325/1050 : 36 56                      ACZERT:    MVI	L, 126o               ;Reset pointer to MSW of FPACC
 2326/1052 : 0E 04                                 MVI	B, 004                ;Set precision counter to number of bytes in FPACC
 2327/1054 : C7                         LOOK0:     MOV	A,M                    ;Plus one. Fetch a byte of the FPACC.
 2328/1055 : A0                                    ANA	A                    ;Set CPU flags
 2329/1056 : 48 63 10                              JNZ	ACNONZ             ;If find anything then FPACC is not zero
 2330/1059 : 31                                    DCR	L                    ;Else decrement pointer to NSW of FPACC
 2331/105A : 09                                    DCR	B                    ;Decrement precision counter
 2332/105B : 48 54 10                              JNZ	LOOK0              ;Continue checking to see if FPACC contains anything
 2333/105E : 36 57                                 MVI	L, 127o               ;Until precision counter is zero. If reach here then
 2334/1060 : A8                                    XRA	A                    ;Reset pointer to FPACC Exponent. Clear the ACC and
 2335/1061 : F8                                    MOV	M,A                    ;Clear out the FPACC Exponent. Value of FPACC is zip!
 2336/1062 : 07                                    RET                    ;Exit to calling routine
 2337/1063 : 36 53                      ACNONZ:    MVI	L, 123o               ;If FPACC has any value set pointer to LSW minus one
 2338/1065 : 0E 04                                 MVI	B, 004                ;Set precision counter to number of bytes in FPACC
 2339/1067 : 46 7F 12                              CALL	ROTATL             ;Plus one for special cases. Rotate the contents of the
 2340/106A : C7                                    MOV	A,M                    ;FPACC to the LEFT. Pointer will be set to MSW after
 2341/106B : A0                                    ANA	A                    ;Rotate ops. Fetch MSW and see if have anything in
 2342/106C : 70 76 10                              JM	ACCSET             ;Most significant bit position. If so, have rotated enough
 2343/106F : 30                                    INR	L                    ;If not, advance pointer to FPACC Exponent. Fetch
 2344/1070 : CF                                    MOV	B,M                    ;The value of the Exponent and decrement it by one
 2345/1071 : 09                                    DCR	B                    ;To compensate for the rotate left of the mantissa
 2346/1072 : F9                                    MOV	M,B                    ;Restore the new value of the Exponent
 2347/1073 : 44 63 10                              JMP	ACNONZ             ;Continue rotating ops to normalize the FPACC
 2348/1076 : 36 56                      ACCSET:    MVI	L, 126o               ;Set pntr to FPACC MSW. Now must provide room for
 2349/1078 : 0E 03                                 MVI	B, 003                ;Sign bit in nonnalized FPACC. Set precision counter.
 2350/107A : 46 89 12                              CALL	ROTATR             ;Rotate the FPACC once to the right now.
 2351/107D : 36 40                      RESIGN:    MVI	L, 100o               ;Set the pointer to SIGN indicator storage location
 2352/107F : C7                                    MOV	A,M                    ;Fetch the original sign of the FPACC
 2353/1080 : A0                                    ANA	A                    ;Set CPU flags
 2354/1081 : 13                                    RP                    ;If original sign of FPACC was positive, can exit now.
 2355/1082 :                            
 2356/1082 : 36 54                      FPCOMP:    MVI	L, 124o               ; However, if original sign was negative, must now restore
 2357/1084 : 0E 03                                 MVI	B, 003                ;The FPACC to negative by performing two's comple-
 2358/1086 : 44 68 12                              JMP	COMPLM             ;Ment on FPACC. Return to caring rtn via COMPLM.
 2359/1089 :                            
 2360/1089 :                                                              ;Floating point ADDITION. Adds contents of FPACC to
 2361/1089 :                                                              ;FPOP and leaves result in FPACC. Routine first checks
 2362/1089 :                                                              ;to see if either register contains zero. If so addition
 2363/1089 :                                                              ;result is already present!
 2364/1089 :                            
 2365/1089 : 36 56                      FPADD:     MVI	L, 126o               ;Set L to point to MSW of FPACC
 2366/108B : 2E 01                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Do same for register H
 2367/108D : C7                                    MOV	A,M                    ;Fetch MSW of FPACC to accumulator
 2368/108E : A0                                    ANA	A                    ;Set CPU flags after loading op
 2369/108F : 48 9D 10                              JNZ	NONZAC             ;If accumulator non-zero then FPACC has some value
 2370/1092 : 36 54                      MOVOP:     MVI	L, 124o               ;But, if accumulator was zero then normalized FPACC
 2371/1094 : DD                                    MOV	D,H                    ;Must also be zero. Thus answer to addition is simply the
 2372/1095 : E6                                    MOV	E,L                    ;Value in FPOP. Set up pointers to transfer contents of
 2373/1096 : 36 5C                                 MVI	L, 134o               ;FPOP to FPACC by pointing to the LSW of both
 2374/1098 : 0E 04                                 MVI	B, 004                ;Registers and perform the transfer. Then exit to calling
 2375/109A : 44 0B 11                              JMP	MOVEIT             ;Routine with answer in FPACC via MOVEIT.
 2376/109D : 36 5E                      NONZAC:    MVI	L, 136o               ;If FPACC was non-zero then check to see if FPOP has
 2377/109F : C7                                    MOV	A,M                    ;Some value by obtaining MSW of FPOP
 2378/10A0 : A0                                    ANA	A                    ;Set CPU flags after loading op. If MSW zero then
 2379/10A1 : 2B                                    RZ                    ;Normalized FPOP must be zero. Answer is in FPACC!
 2380/10A2 :                            
 2381/10A2 :                                                              ;If neither FPACC or FPOP was zero then must perform
 2382/10A2 :                                                              ;addition operation. Must first check to see if two num-
 2383/10A2 :                                                              ;bers are within significant mnge. If not, largest number
 2384/10A2 :                                                              ;is answer. If numbers within range, then must align ex-
 2385/10A2 :                                                              ;ponents before perforrning the addition of the man-
 2386/10A2 :                                                              ;tissa.
 2387/10A2 :                            
 2388/10A2 : 36 57                      CKEQEX:    MVI	L, 127o               ;Set pointer to FPACC Exponent storage location.
 2389/10A4 : C7                                    MOV	A,M                    ;Fetch the Exponent value to the accumulator.
 2390/10A5 : 36 5F                                 MVI	L, 137o               ;Change the pointer to the FPOP Exponent
 2391/10A7 : BF                                    CMP	M                    ;Compare the values of the exponents. If they are the
 2392/10A8 : 68 E1 10                              JZ	SHACOP             ;Same then can immediately proceed to add operations.
 2393/10AB : C8                                    MOV	B,A                    ;If not the same, store FPACC Exponent size in regis B
 2394/10AC : C7                                    MOV	A,M                    ;Fetch the FPOP Exponent size into the ACC
 2395/10AD : 99                                    SBB	B                    ;Subtract the FPACC Exponent from the FPOP Exp.
 2396/10AE : 50 B4 10                              JP	SKPNEG             ;If result is positive jump over the next few instructions
 2397/10B1 : C8                                    MOV	B,A                    ;If result was negative, store the result in B
 2398/10B2 : A8                                    XRA	A                    ;Clear the accumulator
 2399/10B3 : 99                                    SBB	B                    ;Subtract register B to negate the original value
 2400/10B4 : 3C 18                      SKPNEG:    CPI	030o               ;See if difference is less than 24 decimal.
 2401/10B6 : 70 C3 10                              JM	LINEUP             ;If so, can align exponents. Go do it.
 2402/10B9 : C7                                    MOV	A,M                    ;If not, find out which number is largest. Fetch FPOP
 2403/10BA : 36 57                                 MVI	L, 127o               ;Exponent into ACC. Change pointer to FPACC Exp.
 2404/10BC : 97                                    SUB	M                    ;Subtract FPACC from FPOP. If result is negative then
 2405/10BD : 33                                    RM                    ;was larger. Return with answer in FPACC.
 2406/10BE : 36 54                                 MVI	L, 124o               ;If result was positive, larger value in FPOP. Set pointers
 2407/10C0 : 44 92 10                              JMP	MOVOP              ;To transfer FPOP into FPACC and then exit to caller.
 2408/10C3 : C7                         LINEUP:    MOV	A,M                    ;Fetch FPOP Exponent into accumulator.
 2409/10C4 : 36 57                                 MVI	L, 127o               ;Change pointer to FPACC Exponent.
 2410/10C6 : 97                                    SUB	M                    ;Subtract FPACC Exponent from FPOP Exponent. If
 2411/10C7 : 70 D7 10                              JM	SHIFT0             ;Result is negative FPACC is larger. Go shift FPOP.
 2412/10CA : D0                                    MOV	C,A                    ;If result positive FPOP larger, must shift FPACC. Store
 2413/10CB : 36 57                      MORACC:    MVI	L, 127o               ;Difference count in C. Reset pointer to FPACC Exp
 2414/10CD : 46 FC 10                              CALL	SHLOOP             ;Call the SHift LOOP to rotate FPACC mantissa RIGHT
 2415/10D0 : 11                                    DCR	C                    ;And INCREMENT Exponent. Decr difference counter
 2416/10D1 : 48 CB 10                              JNZ	MORACC             ;Continue rotate operations until diff counter is zero
 2417/10D4 : 44 E1 10                              JMP	SHACOP             ;Go do final alignment and perform addition process
 2418/10D7 : D0                         SHIFT0:    MOV	C,A                    ;Routine to shift FPOP. Set difference count into reg. C
 2419/10D8 : 36 5F                      MOROP:     MVI	L, 137o               ;Set pointer to FPOP Exponent.
 2420/10DA : 46 FC 10                              CALL	SHLOOP             ;Call the SHift LOOP to rotate FPOP mantissa RIGHT
 2421/10DD : 10                                    INR	C                    ;And INCREMENT Exponent. Then incr difference cntr
 2422/10DE : 48 D8 10                              JNZ	MOROP              ;Continue rotate opemtions until diff counter is zero
 2423/10E1 :                            ;;; The below two instructions are changed by PATCH NR.1
 2424/10E1 :                            ;;;SHACOP:    LLI 123                ;Set pointer to FPACC LSW minus one to provide extra
 2425/10E1 :                            ;;;           LMI 000                ;Byte for addition ops. Clear that location to zero.
 2426/10E1 : 46 00 18                   SHACOP:	   CALL	PATCH1		; patch 1 inserts a few lines at 30-000
 2427/10E4 : C0                         	   MOV	A,A
 2428/10E5 :                            	
 2429/10E5 :                            ;;;           MVI L, 133
 2430/10E5 :                            ;;;           LMI 000                ;THIS IS PATCH #1
 2431/10E5 : 36 57                                 MVI	L, 127o               ;Change pointer to FPACC Exponent
 2432/10E7 : 46 FC 10                              CALL	SHLOOP             ;Rotate FPACC mantissa RIGHT & Increment Exponent
 2433/10EA : 36 5F                                 MVI	L, 137o               ;Change pointer to FPOP Exponent
 2434/10EC : 46 FC 10                              CALL	SHLOOP             ;Rotate FPOP mantissa RIGHT & Increment Exponent
 2435/10EF : DD                                    MOV	D,H                    ;Rotate ops provide room for overflow. Now set up
 2436/10F0 : 26 53                                 MVI	E, 123o               ;Pointers to LSW minus one for both FPACC & FPOP
 2437/10F2 : 0E 04                                 MVI	B, 004                ;(FPOP already set after SHLOOP). Set precision counter
 2438/10F4 : 46 57 12                              CALL	ADDER              ;Call quad precision ADDITION subroutine.
 2439/10F7 : 0E 00                                 MVI	B, 000                ;Set CPU register B to indicate standard normalization
 2440/10F9 : 44 36 10                              JMP	FPNORM             ;Go normalize the result and exit to caller.
 2441/10FC : CF                         SHLOOP:    MOV	B,M                    ;Shifting loop. First fetch Exponent currently being
 2442/10FD : 08                                    INR	B                    ;Pointed to and Increment the value by one.
 2443/10FE : F9                                    MOV	M,B                    ;Return the updated Exponent value to memory.
 2444/10FF : 31                                    DCR	L                    ;Decrement the pointer to mantissa portion MSW
 2445/1100 : 0E 04                                 MVI	B, 004                ;Set precision counter
 2446/1102 : C7                         FSHIFT:    MOV	A,M                    ;Fetch MSW of mantissa
 2447/1103 : A0                                    ANA	A                    ;Set CPU flags after load ops
 2448/1104 : 50 89 12                              JP	ROTATR             ;If MSB not a one can do normal rotate ops
 2449/1107 : 12                         BRING1:    RAL                    ;If MSB is a one need to set up carrv bit for the negative
 2450/1108 : 44 8A 12                              JMP	ROTR               ;Number case. Then make special entry to ROTATR sub
 2451/110B :                            
 2452/110B :                                                              ;The following subroutine moves the contents of a string
 2453/110B :                                                              ;of memory locations from the address pointed to by
 2454/110B :                                                              ;CPU registers H & L to the address specified by the con-
 2455/110B :                                                              ;tents of registers D & E when the routine is entered. The
 2456/110B :                                                              ;process continues until the counter in register B is zero.
 2457/110B :                            
 2458/110B : C7                         MOVEIT:    MOV	A,M                    ;Fetch a word from memory string A
 2459/110C : 30                                    INR	L                    ;Advance A string pointer
 2460/110D : 46 EE 12                              CALL	SWITCH             ;Switch pointer to string B
 2461/1110 : F8                                    MOV	M,A                    ;Put word from string A into string B
 2462/1111 : 30                                    INR	L                   ;Advance B string pointer
 2463/1112 : 46 EE 12                              CALL	SWITCH             ;Switch pointer back to string A
 2464/1115 : 09                                    DCR	B                    ;Decrement loop counter
 2465/1116 : 2B                                    RZ                    ;Return to calling routine when counter reaches zero
 2466/1117 : 44 0B 11                              JMP	MOVEIT             ;Else continue transfer operations
 2467/111A :                            
 2468/111A :                                                              ;The following subroutine SUBTRACTS the
 2469/111A :                                                              ;contents of the FLOATING POINT ACCUMULATOR from the
 2470/111A :                                                              ;contents of the FLOATING POINT OPERAND and
 2471/111A :                                                              ;leaves the result in the FPACC. The routine merely
 2472/111A :                                                              ;negates the value in the FPACC and then goes to the
 2473/111A :                                                              ;FPADD subroutine just presented.
 2474/111A :                            
 2475/111A : 36 54                      FPSUB:     MVI	L, 124o               ;Set L to address of LSW of FPACC
 2476/111C : 2E 01                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to page of FPACC
 2477/111E : 0E 03                                 MVI	B, 003                ;Set precision counter
 2478/1120 : 46 68 12                              CALL	COMPLM             ;Two's complement the value in the FPACC
 2479/1123 : 44 89 10                              JMP	FPADD              ;Now go add the negated value to perform subtraction!
 2480/1126 :                            
 2481/1126 :                                                              ;The first part of the FLOATING POINT MULTIPLI-
 2482/1126 :                                                              ;CATION subroutine calls a subroutine to check the
 2483/1126 :                                                              ;original signs of the numbers that are to be multi-
 2484/1126 :                                                              ;plied and perform working register clearing functions.
 2485/1126 :                                                              ;Next the exponents of the numbers to be multiplied
 2486/1126 :                                                              ;are added together.
 2487/1126 :                            
 2488/1126 : 46 76 11                   FPMULT:    CALL	CKSIGN             ;Call routine to set up registers & ck signs of numbers
 2489/1129 : 36 5F                      ADDEXP:    MVI	L, 137o               ;Set pointer to FPOP Exponent
 2490/112B : C7                                    MOV	A,M                    ;Fetch FPOP Exponent into the accumulator
 2491/112C : 36 57                                 MVI	L, 127o               ;Change pointer to FPACC Exponent
 2492/112E : 87                                    ADD	M                    ;Add FPACC Exponent to FPOP Exponent
 2493/112F : 04 01                                 ADI	001                ;Add one more to total for algorithm compensation
 2494/1131 : F8                                    MOV	M,A                    ;Store result in FPACC Exponent location
 2495/1132 : 36 42                      SETMCT:    MVI	L, 102o               ;Change pointer to bit counter storage location
 2496/1134 : 3E 17                                 MVI	M, 027o               ;Initialize bit counter to 23 decimal
 2497/1136 :                            
 2498/1136 :                                                              ;Next portion of the FPMULT routine is the iinplernen-
 2499/1136 :                                                              ;tation of the algorithm illustrated in the flow chart
 2500/1136 :                                                              ;above. This portion multiplies the values of the two
 2501/1136 :                                                              ;mantissas. The final value is rounded off to leave the
 2502/1136 :                                                              ;23 most significant bits as the answer that is stored
 2503/1136 :                                                              ;back in the FPACC.
 2504/1136 :                            
 2505/1136 : 36 56                      MULTIP:    MVI	L, 126o                ;Set pointer to MSW of FPACC mantissa
 2506/1138 : 0E 03                                 MVI	B, 003                ;Set precision counter
 2507/113A : 46 89 12                              CALL	ROTATR             ;Rotate FPACC (multiplier) RIGHT into carry bit
 2508/113D : 62 B8 11                              CC	ADOPPP             ;If carry is a one, add multiplicand to partial-product
 2509/1140 : 36 66                                 MVI	L, 146o                ;Set pointer to partial-product most significant byte
 2510/1142 : 0E 06                                 MVI	B, 006                ;Set precision counter (p-p register is double length)
 2511/1144 : 46 89 12                              CALL	ROTATR             ;Shift partial-product RIGHT
 2512/1147 : 36 42                                 MVI	L, 102o                ;Set pointer to bit counter storage location
 2513/1149 : D7                                    MOV	C,M                    ;Fetch current value of bit counter
 2514/114A : 11                                    DCR	C                    ;Decrement the value of the bit counter
 2515/114B : FA                                    MOV	M,C                    ;Restore the updated bit counter to its storage location
 2516/114C : 48 36 11                              JNZ	MULTIP             ;If have not multiplied for 23 (deciinal) bits, keep going
 2517/114F : 36 66                                 MVI	L, 146o                ;If have done 23 (decimal) bits, set pntr to p-p MSW
 2518/1151 : 0E 06                                 MVI	B, 006                ;Set precision counter (for double length)
 2519/1153 : 46 89 12                              CALL	ROTATR             ;Shift partial-product once more to the RIGHT
 2520/1156 : 36 63                                 MVI	L, 143o                ;Set pointer to access 24'th bit in partial-product
 2521/1158 : C7                                    MOV	A,M                    ;Fetch the byte containing the 24'th bit
 2522/1159 : 12                                    RAL                    ;Position the 24'th bit to be MSB in the accumulator
 2523/115A : A0                                    ANA	A                    ;Set the CPU flags after to rotate operation and test to
 2524/115B : 72 C2 11                              CM	MROUND             ;See if 24'th bit of p-p is a ONE. If so, must round-off
 2525/115E : 36 53                                 MVI	L, 123o                ;Now set up pointers
 2526/1160 : E6                                    MOV	E,L                    ;To perform transfer
 2527/1161 : DD                                    MOV	D,H                    ;Of the multiplication results
 2528/1162 : 36 63                                 MVI	L, 143o                ;From the partial-product location
 2529/1164 : 0E 04                                 MVI	B, 004                ;To the FPACC
 2530/1166 :                            
 2531/1166 :                            	
 2532/1166 : 46 0B 11                   EXMLDV:    CALL	MOVEIT             ;Perform the transfer from p-p to FPACC
 2533/1169 : 0E 00                                 MVI	B, 000                ;Set up CPU register B to indicate regular normalization
 2534/116B : 46 36 10                              CALL	FPNORM             ;Normalize the result of multiplication
 2535/116E : 36 41                                 MVI	L, 101o               ;Now set the pointer to the original SIGNS indicator
 2536/1170 : C7                                    MOV	A,M                    ;Fetch the indicator
 2537/1171 : A0                                    ANA	A                    ;Exercise the CPU flags
 2538/1172 : 0B                                    RNZ                    ;If indicator is non-zero, answer is positive, can exit her
 2539/1173 : 44 82 10                              JMP	FPCOMP             ;If not, answer must be negated, exit via 2's complement.
 2540/1176 :                            
 2541/1176 :                                                              ;The following portions of the FPMULT
 2542/1176 :                                                              ;routine set up working locations in memory by clearing
 2543/1176 :                                                              ;locations for an expanded FPOP area and the partial-produc
 2544/1176 :                                                              ;area. Next, the signs of the two numbers to be multiplied
 2545/1176 :                                                              ;are examined. Negative numbers are negated
 2546/1176 :                                                              ;in preparation for the multiplication
 2547/1176 :                                                              ;algorithm. A SIGNS indicator register is set up during
 2548/1176 :                                                              ;this process to indicate whether the final result of the
 2549/1176 :                                                              ;multiplication should be positive or negative. (Negative
 2550/1176 :                                                              ;if original signs of the two numbers to be multiplied are
 2551/1176 :                                                              ;different.)
 2552/1176 :                            
 2553/1176 : 36 60                      CKSIGN:    MVI	L, 140o               ;Set pointer to start of partial-product working area
 2554/1178 : 2E 01                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to proper page
 2555/117A : 0E 08                                 MVI	B, 010o               ;Set up a loop counter in CPU register B
 2556/117C : A8                                    XRA	A                    ;Clear the accumulator
 2557/117D :                            
 2558/117D : F8                         CLRNEX:    MOV	M,A                    ;Now clear out locations for the partial-product
 2559/117E : 30                                    INR	L                    ;Working registers
 2560/117F : 09                                    DCR	B                    ;Until the loop counter
 2561/1180 : 48 7D 11                              JNZ	CLRNEX             ;Is zero
 2562/1183 : 0E 04                      CLROPL:    MVI	B, 004                ;Set a loop counter
 2563/1185 : 36 58                                 MVI	L, 130o               ;Set up pointer
 2564/1187 : F8                         CLRNX1:    MOV	M,A                    ;Clear out some extra registers so that the
 2565/1188 : 30                                    INR	L                    ;FPOP may be extended in length
 2566/1189 : 09                                    DCR	B                    ;Perform clearing ops until loop counter
 2567/118A : 48 87 11                              JNZ	CLRNX1             ;Is zero
 2568/118D : 36 41                                 MVI	L, 101o               ;Set pointer to M/D SIGNS indicator storage location
 2569/118F : 3E 01                                 MVI	M, 001                ;Set initial value of SIGNS indicator to plus one
 2570/1191 : 36 56                                 MVI	L, 126o               ;Change pointer to MSW of FPACC
 2571/1193 : C7                                    MOV	A,M                    ;Fetch MSW of mantissa into accumulator
 2572/1194 : A0                                    ANA	A                    ;Test flags
 2573/1195 : 70 A9 11                              JM	NEGFPA             ;If MSB in MSW of FPACC is a one, number is negative
 2574/1198 : 36 5E                      OPSGNT:    MVI	L, 136o               ;Set pointer to MSW of FPOP
 2575/119A : C7                                    MOV	A,M                    ;Fetch MSW of mantissa into accumulator
 2576/119B : A0                                    ANA	A                    ;Test flags
 2577/119C : 13                                    RP                    ;Return to caller if number in FPOP is positive
 2578/119D : 36 41                                 MVI	L, 101o               ;Else change pointer to M/D SIGNS indicator
 2579/119F : D7                                    MOV	C,M                    ;Fetch the value in the SIGNS indicator
 2580/11A0 : 11                                    DCR	C                    ;Decrement the value by one
 2581/11A1 : FA                                    MOV	M,C                    ;Restore the new value back to storage location
 2582/11A2 : 36 5C                                 MVI	L, 134o               ;Set pointer to LSW of FPOP
 2583/11A4 : 0E 03                                 MVI	B, 003                ;Set precision counter
 2584/11A6 : 44 68 12                              JMP	COMPLM             ;Two's complement value of FPOP & return to caller
 2585/11A9 : 36 41                      NEGFPA:    MVI	L, 101o               ;Set pointer to M/D SIGNS indicator
 2586/11AB : D7                                    MOV	C,M                    ;Fetch the value in the SIGNS indicator
 2587/11AC : 11                                    DCR	C                    ;Decrement the value by one
 2588/11AD : FA                                    MOV	M,C                    ;Restore the new value back to storage location
 2589/11AE : 36 54                                 MVI	L, 124o               ;Set pointer to LSW of FPACC
 2590/11B0 : 0E 03                                 MVI	B, 003                ;Set precision counter
 2591/11B2 : 46 68 12                              CALL	COMPLM             ;Two's complement value of FPACC
 2592/11B5 : 44 98 11                              JMP	OPSGNT             ;Proceed to check sign of FPOP
 2593/11B8 :                            
 2594/11B8 :                                                              ;The following subroutine adds the double length (six regis
 2595/11B8 :                                                              ;multiplicand in FPOP to the partial-product register when
 2596/11B8 :                                                              ;called on by the multiplication algorithm.
 2597/11B8 :                            
 2598/11B8 : 26 61                      ADOPPP:    MVI	E, 141o               ;Pointer to LSW of partial-product
 2599/11BA : DD                                    MOV	D,H                    ;On same page as FPOP
 2600/11BB : 36 59                                 MVI	L, 131o               ;LSIV of FPOP which contains extended multiplicand
 2601/11BD : 0E 06                                 MVI	B, 006                ;Set precision counter (double length working registers)
 2602/11BF : 44 57 12                              JMP	ADDER              ;Add multiplicand to partial-product & return to caller
 2603/11C2 :                            
 2604/11C2 : 0E 03                      MROUND:    MVI	B, 003                ;Set up precision counter
 2605/11C4 : 06 40                                 MVI	A, 100o               ;Prepare to add one to 24'th bit of partial-product
 2606/11C6 : 87                                    ADD	M                    ;Add one to the 24'th bit of the partial-product
 2607/11C7 : F8                         CROUND:    MOV	M,A                    ;Restore the updated byte to memory
 2608/11C8 : 30                                    INR	L                    ;Advance the memory pointer to next most significant
 2609/11C9 : 06 00                                 MVI	A, 000                ;Byte of partial-product, then clear ACC without
 2610/11CB : 8F                                    ADC	M                    ;Disturbing carry bit. Now perform add with carry to
 2611/11CC : 09                                    DCR	B                    ;Propagate any rounding in the partial-product registers.
 2612/11CD : 48 C7 11                              JNZ	CROUND             ;If cotinter is not zero continue propagating any carry
 2613/11D0 : F8                                    MOV	M,A                    ;Restore final byte to memory
 2614/11D1 : 07                                    RET                    ;Exit to CALLling routine
 2615/11D2 :                            
 2616/11D2 : 46 76 11                   FPDIV:     CALL	CKSIGN             ;Call routine to set up registers & ck signs of numbers
 2617/11D5 : 36 56                                 MVI	L, 126o               ;Set pointer to MSW of FPACC (divisor)
 2618/11D7 : C7                                    MOV	A,M                    ;Fetch MSW of FPACC to accumulator
 2619/11D8 : A0                                    ANA	A                    ;Exercise CPU flags
 2620/11D9 : 68 EF 0A                              JZ	DVERR              ;If MSW of FPACC is zero go display 'DZ' error message
 2621/11DC : 36 5F                      SUBEXP:    MVI	L, 137o               ;Set pointer to FPOP (dividend) Exponent
 2622/11DE : C7                                    MOV	A,M                    ;Get FPOP Exponent into accumulator
 2623/11DF : 36 57                                 MVI	L, 127o               ;Change pointer to FPACC (divisor) Exponent
 2624/11E1 : 97                                    SUB	M                    ;Subtract divisor exponent from dividend exponent
 2625/11E2 : 04 01                                 ADI	001                ;Add one for algorithm compensation
 2626/11E4 : F8                                    MOV	M,A                    ;Place result in FPACC Exponent
 2627/11E5 : 36 42                      SETDCT:    MVI	L, 102o               ;Set pointer to bit counter storage location
 2628/11E7 : 3E 17                                 MVI	M, 027o               ;Initialize bit counter to 23 decimal
 2629/11E9 :                            
 2630/11E9 :                                                              ;Main division algorithm for mantissas
 2631/11E9 :                            
 2632/11E9 : 46 41 12                   DIVIDE:    CALL	SETSUB             ;Go subtmct divisor from dividend
 2633/11EC : 70 FE 11                              JM	NOGO               ;If result is negative then place a zero bit in quotient
 2634/11EF : 26 5C                                 MVI	E, 134o               ;If result zero or positive then move remainder after
 2635/11F1 : 36 59                                 MVI	L, 131o               ;Subtraction from working area to become new dividend
 2636/11F3 : 0E 03                                 MVI	B, 003                ;Set up moving pointers and initialize precision counter
 2637/11F5 : 46 0B 11                              CALL	MOVEIT             ;Perform the transfer
 2638/11F8 : 06 01                                 MVI	A, 001                ;Place a one into least significant bit of accumulator
 2639/11FA : 1A                                    RAR                    ;And rotate it out into the carry bit
 2640/11FB : 44 FF 11                              JMP	QUOROT             ;Proceed to rotate the carry bit into the current quotient
 2641/11FE : A8                         NOGO:      XRA	A                    ;When result is negative, put a zero in the carry bit, then
 2642/11FF : 36 64                      QUOROT:    MVI	L, 144o               ;Set up pointer to LSW of quotient register
 2643/1201 : 0E 03                                 MVI	B, 003                ;Set precision counter
 2644/1203 : 46 80 12                              CALL	ROTL               ;Rotate carry bit into quotient by using special entry to
 2645/1206 : 36 5C                                 MVI	L, 134o               ;ROTATL subroutine. Now set up pointer to dividend
 2646/1208 : 0E 03                                 MVI	B, 003                ;LSW and set precision counter
 2647/120A : 46 7F 12                              CALL	ROTATL             ;Rotate the current dividend to the left
 2648/120D : 36 42                                 MVI	L, 102o               ;Set pointer to bit counter storage location
 2649/120F : D7                                    MOV	C,M                    ;Fetch the value of the bit counter
 2650/1210 : 11                                    DCR	C                    ;Decrement the value by one
 2651/1211 : FA                                    MOV	M,C                    ;Restore the new counter value to storage
 2652/1212 : 48 E9 11                              JNZ	DIVIDE             ;If bit counter is not zero, continue division process
 2653/1215 : 46 41 12                              CALL	SETSUB             ;After 23 (decimal) bits, do subtraction once more for
 2654/1218 : 70 38 12                              JM	DVEXIT             ;Possible rounding. Jump ahead if no rounding required.
 2655/121B : 36 64                                 MVI	L, 144o               ;If rounding required set pointer to LSW of quotient
 2656/121D : C7                                    MOV	A,M                    ;Fetch LSW of quotient to accumulator
 2657/121E : 04 01                                 ADI	001                ;Add one to 23rd bit of quotient
 2658/1220 : F8                                    MOV	M,A                    ;Restore updated LSW of quotient
 2659/1221 : 06 00                                 MVI	A, 000                ;Clear accumulator without disturbing carry bit
 2660/1223 : 30                                    INR	L                    ;Advance pointer to next significant byte of quotient
 2661/1224 : 8F                                    ADC	M                    ;Propagate any carry as part of rounding process
 2662/1225 : F8                                    MOV	M,A                    ;Restore the updated byte of quotient
 2663/1226 : 06 00                                 MVI	A, 000                ;Clear ACC again without disturbing carry bit
 2664/1228 : 30                                    INR	L                    ;Advance pointer to MSW of quotient
 2665/1229 : 8F                                    ADC	M                    ;Propagate any carry to finish rounding process
 2666/122A : F8                                    MOV	M,A                    ;Restore the updated byte of quotient
 2667/122B : 50 38 12                              JP	DVEXIT             ;If most significant bit of quotient is zero, go finish up
 2668/122E : 0E 03                                 MVI	B, 003                ;If not, set precision counter
 2669/1230 : 46 89 12                              CALL	ROTATR             ;And rotate quotient to the right to clear the sign bit
 2670/1233 : 36 57                                 MVI	L, 127o               ;Set pointer to FPACC Exponent
 2671/1235 : CF                                    MOV	B,M                    ;Fetch FPACC exponent
 2672/1236 : 08                                    INR	B                    ;Increment the value to compensate for the rotate right
 2673/1237 : F9                                    MOV	M,B                    ;Restore the updated exponent value
 2674/1238 : 36 63                      DVEXIT:    MVI	L, 143o               ;Set up pointers
 2675/123A : 26 53                                 MVI	E, 123o               ;To transfer the quotient into the FPACC
 2676/123C : 0E 04                                 MVI	B, 004                ;Set precision counter
 2677/123E :                                                              ;THIS IS A CORRECTION FOUND IN THE NOTES
 2678/123E : 44 66 11                              JMP	EXMLDV             ;And exit through FPMULT routine at EXMLDV
 2679/1241 :                            
 2680/1241 :                                                              ;Subroutine to subtract divisor from dividend. Used by
 2681/1241 :                                                              ;main DIVIDE subroutine.
 2682/1241 :                            
 2683/1241 : 26 59                      SETSUB:    MVI	E, 131o               ;Set pointer to LSW of working area
 2684/1243 : DD                                    MOV	D,H                    ;On same page as FPACC
 2685/1244 : 36 54                                 MVI	L, 124o               ;Set pointer to LSW of FPACC (divisor)
 2686/1246 : 0E 03                                 MVI	B, 003                ;Set precision counter
 2687/1248 : 46 0B 11                              CALL	MOVEIT             ;Perform transfer
 2688/124B : 26 59                                 MVI	E, 131o               ;Reset pointer to LSW of working area (now divisor)
 2689/124D : 36 5C                                 MVI	L, 134o               ;Reset pointer to LSW of FPOP (dividend)
 2690/124F : 0E 03                                 MVI	B, 003                ;Set precision counter
 2691/1251 : 46 93 12                              CALL	SUBBER             ;Subtract divisor from dividend
 2692/1254 : C7                                    MOV	A,M                    ;Get MSW of the result of the subtraction operations
 2693/1255 : A0                                    ANA	A                    ;Exercise CPU flags
 2694/1256 : 07                                    RET                    ;Return to caller with status
 2695/1257 : A0                         ADDER:     ANA	A                    ;Initialize the carry bit to zero upon entry
 2696/1258 : C7                         ADDMOR:    MOV	A,M                    ;Fetch byte from register group A
 2697/1259 : 46 EE 12                              CALL	SWITCH             ;Switch memory pointer to register group B
 2698/125C : 8F                                    ADC	M                    ;Add byte from A to byte from B with carry
 2699/125D : F8                                    MOV	M,A                    ;Leave result in register group B
 2700/125E : 09                                    DCR	B                    ;Decrement number of bytes (precision) counter
 2701/125F : 2B                                    RZ                    ;Return to caller when all bytes in group processed
 2702/1260 : 30                                    INR	L                    ;Else advance pointer for register group B
 2703/1261 : 46 EE 12                              CALL	SWITCH             ;Switch memory pointer back to register group A
 2704/1264 : 30                                    INR	L                    ;Advance the pointer for register group A
 2705/1265 : 44 58 12                              JMP	ADDMOR             ;Continue the multi-byte addition operation
 2706/1268 :                            
 2707/1268 :                                                              ;N'th precision two's complement (negate)
 2708/1268 :                                                              ;subroutine. Performs a two's complement on the multi-byte
 2709/1268 :                                                              ;registers tarting at the address pointed
 2710/1268 :                                                              ; to by H & L (least significant byte) upon entry.
 2711/1268 :                            
 2712/1268 : C7                         COMPLM:    MOV	A,M                    ;Fetch the least significant byte of the number to ACC
 2713/1269 : 2C FF                                 XRI	377o               ;Exclusive OR to complement the byte
 2714/126B : 04 01                                 ADI	001                ;Add one to form two's complement of byte
 2715/126D : F8                         MORCOM:    MOV	M,A                    ;Restore the negated byte to memory
 2716/126E : 1A                                    RAR                   ;Save the carry bit
 2717/126F : D8                                    MOV	D,A                    ;In CPU register D
 2718/1270 : 09                                    DCR	B                    ;Decrement number of bytes (precision) counter
 2719/1271 : 2B                                    RZ                    ;Return to caller when all bytes in number processed
 2720/1272 : 30                                    INR	L                    ;Else advance the pointer
 2721/1273 : C7                                    MOV	A,M                    ;Fetch the next byte of the number to ACC
 2722/1274 : 2C FF                                 XRI	377o               ;Exclusive OR to complement the byte
 2723/1276 : E0                                    MOV	E,A                    ;Save complemented value in register E temporarily
 2724/1277 : C3                                    MOV	A,D                    ;Restore previous carry status to ACC
 2725/1278 : 12                                    RAL                    ;And rotate it out to the carry bit
 2726/1279 : 06 00                                 MVI	A, 000                ;Clear ACC without disturbing carry status
 2727/127B : 8C                                    ADC	E                    ;Add in any carry to complemented value
 2728/127C : 44 6D 12                              JMP	MORCOM             ;Continue the two's complement procedure as req'd
 2729/127F :                            
 2730/127F :                                                              ;N'th precision rotate left subroutine. Rotates a multi-
 2731/127F :                                                              ;byte number left starting at the address initially
 2732/127F :                                                              ;specified by the contents of CPU registers H & L upon
 2733/127F :                                                              ;subroutine entry (LSW). First entry point will clear
 2734/127F :                                                              ;the carry bit before beginning rotate operations. Second
 2735/127F :                                                              ;entry point does not clear the carry bit.
 2736/127F :                            
 2737/127F : A0                         ROTATL:    ANA	A                    ;Clear the carry bit at this entry point
 2738/1280 : C7                         ROTL:      MOV	A,M                    ;Fetch a byte from memory
 2739/1281 : 12                                    RAL                    ;Rotate it left (bring carry into LSB, push MSB to carry)
 2740/1282 : F8                                    MOV	M,A                    ;Restore rotated word to memory
 2741/1283 : 09                                    DCR	B                    ;Decrement precision counter
 2742/1284 : 2B                                    RZ                    ;Exit to caller when finished
 2743/1285 : 30                                    INR	L                    ;Else advance pointer to next byte
 2744/1286 : 44 80 12                              JMP	ROTL               ;Continue rotate left operations
 2745/1289 :                            
 2746/1289 :                            
 2747/1289 :                                                              ;N'th precision rotate
 2748/1289 :                                                              ;right subroutine. Opposite of
 2749/1289 :                                                              ;above subroutine.
 2750/1289 :                            
 2751/1289 : A0                         ROTATR:    ANA	A                    ;Clear the carry bit at this entry point
 2752/128A : C7                         ROTR:      MOV	A,M                    ;Fetch a byte from memory
 2753/128B : 1A                                    RAR                    ;Rotate it right (carry into MSB, LSB to carry)
 2754/128C : F8                                    MOV	M,A                    ;Restore rotated word to memory
 2755/128D : 09                                    DCR	B                    ;Decrement precision counter
 2756/128E : 2B                                    RZ                    ;Exit to caller when finished
 2757/128F : 31                                    DCR	L                    ;Else decrement pointer to next byte
 2758/1290 : 44 8A 12                              JMP	ROTR               ;Continue rotate right operations
 2759/1293 :                            
 2760/1293 :                                                              ;N'th precision subtraction subroutine.
 2761/1293 :                                                              ;Number starting at location pointed to by D & E (least
 2762/1293 :                                                              ;significant byte) is subtracted from number starting at
 2763/1293 :                                                              ;address specified by contents of H & L.
 2764/1293 :                            
 2765/1293 : A0                         SUBBER:    ANA	A                    ;Initialize the carry bit to zero upon entry
 2766/1294 : C7                         SUBTRA:    MOV	A,M                    ;Fetch byte from register group A
 2767/1295 : 46 EE 12                              CALL	SWITCH             ;Switch memory pointer to register group B
 2768/1298 : 9F                                    SBB	M                    ;Subtract byte from group B ftom that in group A
 2769/1299 : F8                                    MOV	M,A                    ;Leave result in register group B
 2770/129A : 09                                    DCR	B                    ;Decrement number of bytes (precision) counter
 2771/129B : 2B                                    RZ                    ;Return to caller when all bytes in group processed
 2772/129C : 30                                    INR	L                    ;Else advance pointer for register group B
 2773/129D : 46 EE 12                              CALL	SWITCH             ;Switch memory pointer back to register group A
 2774/12A0 : 30                                    INR	L                    ;Advance the pointer for register group A
 2775/12A1 : 44 94 12                              JMP	SUBTRA             ;Continue the multi-byte subtraction operation
 2776/12A4 :                            
 2777/12A4 :                                                              ;The next subroutine will transfer the four byte
 2778/12A4 :                                                              ;register string (generally a number in floating point
 2779/12A4 :                                                              ;format) from the starting address pointed to by CPU
 2780/12A4 :                                                              ;registers H & L when the subroutine is entered to
 2781/12A4 :                                                              ;the FPACC (floating point accumulator registers).
 2782/12A4 :                            
 2783/12A4 : 1E 01                      FLOAD:     MVI	D,PG01 ;\HB\OLDPG1    ;** Set page address of FPACC
 2784/12A6 : 26 54                                 MVI	E, 124o               ;Set address of least signficant byte of FPACC
 2785/12A8 : 0E 04                                 MVI	B, 004                ;Set precision counter to four bytes (mantissa bytes
 2786/12AA : 44 0B 11                              JMP	MOVEIT             ;Plus Exponent) and exit via the transfer routine
 2787/12AD :                            
 2788/12AD :                                                              ;The next several subroutines are used to perform
 2789/12AD :                                                              ;floating pojnt register loading and transfer operations.
 2790/12AD :                            
 2791/12AD : E6                         FSTORE:    MOV	E,L                    ;Transfer contents of register L to E
 2792/12AE : DD                                    MOV	D,H                    ;Transfer contents of register H to D
 2793/12AF : 36 54                                 MVI	L, 124o               ;Set L to least significant byte of FPACC mantissa
 2794/12B1 : 2E 01                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set page to FPACC storage area
 2795/12B3 : 44 BA 12                              JMP	SETIT              ;Go transfer FPACC contents to area pointed to by D&E
 2796/12B6 : 1E 01                      OPLOAD:    MVI	D,PG01 ;\HB\OLDPG1    ;** Set page to FPOP storage area
 2797/12B8 : 26 5C                                 MVI	E, 134o               ;Set pointer to least significant byte of FPOP
 2798/12BA : 0E 04                      SETIT:     MVI	B, 004                ;Set precision counter. Transfer from H & L area to
 2799/12BC : 44 0B 11                              JMP	MOVEIT             ;Locations pointed to by D & E
 2800/12BF :                            
 2801/12BF :                                                              ;The next subroutine perforins a double transfer opera-
 2802/12BF :                                                              ;tion. It first transfers the contents of the FPACC into
 2803/12BF :                                                              ;the FPOP. It then transfers new data (as pointed to by
 2804/12BF :                                                              ;H & L upon entry to the subroutine) into the FPACC.
 2805/12BF :                            
 2806/12BF : 46 CF 12                   FACXOP:    CALL	SAVEHL             ;Save contents of H & L upon entry to subroutine
 2807/12C2 : 36 54                                 MVI	L, 124o               ;Set pointer to FPACC LSW
 2808/12C4 : 2E 01                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set pointer to page of FPACC
 2809/12C6 : 46 B6 12                              CALL	OPLOAD             ;Transfer FPACC to FPOP
 2810/12C9 : 46 DF 12                              CALL	RESTHL             ;Recover original subroutine entry values for H & L
 2811/12CC : 44 A4 12                              JMP	FLOAD              ;Transfer registers pointed to by H & L into the FPACC
 2812/12CF :                            
 2813/12CF :                                                              ;Subroutine to save the contents of CPU registers D, E, H
 2814/12CF :                                                              ;and L in a temporary storage area in memory.
 2815/12CF :                            
 2816/12CF : C5                         SAVEHL:    MOV	A,H                    ;Transfer value in H to ACC
 2817/12D0 : CE                                    MOV	B,L                    ;And value in L to B
 2818/12D1 : 36 80                                 MVI	L, 200o               ;Now set L to start of tempomry storage locations
 2819/12D3 : 2E 01                                 MVI	H,PG01 ;\HB\OLDPG1    ;** And set H to storage area page
 2820/12D5 : F8                                    MOV	M,A                    ;Save A (entry value of H) in memory
 2821/12D6 : 30                                    INR	L                    ;Advance pointer
 2822/12D7 : F9                                    MOV	M,B                    ;Save B (entry value of L) in memory
 2823/12D8 : 30                                    INR	L                    ;Advance pointer
 2824/12D9 : FB                                    MOV	M,D                    ;Save D in memory
 2825/12DA : 30                                    INR	L                    ;Advance pointer
 2826/12DB : FC                                    MOV	M,E                    ;Save E in memory
 2827/12DC : E8                                    MOV	H,A                    ;Restore entry value of H
 2828/12DD : F1                                    MOV	L,B                    ;Restore entry value of L
 2829/12DE : 07                                    RET                    ;Exit to calling routine
 2830/12DF :                            
 2831/12DF :                                                              ;Subroutine to restore the contents of CPU registers D,
 2832/12DF :                                                              ;E, H and L from temporary storage in memory.
 2833/12DF :                            
 2834/12DF : 36 80                      RESTHL:    MVI	L, 200o               ;Set L to start of temporary storage locations
 2835/12E1 : 2E 01                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to storage area page
 2836/12E3 : C7                                    MOV	A,M                    ;Fetch stored value for li iii ACC
 2837/12E4 : 30                                    INR	L                    ;Advance pointer
 2838/12E5 : CF                                    MOV	B,M                    ;Fetch stored value for L into B
 2839/12E6 : 30                                    INR	L                    ;Advance pointer
 2840/12E7 : DF                                    MOV	D,M                    ;Fetch stored value for T.)
 2841/12E8 : 30                                    INR	L                    ;Advance pointer
 2842/12E9 : E7                                    MOV	E,M                    ;Fetch stored value for
 2843/12EA : E8                                    MOV	H,A                    ;Restore  saved value for H
 2844/12EB : F1                                    MOV	L,B                    ;Restore saved value for L
 2845/12EC : C7                                    MOV	A,M                    ;Leave stored value for E in ACC
 2846/12ED : 07                                    RET                    ;Exit to calling routine
 2847/12EE :                            
 2848/12EE :                                                              ;Subroutine to exchange the contents of H & L with
 2849/12EE :                                                              ;D & E.
 2850/12EE :                            
 2851/12EE : D5                         SWITCH:    MOV	C,H                    ;Transfer register H to C temporarily
 2852/12EF : EB                                    MOV	H,D                    ;Place value of D into H
 2853/12F0 : DA                                    MOV	D,C                    ;Now put former H from C into D
 2854/12F1 : D6                                    MOV	C,L                    ;Transfer register L to C temporarily
 2855/12F2 : F4                                    MOV	L,E                    ;Place value of E into L
 2856/12F3 : E2                                    MOV	E,C                    ;Now put former L from C into E
 2857/12F4 : 07                                    RET                    ;Exit to calling routine
 2858/12F5 : 2E 01                      GETINP:    MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to page of GETINP character counter
 2859/12F7 : 36 90                                 MVI	L, 220o               ;Set L to address of GETINP character counter
 2860/12F9 : D7                                    MOV	C,M                    ;Load counter value into CPU register C
 2861/12FA : 10                                    INR	C                    ;Exercise the counter in order
 2862/12FB : 11                                    DCR	C                    ;To set CPU flags. If counter is non-zero, then indexing
 2863/12FC : 48 08 13                              JNZ	NOT0               ;Register (GETINP counter) is all set so jump ahead.
 2864/12FF : F4                                    MOV	L,E                    ;But, if counter zero, then starting to process a new
 2865/1300 : EB                                    MOV	H,D                    ;Character string. Transfer char string buffer pointer into
 2866/1301 : D7                                    MOV	C,M                    ;H & L and fetch the string's character count value (cc)
 2867/1302 : 10                                    INR	C                    ;Increment the (cc) by one to take account of (cc) byte
 2868/1303 : 46 1E 13                              CALL	INDEXC             ;Add contents of regis C to H & L to point to end of the
 2869/1306 : 3E 00                                 MVI	M, 000                ;Character string in buffer and place a zero byte marker
 2870/1308 : 36 90                      NOT0:      MVI	L, 220o               ;Set L back to address of GETINP counter which is used
 2871/130A : 2E 01                                 MVI	H,PG01 ;\HB\OLDPG1    ;** As an indexing value. Set H to correct page.
 2872/130C : D7                                    MOV	C,M                    ;Fetch the value of GETINP counter into register C
 2873/130D : 10                                    INR	C                    ;Increment the value in C
 2874/130E : FA                                    MOV	M,C                    ;Restore the updated value for future use
 2875/130F : F4                                    MOV	L,E                    ;Bring the base address of the character string buffer into
 2876/1310 : EB                                    MOV	H,D                    ;CPU registers H & L
 2877/1311 : 46 1E 13                              CALL	INDEXC             ;Add contents of register C to form indexed address of
 2878/1314 : C7                                    MOV	A,M                    ;Next character to be fetched as input. Fetch the next
 2879/1315 : A0                                    ANA	A                    ;Character. Exercise the CPU flags.
 2880/1316 : 2E 01                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Restore page pointer to floating point working area
 2881/1318 : 0B                                    RNZ                    ;If character is non-zero, not end of string, exit to calle
 2882/1319 : 36 90                                 MVI	L, 220o               ;If zero character, must reset GETINP counter for next
 2883/131B : 3E 00                                 MVI	M, 000                ;String. Reset pointer and clear GETINP counter to zero
 2884/131D : 07                                    RET                    ;Then exit to calling routine
 2885/131E :                            
 2886/131E :                                                              ;Following subroutine causes register C to be used as an
 2887/131E :                                                              ;indexing register. Value in C is added to address in H
 2888/131E :                                                              ;and L to form new address.
 2889/131E :                            
 2890/131E : C6                         INDEXC:    MOV	A,L                    ;Place value from register L into accumulator
 2891/131F : 82                                    ADD	C                    ;Add quantity in register C
 2892/1320 : F0                                    MOV	L,A                    ;Restore updated value back to L
 2893/1321 : 03                                    RNC                    ;Exit to caller if no carry from addition
 2894/1322 : 28                                    INR	H                    ;But, if have carry then must increment register H
 2895/1323 : 07                                    RET                    ;Before returning to calling routine
 2896/1324 :                            
 2897/1324 :                                                              ;Main Decimal INPUT subroutine to convert strings of
 2898/1324 :                                                              ;ASCII characters representing decimal fixed or floating
 2899/1324 :                                                              ;point numbers to binary floating point numbers.
 2900/1324 :                            
 2901/1324 : E6                         DINPUT:    MOV	E,L                    ;Save entry value of register L in E. (Pointer to buffer
 2902/1325 : DD                                    MOV	D,H                    ;Containing ASCII character string.) Do same for H to D.
 2903/1326 : 2E 01                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to page of floating point working registers
 2904/1328 : 36 68                                 MVI	L, 150o               ;Set L to start of decirnal-to-binary working area
 2905/132A : A8                                    XRA	A                    ;Clear the accumulator
 2906/132B : 0E 08                                 MVI	B, 010o               ;Set up a loop counter
 2907/132D : F8                         CLRNX2:    MOV	M,A                    ;Deposit zero in working area to initialize
 2908/132E : 30                                    INR	L                    ;Advance the memory pointer
 2909/132F : 09                                    DCR	B                    ;Decrement the loop counter
 2910/1330 : 48 2D 13                              JNZ	CLRNX2             ;Clear working area until loop counter is zero
 2911/1333 : 36 43                                 MVI	L, 103o               ;Set pointer to floating point temporary registers and
 2912/1335 : 0E 04                                 MVI	B, 004                ;Indicators working area. Set up a loop counter.
 2913/1337 : F8                         CLRNX3:    MOV	M,A                    ;Deposit zero in working area to initialize
 2914/1338 : 30                                    INR	L                    ;Advance the memory pointer
 2915/1339 : 09                                    DCR	B                    ;Decrement the loop counter
 2916/133A : 48 37 13                              JNZ	CLRNX3             ;Clear working area until loop counter is zero
 2917/133D : 46 F5 12                              CALL	GETINP             ;Fetch a character from the ASCII chax string buffer
 2918/1340 : 3C AB                                 CPI	253o               ;(Typically the SYMBOL/TOKEN buffer). See if it is
 2919/1342 : 68 4D 13                              JZ	NINPUT             ;Code for + sign. Jump ahead if code for + sign.
 2920/1345 : 3C AD                                 CPI	255o               ;See if code for minus (-) sign.
 2921/1347 : 48 50 13                              JNZ	NOTPLM             ;Jump ahead if not code for minus sign. If code for
 2922/134A : 36 43                                 MVI	L, 103o               ;Minus sign, set pointer to MINUS flag storage location.
 2923/134C : F8                                    MOV	M,A                    ;Set the MINUS flag to indicate a minus number
 2924/134D : 46 F5 12                   NINPUT:    CALL	GETINP             ;Fetch another character from the ASCII char string
 2925/1350 : 3C AE                      NOTPLM:    CPI	256o               ;See if character represents a period (decimal point) in
 2926/1352 : 68 81 13                              JZ	PERIOD             ;Input string. Jump ahead if yes.
 2927/1355 : 3C C5                                 CPI	305o               ;If not period, see if code for E as in Exponent
 2928/1357 : 68 91 13                              JZ	FNDEXP             ;Jump ahead if yes.
 2929/135A : 3C A0                                 CPI	240o               ;Else see if code for space.
 2930/135C : 68 4D 13                              JZ	NINPUT             ;Ignore space character, go fetch another character.
 2931/135F : A0                                    ANA	A                    ;If none of the above see if zero byte
 2932/1360 : 68 C9 13                              JZ	ENDINP             ;Indicating end of input char string. If yes, jumn ahead.
 2933/1363 : 3C B0                                 CPI	260o               ;If not end of string, check to see
 2934/1365 : 70 FD 0A                              JM	NUMERR             ;If character represents
 2935/1368 : 3C BA                                 CPI	272o               ;A valid decimal number (0 to 9)
 2936/136A : 50 FD 0A                              JP	NUMERR             ;Display error message if not a valid digit at this point!
 2937/136D : 36 6E                                 MVI	L, 156o               ;For valid digit, set pointer to MSW of temporary
 2938/136F : D0                                    MOV	C,A                    ;Decimal to binary holding registers. Save character in C.
 2939/1370 : 06 F8                                 MVI	A, 370o               ;Form mask for sizing in accumulator. Now see if
 2940/1372 : A7                                    ANA	M                    ;Holding register has enough room for the conversion of
 2941/1373 : 48 4D 13                              JNZ	NINPUT             ;Another digit. Ignore the input if no more room.
 2942/1376 : 36 45                                 MVI	L, IN_DIGIT_CC_L      ;If have room in register then set pointer to input digit
 2943/1378 : CF                                    MOV	B,M                    ;Counter location. Fetch the present value.
 2944/1379 : 08                                    INR	B                    ;Increment it to account for incoming digit.
 2945/137A : F9                                    MOV	M,B                    ;Restore updated count to storage location.
 2946/137B : 46 2E 14                              CALL	DECBIN             ;Call the DECimal to BINary conversion routine to add
 2947/137E : 44 4D 13                              JMP	NINPUT             ;In the new digit in holding registers. Continue inputting.
 2948/1381 : C8                         PERIOD:    MOV	B,A                    ;Save character code in register B
 2949/1382 : 36 46                                 MVI	L, 106o               ;Set pointer to PERIOD indicator storage location
 2950/1384 : C7                                    MOV	A,M                    ;Fetch value in PERIOD indicator
 2951/1385 : A0                                    ANA	A                    ;Exercise CPU flags
 2952/1386 : 48 FD 0A                              JNZ	NUMERR             ;If already have a period then display error message
 2953/1389 : 36 45                                 MVI	L, IN_DIGIT_CC_L      ;If not, change pointer to digit counter storage location
 2954/138B : F8                                    MOV	M,A                    ;Clear the digit counter back to zero
 2955/138C : 30                                    INR	L                    ;Advance pointer to PERIOD indicator
 2956/138D : F9                                    MOV	M,B                    ;Set the PERIOD indicator
 2957/138E : 44 4D 13                              JMP	NINPUT             ;Continue processing the input character string
 2958/1391 : 46 F5 12                   FNDEXP:    CALL	GETINP             ;Get next character in Exponent
 2959/1394 : 3C AB                                 CPI	253o               ;See if it is code for + sign
 2960/1396 : 68 A1 13                              JZ	EXPINP             ;Jump ahead if yes.
 2961/1399 : 3C AD                                 CPI	255o               ;If not + sign, see if minus sign
 2962/139B : 48 A4 13                              JNZ	NOEXPS             ;If not minus sign then jump ahead
 2963/139E : 36 44                                 MVI	L, 104o               ;For minus sign, set pointer to EXP SIGN indicator
 2964/13A0 : F8                                    MOV	M,A                    ;Set the EXP SIGN indicator for a minus exponent
 2965/13A1 : 46 F5 12                   EXPINP:    CALL	GETINP             ;Fetch the next character in the decimal exponent
 2966/13A4 : A0                         NOEXPS:    ANA	A                    ;Exercise the CPU flags
 2967/13A5 : 68 C9 13                              JZ	ENDINP             ;If character inputted was zero, then end of input string
 2968/13A8 : 3C B0                                 CPI	260o               ;If not end of string, check to see
 2969/13AA : 70 FD 0A                              JM	NUMERR             ;If character represents
 2970/13AD : 3C BA                                 CPI	272o               ;A valid decimal number (0 to 9)
 2971/13AF : 50 FD 0A                              JP	NUMERR             ;Display error message if not a valid digit at this point!
 2972/13B2 : 24 0F                                 ANI	017o               ;Else trim the ASCII code to BCD
 2973/13B4 : C8                                    MOV	B,A                    ;And save in register B
 2974/13B5 : 36 6F                                 MVI	L, 157o               ;Set pointer to input exponent storage location
 2975/13B7 : 06 03                                 MVI	A, 003                ;Set accumulator equal to three
 2976/13B9 : BF                                    CMP	M                    ;See if any previous digit in exponent greater than three
 2977/13BA : 70 FD 0A                              JM	NUMERR             ;Display error message if yes
 2978/13BD : D7                                    MOV	C,M                    ;Else save any previous value in register C
 2979/13BE : C7                                    MOV	A,M                    ;And also place any previous value in accumulator
 2980/13BF : A0                                    ANA	A                    ;Clear the carry bit with this instruction
 2981/13C0 : 12                                    RAL                    ;Single precision multiply by ten algorithm
 2982/13C1 : 12                                    RAL                    ;Two rotate lefts equals times four
 2983/13C2 : 82                                    ADD	C                    ;Adding in the digit makes total times five
 2984/13C3 : 12                                    RAL                    ;Rotating left again equals times ten
 2985/13C4 : 81                                    ADD	B                    ;now add in digit just inputted
 2986/13C5 : F8                                    MOV	M,A                    ;Restore the value to exponent storage location
 2987/13C6 : 44 A1 13                              JMP	EXPINP             ;Go get any additional exponent int)ut
 2988/13C9 : 36 43                      ENDINP:    MVI	L, 103o               ;Set pointer to mantissa SIGN indicator
 2989/13CB : C7                                    MOV	A,M                    ;Fetch the SIGN indicator to the acclimulator
 2990/13CC : A0                                    ANA	A                    ;Exercise the CPU flags
 2991/13CD : 68 D7 13                              JZ	FININP             ;If SIGN indicator is zero, go finish up as nr is positive
 2992/13D0 : 36 6C                                 MVI	L, 154o               ;But, if indicator is non-zero, number is negative
 2993/13D2 : 0E 03                                 MVI	B, 003                ;Set pntr to LSW of storage registers, set precision entr
 2994/13D4 : 46 68 12                              CALL	COMPLM             ;Negate the triple-precision number in holding registers
 2995/13D7 : 36 6B                      FININP:    MVI	L, 153o               ;Set pointer to input storage LS~V minus one
 2996/13D9 : A8                                    XRA	A                    ;Clear the accumulator
 2997/13DA : F8                                    MOV	M,A                    ;Clear the LSW minus one location
 2998/13DB : DD                                    MOV	D,H                    ;Set register D to floating point working page
 2999/13DC : 26 53                                 MVI	E, 123o               ;Set E to address of FPACC LSW minus one
 3000/13DE : 0E 04                                 MVI	B, 004                ;Set precision counter
 3001/13E0 : 46 0B 11                              CALL	MOVEIT             ;Move number from input register to FPACC
 3002/13E3 : 46 34 10                              CALL	FPFLT              ;Now convert the binary fixed point to floating point
 3003/13E6 : 36 44                                 MVI	L, 104o               ;Set pointer to Exponent SIGN indicator location
 3004/13E8 : C7                                    MOV	A,M                    ;Fetch the value of the EXP SIGN indicator
 3005/13E9 : A0                                    ANA	A                    ;Exercise the CPU flags
 3006/13EA : 36 6F                                 MVI	L, 157o               ;Reset pointer to input exponent storage location
 3007/13EC : 68 F5 13                              JZ	POSEXP             ;If EXP SIGN indicator zero, exponent is positive
 3008/13EF : C7                                    MOV	A,M                    ;Else, exponent is negative so must negate
 3009/13F0 : 2C FF                                 XRI	377o               ;The value in the input exponent storage location
 3010/13F2 : 04 01                                 ADI	001                ;By performing this two's complement
 3011/13F4 : F8                                    MOV	M,A                    ;Restore the negated value to exponent storage location
 3012/13F5 : 36 46                      POSEXP:    MVI	L, 106o               ;Set pointer to PERIOD indicator storage location
 3013/13F7 : C7                                    MOV	A,M                    ;Fetch the contents of the PERIOD indicator
 3014/13F8 : A0                                    ANA	A                    ;Exercise the CPU flags
 3015/13F9 : 68 00 14                              JZ	EXPOK              ;If PERIOD indicator clear, no decimal point involved
 3016/13FC : 36 45                                 MVI	L, IN_DIGIT_CC_L      ;If have a decimal point, set pointer to digit counter
 3017/13FE : A8                                    XRA	A                    ;Storage location. Clear the accumulator.
 3018/13FF : 97                                    SUB	M                    ;And get a negated value of the digit counter in ACC
 3019/1400 : 36 6F                      EXPOK:     MVI	L, 157o               ;Change pointer to input exponent storage location
 3020/1402 : 87                                    ADD	M                    ;Add this value to negated digit counter value
 3021/1403 : F8                                    MOV	M,A                    ;Restore new value to storage location
 3022/1404 : 70 1B 14                              JM	MINEXP             ;If new value is minus, skip over next subroutine
 3023/1407 : 2B                                    RZ                    ;If new value is zero, no further processing required
 3024/1408 :                            
 3025/1408 :                                                              ;Following subroutine will multiply the floating point
 3026/1408 :                                                              ;binary number stored in FPACC by ten tirnes the
 3027/1408 :                                                              ;value stored in the deciinal exponent storage location.
 3028/1408 :                            
 3029/1408 : 36 88                      FPX10:     MVI	L, 210o               ;Set pointer to registers containing floating point
 3030/140A : 2E 01                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Binary representation of 10 (decimal).
 3031/140C : 46 BF 12                              CALL	FACXOP             ;Transfer FPACC to FPOP and 10 (dec) to FPACC
 3032/140F : 46 26 11                              CALL	FPMULT             ;Multiply FPOP (formerly FPACC) by 10 (decimal)
 3033/1412 : 36 6F                                 MVI	L, 157o               ;Set pointer to decimal exponent storage location
 3034/1414 : D7                                    MOV	C,M                    ;Fetch the exponent value
 3035/1415 : 11                                    DCR	C                    ;Decrement
 3036/1416 : FA                                    MOV	M,C                    ;Restore to storage
 3037/1417 : 48 08 14                              JNZ	FPX10              ;If exponent value is not zero, continue multiplication
 3038/141A : 07                                    RET                    ;When exponent is zero can exit. Conversion completed.
 3039/141B :                            
 3040/141B :                                                              ;Following subroutine will multiply the floating point
 3041/141B :                                                              ;binary number stored in PPACC by 0.1 times the value
 3042/141B :                                                              ;(negative) stored in the decimal exponent storage location
 3043/141B :                            
 3044/141B :                            MINEXP:
 3045/141B : 36 8C                      FPD10:     MVI	L, 214o               ;Set pointer to registers containing floating point
 3046/141D : 2E 01                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Binary representation of 0.1 (decimal).
 3047/141F : 46 BF 12                              CALL	FACXOP             ;Transfer FPACC to FPOP and 0.1 (dec) to FPACC
 3048/1422 : 46 26 11                              CALL	FPMULT             ;Multitply FPOP (formerly FPACC) by 0.1 (decimal)
 3049/1425 : 36 6F                                 MVI	L, 157o               ;Set pointer to decimal exponent storage location
 3050/1427 : CF                                    MOV	B,M                    ;Fetch the exponent value
 3051/1428 : 08                                    INR	B                    ;Increment
 3052/1429 : F9                                    MOV	M,B                    ;Restore to storage
 3053/142A : 48 1B 14                              JNZ	FPD10              ;If exponent value is not zero, continue multiplication
 3054/142D : 07                                    RET                    ;When exponent is zero can exit. Conversion completed.
 3055/142E :                            
 3056/142E :                                                              ;Following subroutine is used
 3057/142E :                                                              ;to convert decimal charac-
 3058/142E :                                                              ;ters to binary fixed point forinat
 3059/142E :                                                              ;in a triple-precision format.
 3060/142E :                            
 3061/142E : 46 CF 12                   DECBIN:    CALL	SAVEHL             ;Save entry value of D, E, H and L in memory
 3062/1431 : 36 6B                                 MVI	L, 153o               ;Set pointer to temporary storage location
 3063/1433 : C2                                    MOV	A,C                    ;Restore character inputted to accumulator
 3064/1434 : 24 0F                                 ANI	017o               ;Trim ASCII code to BCD
 3065/1436 : F8                                    MOV	M,A                    ;Store temporarily
 3066/1437 : 26 68                                 MVI	E, 150o               ;Set pointer to working area LSW of multi-byte register
 3067/1439 : 36 6C                                 MVI	L, 154o               ;Set another pointer to LSW of conversion register
 3068/143B : DD                                    MOV	D,H                    ;Make sure D set to page of working area
 3069/143C : 0E 03                                 MVI	B, 003                ;Set precision counter
 3070/143E : 46 0B 11                              CALL	MOVEIT             ;Move original value of conversion register to working
 3071/1441 : 36 6C                                 MVI	L, 154o               ;Register. Reset pointer to LSW of conversion register.
 3072/1443 : 0E 03                                 MVI	B, 003                ;Set precision counter
 3073/1445 : 46 7F 12                              CALL	ROTATL             ;Rotate register left, (Multiplies value by two.)
 3074/1448 : 36 6C                                 MVI	L, 154o               ;Reset pointer to LSW.
 3075/144A : 0E 03                                 MVI	B, 003                ;Set precision counter
 3076/144C : 46 7F 12                              CALL	ROTATL             ;Multiply by two again (total now times four).
 3077/144F : 26 6C                                 MVI	E, 154o               ;Set pointer to LSW of conversion register.
 3078/1451 : 36 68                                 MVI	L, 150o               ;Set pointer to LSW of working register (original value).
 3079/1453 : 0E 03                                 MVI	B, 003                ;Set precision counter.
 3080/1455 : 46 57 12                              CALL	ADDER              ;Add original value to rotated value (now times five).
 3081/1458 : 36 6C                                 MVI	L, 154o               ;Reset pointer to LSW
 3082/145A : 0E 03                                 MVI	B, 003                ;Set precision counter
 3083/145C : 46 7F 12                              CALL	ROTATL             ;Multiply by two once more (total now times ten).
 3084/145F : 36 6A                                 MVI	L, 152o               ;Set pointer to clear working register locatiotis
 3085/1461 : A8                                    XRA	A                    ;Clear the accumulator
 3086/1462 : F8                                    MOV	M,A                    ;Clear MSW of working register
 3087/1463 : 31                                    DCR	L                    ;Decrement pointer
 3088/1464 : F8                                    MOV	M,A                    ;Clear next byte
 3089/1465 : 36 6B                                 MVI	L, 153o               ;Set pointer to current digit storage location
 3090/1467 : C7                                    MOV	A,M                    ;Fetch the current digit
 3091/1468 : 36 68                                 MVI	L, 150o               ;Change pointer to LSW of working register
 3092/146A : F8                                    MOV	M,A                    ;Deposit the current digit in LSW of working register
 3093/146B : 26 6C                                 MVI	E, 154o               ;Set pointer to conversion register LSW
 3094/146D : 0E 03                                 MVI	B, 003                ;Set precision counter
 3095/146F : 46 57 12                              CALL	ADDER              ;Add current digit to conversion register to complete
 3096/1472 : 44 DF 12                              JMP	RESTHL             ;Conversion. Exit to caller by restoring CPU registers.
 3097/1475 : 2E 01                      FPOUT:     MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to working area for floating point routines
 3098/1477 : 36 6F                                 MVI	L, 157o               ;Set pointer to decimal exponent storage location
 3099/1479 : 3E 00                                 MVI	M, 000                ;Initialize storage location to zero
 3100/147B : 36 56                                 MVI	L, 126o               ;Change pointer to FPACC (number to be outputted)
 3101/147D : C7                                    MOV	A,M                    ;And fetch MSW of FPACC
 3102/147E : A0                                    ANA	A                    ;Test the contents of MSW of FPACC
 3103/147F : 70 87 14                              JM	OUTNEG             ;If most significant bit of MSW is a one, have a minus nr.
 3104/1482 : 06 A0                                 MVI	A, 240o               ;Else number is positive, set ASCII code for space for a
 3105/1484 : 44 90 14                              JMP	AHEAD1             ;Positive number and go display a space
 3106/1487 : 36 54                      OUTNEG:    MVI	L, 124o               ;If number in FPACC is negative must negate in order
 3107/1489 : 0E 03                                 MVI	B, 003                ;To display. Set pntr to LSW of FPACC & set prec. cntr.
 3108/148B : 46 68 12                              CALL	COMPLM             ;Negate the number in the FPACC to make it positive
 3109/148E : 06 AD                                 MVI	A, 255o               ;But load ACC with ASCII code for minus sign
 3110/1490 : 46 82 03                   AHEAD1:    CALL	ECHO               ;Call user display driver to output space or minus sign
 3111/1493 : 36 48                                 MVI	L, 110o               ;Set pointer to FIXED/FLOAT indicator
 3112/1495 : C7                                    MOV	A,M                    ;Fetch value of FIXED/FLOAT indicator
 3113/1496 : A0                                    ANA	A                    ;Test contents of indicator. If contents are zero, calling
 3114/1497 : 68 AB 14                              JZ	OUTFLT             ;Routine has directed floating point output format.
 3115/149A : 36 57                                 MVI	L, 127o               ;If indicator non-zero, fixed point fonnat requested if
 3116/149C : 06 17                                 MVI	A, 027o               ;Possible. Point to FPACC Exponent. Put 23 decimal in
 3117/149E : CF                                    MOV	B,M                    ;Accumulator. Fetch FPACC Exponent into register B
 3118/149F : 08                                    INR	B                    ;And exercise the register to test its
 3119/14A0 : 09                                    DCR	B                    ;Original contents. If FPACC Exponent is negative in
 3120/14A1 : 70 AB 14                              JM	OUTFLT             ;Value then go to floating point output forrnat. If value
 3121/14A4 : 91                                    SUB	B                    ;Is positive, subtract value from 23 (decimal). If result
 3122/14A5 : 70 AB 14                              JM	OUTFLT             ;Negative, number is too big to use fixed format.
 3123/14A8 : 44 B9 14                              JMP	OUTFIX             ;Else, can use fixed format so skip next routine
 3124/14AB : 36 48                      OUTFLT:    MVI	L, 110o               ;Set pointer to FIXED/FLOAT indicator.
 3125/14AD : 3E 00                                 MVI	M, 000                ;Clear indicator to indicate floating point output format
 3126/14AF : 06 B0                                 MVI	A, 260o               ;Load ASCII code for '0' into accumulator
 3127/14B1 : 46 82 03                              CALL	ECHO               ;Call user display driver to output '0' as first character
 3128/14B4 : 06 AE                                 MVI	A, 256o               ;Number string. Now load ASCII code for decimal point.
 3129/14B6 : 46 82 03                              CALL	ECHO               ;Call user display driver to output '.'as second character.
 3130/14B9 : 36 57                      OUTFIX:    MVI	L, 127o               ;Set pointer to FPACC Exponent
 3131/14BB : 06 FF                                 MVI	A, 377o               ;Load accumulator with minus one
 3132/14BD : 87                                    ADD	M                    ;Add value in FPACC Exponent
 3133/14BE : F8                                    MOV	M,A                    ;Restore compensated exponent value
 3134/14BF :                            
 3135/14BF :                                                              ;Next portion of routine establishes the value for the
 3136/14BF :                                                              ;decimal exponent that will be outputted by processing
 3137/14BF :                                                              ;the binary exponent value in the FPACC.
 3138/14BF :                            
 3139/14BF : 50 DE 14                   DECEXT:    JP	DECEXD             ;If compensated exponent value is zero or positive
 3140/14C2 : 06 04                                 MVI	A, 004                ;Then go multiply FPACC by 0.1 (decimal). Else,
 3141/14C4 : 87                                    ADD	M                    ;Add four to the exponent value.
 3142/14C5 : 50 F0 14                              JP	DECOUT             ;If exponent now zero or positive, ready to output
 3143/14C8 : 36 88                                 MVI	L, 210o               ;If exponent negative, multiply FPACC by 10 (decimal)
 3144/14CA : 2E 01                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set pointer to registers holding 10 (dec) in binary
 3145/14CC : 46 BF 12                              CALL	FACXOP             ;Floating point format. Set up for multiplication.
 3146/14CF : 46 26 11                              CALL	FPMULT             ;Perform the multiplication. Answer in FPACC.
 3147/14D2 : 36 6F                                 MVI	L, 157o               ;Set pointer to decimal exponent storage location.
 3148/14D4 : D7                                    MOV	C,M                    ;Each time the FPACC is multiplied by ten, need to
 3149/14D5 : 11                                    DCR	C                    ;Decrement the value in the decinial exponent storage
 3150/14D6 : FA                                    MOV	M,C                    ;Location. (This establishes decimal exponent value!)
 3151/14D7 : 36 57                      DECREP:    MVI	L, 127o               ;Reset pointer to FPACC Exponent
 3152/14D9 : C7                                    MOV	A,M                    ;Fetch value in exponent
 3153/14DA : A0                                    ANA	A                    ;Test value
 3154/14DB : 44 BF 14                              JMP	DECEXT             ;Repeat process as required
 3155/14DE : 36 8C                      DECEXD:    MVI	L, 214o               ;If exponent is positive, multiply FPACC by 0.1
 3156/14E0 : 2E 01                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set pointer to registers holding 0.1 dec in binary
 3157/14E2 : 46 BF 12                              CALL	FACXOP             ;Floating point format. Set up for multipli(-ation.
 3158/14E5 : 46 26 11                              CALL	FPMULT             ;Perform the multiplication. Answer in FPACC.
 3159/14E8 : 36 6F                                 MVI	L, 157o               ;Set pointer to decimal exponent storage location.
 3160/14EA : CF                                    MOV	B,M                    ;Each time the FPACC is multiplied by one tenth, need
 3161/14EB : 08                                    INR	B                    ;To increment the value in the decimal exponent storage
 3162/14EC : F9                                    MOV	M,B                    ;Location. (This establishes decimal exponent value!)
 3163/14ED : 44 D7 14                              JMP	DECREP             ;Repeat process as required
 3164/14F0 :                            
 3165/14F0 :                                                              ;The next section outputs the mantissa
 3166/14F0 :                                                              ;(or fixed point number) by converting the value remaining
 3167/14F0 :                                                              ;in the FPACC (after the decimal exponent equivalent has
 3168/14F0 :                                                              ;been extracted from the original value if required by the
 3169/14F0 :                                                              ;previous routines) to a string of decirnal digits.
 3170/14F0 : 26 74                      DECOUT:    MVI	E, 164o               ;Set pointer to LSW of output working register
 3171/14F2 : DD                                    MOV	D,H                    ;Set D to same page value as H
 3172/14F3 : 36 54                                 MVI	L, 124o               ;Set pointer to LSW of FPACC
 3173/14F5 : 0E 03                                 MVI	B, 003                ;Set precision counter
 3174/14F7 : 46 0B 11                              CALL	MOVEIT             ;Move value in FPACC to output working register
 3175/14FA : 36 77                                 MVI	L, 167o               ;Set pointer to MSW plus one of output working register
 3176/14FC : 3E 00                                 MVI	M, 000                ;Clear that location to 0
 3177/14FE : 36 74                                 MVI	L, 164o               ;Set pointer to LSW of output working register
 3178/1500 : 0E 03                                 MVI	B, 003                ;Set precision counter
 3179/1502 : 46 7F 12                              CALL	ROTATL             ;Rotate register left once to compensate for sign bit
 3180/1505 : 46 93 15                              CALL	OUTX10             ;Multiply output register by 10, overflow into N4SW+ 1
 3181/1508 : 36 57                      COMPEN:    MVI	L, 127o               ;Set pointer back to FPACC Exponent
 3182/150A : CF                                    MOV	B,M                    ;Compensate for any remainder in the binary exponent
 3183/150B : 08                                    INR	B                    ;By performing a rotate right on the output working
 3184/150C : F9                                    MOV	M,B                    ;Register until the binary exponent becomes zero
 3185/150D : 68 1A 15                              JZ	OUTDIG             ;Go output decimal digits when this loop is finished
 3186/1510 : 36 77                                 MVI	L, 167o               ;Binary exponent compensating loop. Setpointe'r to
 3187/1512 : 0E 04                                 MVI	B, 004                ;Working register MSW+L. Set precision counter.
 3188/1514 : 46 89 12                              CALL	ROTATR             ;Rotate working register to the right.
 3189/1517 : 44 08 15                              JMP	COMPEN             ;Repeat loop as required.
 3190/151A : 36 47                      OUTDIG:    MVI	L, 107o               ;Set pointer to output digit counter storage location
 3191/151C : 3E 07                                 MVI	M, 007                ;Initialize to value of seven
 3192/151E : 36 77                                 MVI	L, 167o               ;Change pointer to output working register MSW+L
 3193/1520 : C7                                    MOV	A,M                    ;Fetch MSW+L byte containing BCD of digit to be
 3194/1521 : A0                                    ANA	A                    ;Displayed. Test the contents of this byte.
 3195/1522 : 68 75 15                              JZ	ZERODG             ;If zero jump to ZERODG routine.
 3196/1525 : 36 77                      OUTDGS:    MVI	L, 167o               ;Reset pointer to working register MSW+L
 3197/1527 : C7                                    MOV	A,M                    ;Fetch BCD of digit to be outputted
 3198/1528 : A0                                    ANA	A                    ;Exercise CPU flags
 3199/1529 : 48 45 15                              JNZ	OUTDGX             ;If not zero, go display the digit
 3200/152C : 36 48                                 MVI	L, 110o               ;If zero, change pointer to FIXED/FLOAT indicator
 3201/152E : C7                                    MOV	A,M                    ;Fetch the indicator into the accumulator
 3202/152F : A0                                    ANA	A                    ;Test value of indicator
 3203/1530 : 68 44 15                              JZ	OUTZER             ;If in floating point mode, go display the digit
 3204/1533 : 36 6F                                 MVI	L, 157o               ;Else change pointer to decimal exponent storage
 3205/1535 : D7                                    MOV	C,M                    ;Location, which, for fixed point, will have a positive
 3206/1536 : 11                                    DCR	C                    ;Value for all digits before the decimal point. Decrement
 3207/1537 : 10                                    INR	C                    ;And increment to exercise flags. See if count is positive.
 3208/1538 : 50 44 15                              JP	OUTZER             ;If positive, must display any zero digit.
 3209/153B : 36 76                                 MVI	L, 166o               ;If not, change pointer to MSW of working register
 3210/153D : C7                                    MOV	A,M                    ;And test to see if any significant digits coming up
 3211/153E : 24 E0                                 ANI	340o               ;By forming a mask and testing for presence of bits
 3212/1540 : 48 44 15                              JNZ	OUTZER             ;If more significant digits coming up soon, display the
 3213/1543 : 07                                    RET                    ;Zero digit. Else, exit to calling routine. Finished.
 3214/1544 : A8                         OUTZER:    XRA	A                    ;Clear the accumulator to restore zero digit value
 3215/1545 : 04 B0                      OUTDGX:    ADI	260o               ;Add 260 (octal) to BCD code in ACC to form ASCII
 3216/1547 : 46 82 03                              CALL	ECHO               ;Code and call the user's display driver subroutine
 3217/154A : 36 48                      DECRDG:    MVI	L, 110o               ;Set pointer to FIXED/FLOAT indicator storage
 3218/154C : C7                                    MOV	A,M                    ;Fetch the indicator to the accumulator
 3219/154D : A0                                    ANA	A                    ;Exercise the CPU flags
 3220/154E : 48 5F 15                              JNZ	CKDECP             ;If indicator non-zero, doing fixed point output
 3221/1551 : 36 47                                 MVI	L, 107o               ;Else, get output digit counter
 3222/1553 : D7                                    MOV	C,M
 3223/1554 : 11                                    DCR	C                    ;Decrement the digit counter & restore to storage
 3224/1555 : FA                                    MOV	M,C
 3225/1556 : 68 C0 15                              JZ	EXPOUT             ;When digit counter is zero, go take care of exponent
 3226/1559 : 46 93 15                   PUSHIT:    CALL	OUTX10             ;Else push next BCD digit out of working register
 3227/155C : 44 25 15                              JMP	OUTDGS             ;And continue the outputting process
 3228/155F : 36 6F                      CKDECP:    MVI	L, 157o               ;For fixed point output, decimal exponent serves as
 3229/1561 : D7                                    MOV	C,M                    ;Counter for number of digits before decimal point
 3230/1562 : 11                                    DCR	C                    ;Fetch the counter and decrement it to account for
 3231/1563 : FA                                    MOV	M,C                    ;Current digit being processed. Restore to storage.
 3232/1564 : 48 6C 15                              JNZ	NODECP             ;If count does not go to zero, jump ahead.
 3233/1567 : 06 AE                                 MVI	A, 256o               ;When count reaches zero, load ASCII code for period
 3234/1569 : 46 82 03                              CALL	ECHO               ;And call user's display driver to display decimal point
 3235/156C : 36 47                      NODECP:    MVI	L, 107o               ;Set pointer to output digit counter storage location
 3236/156E : D7                                    MOV	C,M                    ;Fetch the digit counter
 3237/156F : 11                                    DCR	C                    ;Decrement the value
 3238/1570 : FA                                    MOV	M,C                    ;Restore to storage
 3239/1571 : 2B                                    RZ                    ;If counter reaches zero, exit to caller. Finished.
 3240/1572 : 44 59 15                              JMP	PUSHIT             ;Else continue to output the number.
 3241/1575 : 36 6F                      ZERODG:    MVI	L, 157o               ;If first digit of floating point number is a zero, set
 3242/1577 : D7                                    MOV	C,M                    ;Pointer to decimal exponent storage location.
 3243/1578 : 11                                    DCR	C                    ;Decrement the value to compensate for skipping
 3244/1579 : FA                                    MOV	M,C                    ;Display of first digit. Restore to storage.
 3245/157A : 36 76                                 MVI	L, 166o               ;Change pointer to MSW of output working register
 3246/157C : C7                                    MOV	A,M                    ;Fetch MSW of output working register
 3247/157D : A0                                    ANA	A                    ;Test the contents
 3248/157E : 48 4A 15                              JNZ	DECRDG             ;If non-zero, continue outputting
 3249/1581 : 31                                    DCR	L                    ;Else decrement pointer to next byte in working register
 3250/1582 : C7                                    MOV	A,M                    ;Fetch its contents
 3251/1583 : A0                                    ANA	A                    ;Test
 3252/1584 : 48 4A 15                              JNZ	DECRDG             ;If non-zero, continue outputting
 3253/1587 : 31                                    DCR	L                    ;Else decrement pointer to LSW of working register
 3254/1588 : C7                                    MOV	A,M                    ;Fetch its contents
 3255/1589 : A0                                    ANA	A                    ;Test
 3256/158A : 48 4A 15                              JNZ	DECRDG             ;If non-zero, continue outputting
 3257/158D : 36 6F                                 MVI	L, 157o               ;If decimal mantissa is zero, set pointer to decirnal
 3258/158F : F8                                    MOV	M,A                    ;Exponent storage and clear it
 3259/1590 : 44 4A 15                              JMP	DECRDG             ;Finish outputting
 3260/1593 :                            
 3261/1593 :                                                              ;Following routine multiplies the binary number in the
 3262/1593 :                                                              ;output working register by ten to push the most signifi-
 3263/1593 :                                                              ;cant digit out to the MSW+L byte.
 3264/1593 :                            
 3265/1593 : 36 77                      OUTX10:    MVI	L, 167o               ;Set pointer to work ing register M SW+ 1
 3266/1595 : 3E 00                                 MVI	M, 000                ;Clear it in preparation for receiving next digit pushed
 3267/1597 : 36 74                                 MVI	L, 164o               ;Into it. Change pointer to working register LSW.
 3268/1599 : DD                                    MOV	D,H                    ;Set up register D to same page as H.
 3269/159A : 26 70                                 MVI	E, 160o               ;Set second pointer to LSW of second working register
 3270/159C : 0E 04                                 MVI	B, 004                ;Set precision counter
 3271/159E : 46 0B 11                              CALL	MOVEIT             ;Move first working register into second
 3272/15A1 : 36 74                                 MVI	L, 164o               ;Reset pointer to LSW of first working register
 3273/15A3 : 0E 04                                 MVI	B, 004                ;Set precision counter
 3274/15A5 : 46 7F 12                              CALL	ROTATL             ;Rotate contents of first working register left (X 2)
 3275/15A8 : 36 74                                 MVI	L, 164o               ;Reset pointer to LSW
 3276/15AA : 0E 04                                 MVI	B, 004                ;Reset precision counter
 3277/15AC : 46 7F 12                              CALL	ROTATL             ;Rotate contents left again (X 4)
 3278/15AF : 36 70                                 MVI	L, 160o               ;Set pointer to LSW of original value in 2'nd register
 3279/15B1 : 26 74                                 MVI	E, 164o               ;Set pointer to LSW of rotated value
 3280/15B3 : 0E 04                                 MVI	B, 004                ;Set precision counter
 3281/15B5 : 46 57 12                              CALL	ADDER              ;Add rotated value to original value (X 5)
 3282/15B8 : 36 74                                 MVI	L, 164o               ;Reset pointer to LSW of first working register
 3283/15BA : 0E 04                                 MVI	B, 004                ;Set precision counter
 3284/15BC : 46 7F 12                              CALL	ROTATL             ;Rotate contents left again (X 10)
 3285/15BF : 07                                    RET                    ;Exit to calling routine
 3286/15C0 :                            
 3287/15C0 :                                                              ;The final group of routines in the floating point output
 3288/15C0 :                                                              ;section take care of outputting the decimal exponent
 3289/15C0 :                                                              ;portion of floating point numbers.
 3290/15C0 :                            
 3291/15C0 : 36 6F                      EXPOUT:    MVI	L, 157o               ;Set pointer to decimal exponent storage location
 3292/15C2 : C7                                    MOV	A,M                    ;Fetch value to the accumulator
 3293/15C3 : A0                                    ANA	A                    ;Test the value
 3294/15C4 : 2B                                    RZ                    ;If zero, then no exponent portion. Exit to CALLler.
 3295/15C5 : 06 C5                                 MVI	A, 305o               ;Else, load ACC with ASCII code for letter E.
 3296/15C7 : 46 82 03                              CALL	ECHO               ;Display E for Exponent via user's display driver rtn
 3297/15CA : C7                                    MOV	A,M                    ;Get decimal exponent value back into ACC
 3298/15CB : A0                                    ANA	A                    ;Test again
 3299/15CC : 70 D4 15                              JM	EXOUTN             ;If value is negative, skip ahead
 3300/15CF : 06 AB                                 MVI	A, 253o               ;If positive, load ASCII code for + sign
 3301/15D1 : 44 DB 15                              JMP	AHEAD2             ;Jump to display the + sign
 3302/15D4 : 2C FF                      EXOUTN:    XRI	377o               ;When decimal exponent is negative, must negate
 3303/15D6 : 04 01                                 ADI	001                ;Value for display purposes. Perform two's complement
 3304/15D8 : F8                                    MOV	M,A                    ;And restore the negated value to storage location
 3305/15D9 : 06 AD                                 MVI	A, 255o               ;Load ASCII code for minus sign
 3306/15DB : 46 82 03                   AHEAD2:    CALL	ECHO               ;Display the ASCII character in ACC
 3307/15DE : 0E 00                                 MVI	B, 000                ;Clear register B
 3308/15E0 : C7                                    MOV	A,M                    ;Fetch the decimal exponent value back into ACC
 3309/15E1 : 14 0A                      SUB12:     SUI	012o               ;Subtract 10 (decimal) from value in ACC
 3310/15E3 : 70 EB 15                              JM	TOMUCH             ;Break out of loop when accumulator goes negative
 3311/15E6 : F8                                    MOV	M,A                    ;Else restore value to storage location
 3312/15E7 : 08                                    INR	B                    ;Increment register B as a counter
 3313/15E8 : 44 E1 15                              JMP	SUB12              ;Repeat loop to form tens value of decimal exponent
 3314/15EB : 06 B0                      TOMUCH:    MVI	A, 260o               ;Load base ASCII value for digit into the accumulator
 3315/15ED : 81                                    ADD	B                    ;Add to the count in B to forin tens digit of decimal
 3316/15EE : 46 82 03                              CALL	ECHO               ;Exponent. Display via user's driver subroutine
 3317/15F1 : C7                                    MOV	A,M                    ;Fetch remainder of decimal exponent value
 3318/15F2 : 04 B0                                 ADI	260o               ;Add in ASCII base value to form final digit
 3319/15F4 : 46 82 03                              CALL	ECHO               ;Display second digit of decirnal exponent
 3320/15F7 : 07                                    RET                    ;Finished outputting. Return to caller.
 3321/15F8 :                            ;;; The above RETURN SHOULD BE AT 25 367 15f7h
 3322/15F8 :                            
 3323/15F8 :                            ;;; NOW OPEN AREA UP TO 26 000 CAN BE USED FOR PATCHING...
 3324/15F8 :                            
 3325/15F8 :                            ;	db	(1600h-$) dup 0
 3326/15F8 :                            
 3327/1600 :                            	ORG	1600h	;026#000
 3328/1600 :                            
 3329/1600 : 00                         	db	0		;DATA 000		; CC FOR INPUT LINE BUFFER
 3330/1601 : 00 00 00 00 00 00 00 00 00 	db	79 dup (0)	;DATA *79 		; THE INPUT LINE BUFFER
      160A : 00 00 00 00 00 00 00 00 00
      1613 : 00 00 00 00 00 00 00 00 00
      161C : 00 00 00 00 00 00 00 00 00
      1625 : 00 00 00 00 00 00 00 00 00
      162E : 00 00 00 00 00 00 00 00 00
      1637 : 00 00 00 00 00 00 00 00 00
      1640 : 00 00 00 00 00 00 00 00 00
      1649 : 00 00 00 00 00 00 00      
 3331/1650 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000	; THESE ARE SYMBOL BUFFER STORAGE
 3332/1654 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000
 3333/1658 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000	; SHOULD BE 26-120 TO 26 143
 3334/165C : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000
 3335/1660 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000
 3336/1664 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000	; THESE LOCATIONS ARE AUXILIARY SYMBOL BUFFER
 3337/1668 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000
 3338/166C : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000	; SHOULD BE 26 144 TO 26 175
 3339/1670 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000
 3340/1674 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000
 3341/1678 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000
 3342/167C : 00 00                      	db	0,0		;DATA 000,000
 3343/167E : 00                         	db	0		;DATA 000		; TEMP SCAN STORAGE REGISTER
 3344/167F : 00                         	db	0		;DATA 000		; TAB FLAG
 3345/1680 : 00                         	db	0		;DATA 000		; EVAL CURRENT TEMP REG.
 3346/1681 : 00                         	db	0		;DATA 000		; SYNTAX LINE NUMBER
 3347/1682 : 00                         	db	0		;DATA 000		; SCAN TEMPORARY REGISTER
 3348/1683 : 00                         	db	0		;DATA 000		; STATEMENT TOKEN
 3349/1684 : 00 00                      	db	0,0		;DATA 000,000		; TEMPORARY WORKING REGISTERS
 3350/1686 : 00 00                      	db	0,0		;DATA 000,000		; ARRAY POINTERS
 3351/1688 :                            ;;; NOW WE SHOULD BE UP TO 26 210 1688h
 3352/1688 : 00                         	db	0		;DATA 000		; OPERATOR STACK POINTER
 3353/1689 : 00 00 00 00 00 00 00 00 00 	db	15 dup (0)	;DATA *15		; OPERATOR STACK
      1692 : 00 00 00 00 00 00         
 3354/1698 : 00                         	db	0		;DATA 000		; FUN/ARRAY STACK POINTER
 3355/1699 : 00 00 00 00 00 00 00       	db	7 dup (0)	;DATA *7			; FUNCTION/ARRAY STACK
 3356/16A0 :                            ;;; THE LAST BYTE SHOULD HAVE BEEN 26 237 169fh
 3357/16A0 :                            
 3358/16A0 :                            
 3359/16A0 :                            	;; HEIRARCHY TABLE (FOR OUT OF STACK OPS)
 3360/16A0 :                            	;; USED BY PARSER ROUTINE.
 3361/16A0 :                            ;;; This SHOULD START AT 26 240
 3362/16A0 : 00                         	db	0		;DATA 000		; EOS
 3363/16A1 : 03                         	db	3		;DATA 003		; PLUS SIGN
 3364/16A2 : 03                         	db	3		;DATA 003		; MINUS SIGN
 3365/16A3 : 04                         	db	4		;DATA 004		; MULTIPLICATION SIGN
 3366/16A4 : 04                         	db	4		;DATA 004		; DIVISION SIGN
 3367/16A5 : 05                         	db	5		;DATA 005		; EXPONENT SIGN
 3368/16A6 : 06                         	db	6		;DATA 006		; LEFT PARENTHESIS
 3369/16A7 : 01                         	db	1		;DATA 001		; RIGHT PARENTHESIS
 3370/16A8 : 02                         	db	2		;DATA 002		; NOT ASSIGNED
 3371/16A9 : 02                         	db	2		;DATA 002		; LESS THAN SIGN
 3372/16AA : 02                         	db	2		;DATA 002		; Equal sign
 3373/16AB : 02                         	db	2		;DATA 002		; GREATER THAN SIGN
 3374/16AC : 02                         	db	2		;DATA 002		; LESS THAN OR EQUAL COMBO
 3375/16AD : 02                         	db	2		;DATA 002		; EQUAL OR GREATER THAN
 3376/16AE : 02                         	db	2		;DATA 002		; LESS THAN OR GREATER THAN
 3377/16AF :                            
 3378/16AF :                            	;; HEIRARCHY TABLE (FOR INTO STACK OPS)
 3379/16AF :                            	;; USED BY PARSER ROUTINE.
 3380/16AF :                            ;;; This SHOULD START AT 26 257 16afh
 3381/16AF : 00                         	db	0		;DATA 000		; EOS
 3382/16B0 : 03                         	db	3		;DATA 003		; PLUS SIGN
 3383/16B1 : 03                         	db	3		;DATA 003		; MINUS SIGN
 3384/16B2 : 04                         	db	4		;DATA 004		; MULTIPLICATION SIGN
 3385/16B3 : 04                         	db	4		;DATA 004		; DIVISION SIGN
 3386/16B4 : 05                         	db	5		;DATA 005		; EXPONENTIATION SIGN
 3387/16B5 : 01                         	db	1		;DATA 001		; LEFT PARENTHESIS
 3388/16B6 : 01                         	db	1		;DATA 001		; RIGHT PARENTHESIS
 3389/16B7 : 02                         	db	2		;DATA 002		; NOT ASSIGNED
 3390/16B8 : 02                         	db	2		;DATA 002		; LESS THAN SIGN
 3391/16B9 : 02                         	db	2		;DATA 002		; EQUAL SIGN
 3392/16BA : 02                         	db	2		;DATA 002		; GREATER THAN SIGN
 3393/16BB : 02                         	db	2		;DATA 002		; LESS THAN OR EQUAL SIGN
 3394/16BC : 02                         	db	2		;DATA 002		; EQUAL TO OR GREATER THAN
 3395/16BD : 02                         	db	2		;DATA 002		; LESS THAN OR GREATER THAN
 3396/16BE :                            
 3397/16BE : 00                         	db	0		;DATA 000		; EVAL START POINTER
 3398/16BF : 00                         	db	0		;DATA 000		; EVAL FINISH POINTER
 3399/16C0 :                            
 3400/16C0 :                            	;; FUNCTION NAMES TABLE
 3401/16C0 :                            ;;; This SHOULD START AT 26 300 16c0h
 3402/16C0 :                            
 3403/16C0 : 03                         	db	3		;DATA 3
 3404/16C1 :                            ;	db	"INT"		;DATA "INT"
 3405/16C1 : C9                         	db	"I"+80h
 3406/16C2 : CE                         	db	"N"+80h
 3407/16C3 : D4                         	db	"T"+80h
 3408/16C4 : 03                         	db	3		;DATA 3
 3409/16C5 :                            ;	db	"SGN"		;DATA "SGN"
 3410/16C5 : D3                         	db	"S"+80h
 3411/16C6 : C7                         	db	"G"+80h
 3412/16C7 : CE                         	db	"N"+80h
 3413/16C8 : 03                         	db	3		;DATA 3
 3414/16C9 :                            ;	db	"ABS"		;DATA "ABS"
 3415/16C9 : C1                         	db	"A"+80h
 3416/16CA : C2                         	db	"B"+80h
 3417/16CB : D3                         	db	"S"+80h
 3418/16CC : 03                         	db	3		;DATA 3
 3419/16CD :                            ;	db	"SQR"		;DATA "SQR"
 3420/16CD : D3                         	db	"S"+80h
 3421/16CE : D1                         	db	"Q"+80h
 3422/16CF : D2                         	db	"R"+80h
 3423/16D0 : 03                         	db	3		;DATA 3
 3424/16D1 :                            ;	db	"TAB"		;DATA "TAB"
 3425/16D1 : D4                         	db	"T"+80h
 3426/16D2 : C1                         	db	"A"+80h
 3427/16D3 : C2                         	db	"B"+80h
 3428/16D4 : 03                         	db	3		;DATA 3
 3429/16D5 :                            ;	db	"RND"		;DATA "RND"
 3430/16D5 : D2                         	db	"R"+80h
 3431/16D6 : CE                         	db	"N"+80h
 3432/16D7 : C4                         	db	"D"+80h
 3433/16D8 : 03                         	db	3		;DATA 3
 3434/16D9 :                            ;	db	"CHR"		;DATA "CHR"
 3435/16D9 : C3                         	db	"C"+80h
 3436/16DA : C8                         	db	"H"+80h
 3437/16DB : D2                         	db	"R"+80h
 3438/16DC : 03                         	db	3		;DATA 3
 3439/16DD :                            ;	db	"UDF"		;DATA "UDF"
 3440/16DD : D5                         	db	"U"+80h
 3441/16DE : C4                         	db	"D"+80h
 3442/16DF : C6                         	db	"F"+80h
 3443/16E0 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000	; LINE NUMBER BUFFER STORAGE
 3444/16E4 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000	; (SHOULD BE 340-347)
 3445/16E8 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000	; AUX LINE NUMBER BUFFER
 3446/16EC : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000	; (SHOULD BE 350-357)
 3447/16F0 :                            ;;; The following data is a change in page 3 of Scelbal update issue 4
 3448/16F0 :                            ;;; which apparently makes the "INSERT" command work correctly, the
 3449/16F0 :                            ;;; first time (later SCR commands load 33 into this spot) 
 3450/16F0 : 1B                         	db	033o		;DATA 033 		; USER PGM LINE PTR (PG)
 3451/16F1 : 00                         	db	0		;DATA 000 		; USER PGM LINE PTR (LOW)
 3452/16F2 : 00                         	db	0		;DATA 000 		; AUX PGM LINE PTR (PG)
 3453/16F3 : 00                         	db	0		;DATA 000 		; AUX PGM LINE PTR (LOW)
 3454/16F4 : 00                         	db	0		;DATA 000 		; END OF USER PGM BUFFER PTR (PG)
 3455/16F5 : 00                         	db	0		;DATA 000 		; END OF USER PGM BUFFER PTR (LOW)
 3456/16F6 : 00                         	db	0		;DATA 000		; PARENTHESIS COUNTER (366)
 3457/16F7 : 00                         	db	0		;DATA 000		; QUOTE INDICATOR
 3458/16F8 : 00                         	db	0		;DATA 000		; TABLE COUNTER (370)
 3459/16F9 :                            ;;; locations 371-377 NOT ASSIGNED
 3460/16F9 :                            
 3461/16F9 :                            ;	db	(1700h-$) dup 0
 3462/16F9 :                            
 3463/1700 :                            	org	1700h		;ORG 027#000
 3464/1700 : 03                         	db	3		;DATA 3
 3465/1701 :                            ;	db	"REM"		;DATA "REM"
 3466/1701 : D2                         	db	"R"+80h
 3467/1702 : C5                         	db	"E"+80h
 3468/1703 : CD                         	db	"M"+80h
 3469/1704 : 02                         	db	2		;DATA 2
 3470/1705 :                            ;	db	"IF"		;DATA "IF"
 3471/1705 : C9                         	db	"I"+80h
 3472/1706 : C6                         	db	"F"+80h
 3473/1707 : 03                         	db	3		;DATA 3
 3474/1708 :                            ;	db	"LET"		;DATA "LET"
 3475/1708 : CC                         	db	"L"+80h
 3476/1709 : C5                         	db	"E"+80h
 3477/170A : D4                         	db	"T"+80h
 3478/170B : 04                         	db	4		;DATA 4
 3479/170C :                            ;	db	"GOTO"		;DATA "GOTO"
 3480/170C : C7                         	db	"G"+80h
 3481/170D : CF                         	db	"O"+80h
 3482/170E : D4                         	db	"T"+80h
 3483/170F : CF                         	db	"O"+80h
 3484/1710 : 05                         	db	5		;DATA 5
 3485/1711 :                            ;	db	"PRINT"		;DATA "PRINT"
 3486/1711 : D0                         	db	"P"+80h
 3487/1712 : D2                         	db	"R"+80h
 3488/1713 : C9                         	db	"I"+80h
 3489/1714 : CE                         	db	"N"+80h
 3490/1715 : D4                         	db	"T"+80h
 3491/1716 : 05                         	db	5		;DATA 5
 3492/1717 :                            ;	db	"INPUT"		;DATA "INPUT"
 3493/1717 : C9                         	db	"I"+80h
 3494/1718 : CE                         	db	"N"+80h
 3495/1719 : D0                         	db	"P"+80h
 3496/171A : D5                         	db	"U"+80h
 3497/171B : D4                         	db	"T"+80h
 3498/171C : 03                         	db	3		;DATA 3
 3499/171D :                            ;	db	"FOR"		;DATA "FOR"
 3500/171D : C6                         	db	"F"+80h
 3501/171E : CF                         	db	"O"+80h
 3502/171F : D2                         	db	"R"+80h
 3503/1720 : 04                         	db	4		;DATA 4
 3504/1721 :                            ;	db	"NEXT"		;DATA "NEXT"
 3505/1721 : CE                         	db	"N"+80h
 3506/1722 : C5                         	db	"E"+80h
 3507/1723 : D8                         	db	"X"+80h
 3508/1724 : D4                         	db	"T"+80h
 3509/1725 : 05                         	db	5		;DATA 5
 3510/1726 :                            ;	db	"GOSUB"		;DATA "GOSUB"
 3511/1726 : C7                         	db	"G"+80h
 3512/1727 : CF                         	db	"O"+80h
 3513/1728 : D3                         	db	"S"+80h
 3514/1729 : D5                         	db	"U"+80h
 3515/172A : C2                         	db	"B"+80h
 3516/172B : 06                         	db	6		;DATA 6
 3517/172C :                            ;	db	"RETURN"	;DATA "RETURN"
 3518/172C : D2                         	db	"R"+80h
 3519/172D : C5                         	db	"E"+80h
 3520/172E : D4                         	db	"T"+80h
 3521/172F : D5                         	db	"U"+80h
 3522/1730 : D2                         	db	"R"+80h
 3523/1731 : CE                         	db	"N"+80h
 3524/1732 : 03                         	db	3		;DATA 3
 3525/1733 :                            ;	db	"DIM"		;DATA "DIM"
 3526/1733 : C4                         	db	"D"+80h
 3527/1734 : C9                         	db	"I"+80h
 3528/1735 : CD                         	db	"M"+80h
 3529/1736 : 03                         	db	3		;DATA 3
 3530/1737 :                            ;	db	"END"		;DATA "END"
 3531/1737 : C5                         	db	"E"+80h
 3532/1738 : CE                         	db	"N"+80h
 3533/1739 : C4                         	db	"D"+80h
 3534/173A : 00                         	db	0		;DATA 0
 3535/173B :                            
 3536/173B :                            	; END OF TABLE, SHOULD BE 072 3ah
 3537/173B :                            
 3538/173B : 00                         	db	0		;DATA 000		; GOSUB STACK POINTER
 3539/173C : 00                         	db	0		;DATA *1			; NOT ASSIGNED;
 3540/173D : 00                         	db	0		;DATA 000		; NUMBER OF ARRAYS COUNTER
 3541/173E : 00                         	db	0		;DATA 000		; ARRAY POINTER
 3542/173F : 00                         	db	0		;DATA 000		; VARIABLES COUNTER SHOULD BE 077
 3543/1740 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000	; USED AS THE GOSUB STACK 100-117
 3544/1744 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000
 3545/1748 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000
 3546/174C : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000
 3547/1750 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000	; USED AS ARRAY VARIABLES TABLE
 3548/1754 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000	; SHOULD BE 120-137
 3549/1758 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000
 3550/175C : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000
 3551/1760 :                            
 3552/1760 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000	; USED FOR FOR/NEXT STACK STORAGE
 3553/1764 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000	; SHOULD BE 140 TO 177
 3554/1768 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000
 3555/176C : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000
 3556/1770 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000
 3557/1774 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000
 3558/1778 : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000
 3559/177C : 00 00 00 00                	db	0,0,0,0		;DATA 000,000,000,000
 3560/1780 : 00                         	db	0		;DATA 000		; FOR/NEXT STACK POINTER
 3561/1781 : 00                         	db	0		;DATA 000		; ARRAY/VARIABLE FLAG
 3562/1782 : 00                         	db	0		;DATA 000  		; STOSYM COUNTER
 3563/1783 : 00                         	db	0		;DATA 000		; FUN/ARRAY STACK POINTER (203
 3564/1784 : 00                         	db	0		;DATA 000		; ARRAY VALUES POINTER
 3565/1785 : 00 00 00                   	db	0,0,0		;DATA *3			; NOT USED (SHOULD BE 205-207)
 3566/1788 : 00                         	db	0		;DATA 000		; USED AS VARIABLES SYMBOL TABLE
 3567/1789 : 00 00 00 00 00 00 00 00 00 	db	119 dup (0)	;DATA *119		; (SHOULD BE 211-377 RESERVED)
      1792 : 00 00 00 00 00 00 00 00 00
      179B : 00 00 00 00 00 00 00 00 00
      17A4 : 00 00 00 00 00 00 00 00 00
      17AD : 00 00 00 00 00 00 00 00 00
      17B6 : 00 00 00 00 00 00 00 00 00
      17BF : 00 00 00 00 00 00 00 00 00
      17C8 : 00 00 00 00 00 00 00 00 00
      17D1 : 00 00 00 00 00 00 00 00 00
      17DA : 00 00 00 00 00 00 00 00 00
      17E3 : 00 00 00 00 00 00 00 00 00
      17EC : 00 00 00 00 00 00 00 00 00
      17F5 : 00 00 00 00 00 00 00 00 00
      17FE : 00 00                     
 3568/1800 :                            	;; THERE ARE NOW ADDRESSES AT START OF PAGE 30, NOT ASSIGNED;
 3569/1800 :                            
 3570/1800 :                            ;	db	(1800h-$) dup 0
 3571/1800 :                            
 3572/1800 :                            ;;; The following is PATCH NR.1
 3573/1800 :                                       ORG	1800h	;030#000
 3574/1800 : 36 53                      PATCH1:    MVI	L, 123o
 3575/1802 : 3E 00                                 MVI	M, 000
 3576/1804 : 36 5B                                 MVI	L, 133o
 3577/1806 : 3E 00                                 MVI	M, 000
 3578/1808 : 07                                    RET
 3579/1809 :                            
 3580/1809 :                            ;	db	(180bh-$) dup 0
 3581/1809 :                            
 3582/180B :                                       ORG 	180bh	;030#013
 3583/180B : 36 64                      NEXT:      MVI	L, 144o               ;Load L with start of AUX SYMBOL BUFFER
 3584/180D : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of AUX SYMBOL BUFFER
 3585/180F : 3E 00                                 MVI	M, 000                ;Initialize AUX SYMBOL BUFFER by clearing first byte
 3586/1811 : 36 82                                 MVI	L, 202o               ;Change L to address of SCAN pointer
 3587/1813 : CF                                    MOV	B,M                    ;Fetch pointer value to CPU register B
 3588/1814 : 08                                    INR	B                    ;Add one to the current pointer value
 3589/1815 : 36 81                                 MVI	L, 201o               ;Load L with address of NEXT pointer storage location
 3590/1817 : F9                                    MOV	M,B                    ;Place the updated SCAN pointer as the NEXT pointer
 3591/1818 : 36 81                      NEXT1:     MVI	L, 201o               ;Reset L to address of NEXT pointer storage location
 3592/181A : 46 A0 02                              CALL	GETCHR             ;Fetch the character pointed to by the NEXT pointer
 3593/181D : 68 25 18                              JZ	NEXT2              ;If the character is a space, ignore it
 3594/1820 : 36 64                                 MVI	L, 144o               ;Else, load L with start of AUX SYMBOL BUFFER
 3595/1822 : 46 CC 02                              CALL	CONCT1             ;Concatenate the character onto the AUX SYMBOL BF
 3596/1825 : 36 81                      NEXT2:     MVI	L, 201o               ;Reset L to address of NEXT pointer storage location
 3597/1827 : 46 03 03                              CALL	LOOP               ;Advance the NEXT pointer and see if end of line
 3598/182A : 48 18 18                              JNZ	NEXT1              ;Fetch next character in line if not end of line
 3599/182D : 36 64                                 MVI	L, 144o               ;When reach end of line, should have variable name
 3600/182F : C7                                    MOV	A,M                    ;In the AUX SYMBOL BUFFER. Fetch the (cc) for
 3601/1830 : 3C 01                                 CPI	001                ;The buffer and see if variable name is just one letter
 3602/1832 : 48 39 18                              JNZ	NEXT3              ;If more than one proceed directly to look for name
 3603/1835 : 36 66                                 MVI	L, 146o               ;In FOR/NEXT STACK. If have just a one letter name
 3604/1837 : 3E 00                                 MVI	M, 000                ;Then set second character in buffer to zero
 3605/1839 : 36 85                      NEXT3:     MVI	L, 205o               ;Load L with address of FOR/NEXT STACK pointer
 3606/183B : 2E 17                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Set H to page of FOR/NEXT STACK pointer
 3607/183D : C7                                    MOV	A,M                    ;Fetch the FOR/NEXT STACK pointer value to ACC
 3608/183E : 02                                    RLC                    ;Rotate value left to multiply by two. Then rotate it
 3609/183F : 02                                    RLC                    ;Left again to multiply by four. Add base address plus
 3610/1840 : 04 5E                                 ADI	136o               ;Two to form pointer to variable name in top of stack
 3611/1842 : 2E 17                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Set H to page of FOR/NEXT STACK
 3612/1844 : F0                                    MOV	L,A                    ;Move pointer value from ACC to CPU register L
 3613/1845 : 1E 16                                 MVI	D,PG26 ;\HB\OLDPG26   ;** Set register D to page of AUX SYMBOL BUFFER
 3614/1847 : 26 65                                 MVI	E, 145o               ;Set register E to first character in the buffer
 3615/1849 : 0E 02                                 MVI	B, 002                ;Set B to serve as a character counter
 3616/184B : 46 F8 02                              CALL	STRCPC             ;See if variable name in the NEXT statement same as
 3617/184E : 68 58 18                              JZ	NEXT4              ;That stored in the top of the FOR/NEXT STACK
 3618/1851 : 06 C6                      FORNXT:    MVI	A, 306o               ;Load ACC with ASCII code for letter F
 3619/1853 : 16 CE                                 MVI	C, 316o               ;Load register C with ASCII code for letter N
 3620/1855 : 44 96 02                              JMP	ERROR              ;Display For/Next (FN) error message if required
 3621/1858 : 36 F0                      NEXT4:     MVI	L, 360o               ;Load L with address of user program line pointer
 3622/185A : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of user pgm line pntr storage loc.
 3623/185C : DF                                    MOV	D,M                    ;Fetch the page portion of the line pointer into D
 3624/185D : 30                                    INR	L                    ;Advance the memory pointer
 3625/185E : E7                                    MOV	E,M                    ;Fetch the low portion of the line pointer into E
 3626/185F : 30                                    INR	L                    ;Advance pntr to AUXILIARY LINE POINTER storage
 3627/1860 : FB                                    MOV	M,D                    ;Location and store value of line pointer there too (page)
 3628/1861 : 30                                    INR	L                    ;Advance pointer to second byte of AUXILIARY line
 3629/1862 : FC                                    MOV	M,E                    ;Pointer and store value of line pointer (low portion)
 3630/1863 : 36 85                                 MVI	L, 205o               ;Load L with address of FOR/NEXT STACK pointer
 3631/1865 : 2E 17                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Set H to page of FOR/NEXT STACK pointer
 3632/1867 : C7                                    MOV	A,M                    ;Fetch the FOR/NEXT STACK pointer value to ACC
 3633/1868 : 02                                    RLC                    ;Rotate value left to multiply by two. Then rotate it
 3634/1869 : 02                                    RLC                    ;Left again to multiply by four. Add base address to
 3635/186A : 04 5C                                 ADI	134o               ;Form pointer to top of FOR/NEXT STACK and place
 3636/186C : F0                                    MOV	L,A                    ;The pointer value into CPU register L. Fetch the page
 3637/186D : DF                                    MOV	D,M                    ;Address of the associated FOR statement line pointer
 3638/186E : 30                                    INR	L                    ;Into register D. Advance the pointer and fetch the low
 3639/186F : E7                                    MOV	E,M                    ;Address value into register E. Prepare to change user
 3640/1870 : 36 F0                                 MVI	L, 360o               ;Program line pointer to the FOR statement line by
 3641/1872 : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Setting H & L to the user pgrn line pntr storage loc.
 3642/1874 : FB                                    MOV	M,D                    ;Place the page value in the pointer storage location
 3643/1875 : 30                                    INR	L                    ;Advance the memory pointer
 3644/1876 : FC                                    MOV	M,E                    ;Place the low value in the pointer storage location
 3645/1877 : EB                                    MOV	H,D                    ;Now set up H and L to point to the start of the
 3646/1878 : F4                                    MOV	L,E                    ;Associated FOR statement line in the user pgm buffer
 3647/1879 : 1E 16                                 MVI	D,PG26 ;\HB\OLDPG26   ;** Change D to point to the line input buffer
 3648/187B : 26 00                                 MVI	E, 000                ;And set L to the gtart of the line input buffer
 3649/187D : 46 26 0A                              CALL	MOVEC              ;Move the associated FOR statement line into the input
 3650/1880 : 36 D5                                 MVI	L, 325o               ;Line buffer. Set L to point to start of TO string which is
 3651/1882 : 2E 01                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Stored in a text strings storage area on this page
 3652/1884 : 46 0A 0B                              CALL	INSTR              ;Search the statement line for the occurrence of TO
 3653/1887 : C4                                    MOV	A,E                    ;Register E will be zero if TO not found. Move E to ACC
 3654/1888 : A0                                    ANA	A                    ;To make a test. If TO found then proceed to set up for
 3655/1889 : 68 51 18                              JZ	FORNXT             ;Evaluation. If TO not found, then have error condition.
 3656/188C : 04 02                                 ADI	002                ;Advance the pointer over the characters in TO string
 3657/188E : 36 BE                                 MVI	L, 276o               ;Change L to point to EVAL pointer storage location
 3658/1890 : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of EVAL pointer. Set up the starting
 3659/1892 : F8                                    MOV	M,A                    ;Position for the EVAL subroutine (after TO string)
 3660/1893 : 36 D8                                 MVI	L, 330o               ;Set L to point to start of STEP string which is stored
 3661/1895 : 2E 01                                 MVI	H,PG01 ;\HB\OLDPG1    ;** In text stxings storage area on this page. Search the
 3662/1897 : 46 0A 0B                              CALL	INSTR              ;Statement line for the occurrence of STEP
 3663/189A : C4                                    MOV	A,E                    ;Register E will be zero if STEP not found. Move E to
 3664/189B : A0                                    ANA	A                    ;The accumulator to make a test. If STEP found must
 3665/189C : 48 C0 18                              JNZ	NEXT5              ;Evaluate expression after STEP to get STEP SIZE.
 3666/189F : 36 04                                 MVI	L, 004                ;Else, have an IMPLIED STEP SIZE of 1.0. Set pointer
 3667/18A1 : 2E 01                                 MVI	H,PG01 ;\HB\OLDPG1    ;** To start of storage area for 1.0 in floating point
 3668/18A3 : 46 A4 12                              CALL	FLOAD              ;Format and call subroutine to load FPACC with 1.0
 3669/18A6 : 36 C4                                 MVI	L, 304o               ;Set L to start of FOR/NEXT STEP SIZE storage loc.
 3670/18A8 : 46 AD 12                              CALL	FSTORE             ;Store the value 1.0 in the F/N STEP SIZE registers
 3671/18AB : 36 00                                 MVI	L, 000                ;Change L to the start of the input line buffer
 3672/18AD : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to the page of the input line buffer
 3673/18AF : CF                                    MOV	B,M                    ;Fetch the (cc) into CPU register B (length of FOR line)
 3674/18B0 : 36 BF                                 MVI	L, 277o               ;Change L to EVAL FINISH pointer stomge location
 3675/18B2 : F9                                    MOV	M,B                    ;Set the EVAL FINISH pointer to the end of the line
 3676/18B3 : 46 94 03                              CALL	EVAL               ;Evaluate the LIMIT expression to obtain FOR LIMIT
 3677/18B6 : 36 C8                                 MVI	L, 310o               ;Load L with address of start of F/N LIMIT registers
 3678/18B8 : 2E 01                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Load H with page of FOR/NEXT LIMIT registers
 3679/18BA : 46 AD 12                              CALL	FSTORE  ;MGA 3/31/12 no lab here Store the FOR/NEXT LIMIT value
 3680/18BD : 44 E9 18                              JMP	NEXT6              ;Since have IMPLIED STEP jump ahead
 3681/18C0 : 21                         NEXT5:     DCR	E  ;MGA 3/21/12 lab here When have STEP directive, subtract one from pointer
 3682/18C1 : 36 BF                                 MVI	L, 277o               ;To get to character before S in STEP. Save this value in
 3683/18C3 : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** The EVAL FINISH pointer stomge location to serve
 3684/18C5 : FC                                    MOV	M,E                    ;As evaluation end location when obtaining TO Iiinit
 3685/18C6 : 46 94 03                              CALL	EVAL               ;Evaluate the LIMIT expression to obtain FOR LIMIT
 3686/18C9 : 36 C8                                 MVI	L, 310o               ;Load L with address of start of FIN LIMIT registers
 3687/18CB : 2E 01                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Load H with page of FORINEXT LIMIT registers
 3688/18CD : 46 AD 12                              CALL	FSTORE             ;Store the FOR/NEXT LIMIT value
 3689/18D0 : 36 BF                                 MVI	L, 277o               ;Reset L to EVAL FINISH pointer storage location
 3690/18D2 : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of EVAL FINISH pointer storage loc.
 3691/18D4 : C7                                    MOV	A,M                    ;Fetch the pointer value (character before S in STEP)
 3692/18D5 : 04 05                                 ADI	005                ;Add five to change pointer to character after P in STEP
 3693/18D7 : 31                                    DCR	L                    ;Decrement L to point to EVAL (start) pointer
 3694/18D8 : F8                                    MOV	M,A                    ;Set up the starting position for the EVAL subroutine
 3695/18D9 : 36 00                                 MVI	L, 000                ; Load L with starting address of the line input buffer
 3696/18DB : CF                                    MOV	B,M                    ;Fetch the (cc) for the line input buffer (line length)
 3697/18DC : 36 BF                                 MVI	L, 277o               ;Change L to the EVAL FINISH storage location
 3698/18DE : F9                                    MOV	M,B                    ;Set the EVAL FINISH pointer
 3699/18DF : 46 94 03                              CALL	EVAL               ;Evaluate the STEP SIZE expression
 3700/18E2 : 36 C4                                 MVI	L, 304o               ;Load L with address of start of F/N STEP registers
 3701/18E4 : 2E 01                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to page of FIN STEP registers
 3702/18E6 : 46 AD 12                              CALL	FSTORE             ;Store the FOR/NEXT STEP SIZE value
 3703/18E9 : 36 64                      NEXT6:     MVI	L, 144o               ;Load L with address of AUX SYMBOL BUFFER
 3704/18EB : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of the AUX SYMBOL BUFFER
 3705/18ED : 3E 00                                 MVI	M, 000                ;Initialize AUX SUMBOL BUFFER with a zero byte
 3706/18EF : 36 1C                                 MVI	L, 034o               ;Set L to start of FOR string which is stored in the
 3707/18F1 : 2E 17                                 MVI	H,PG27 ;\HB\OLDPG27   ;** KEYWORD look-up table on this page
 3708/18F3 : 46 0A 0B                              CALL	INSTR              ;Search the statement line for the FOR directive
 3709/18F6 : C4                                    MOV	A,E                    ;Register E will be zero if FOR not found. Move E to
 3710/18F7 : A0                                    ANA	A                    ;ACC and -make test to see if FOR directive located
 3711/18F8 : 36 82                                 MVI	L, 202o               ;Load L with address of SCAN pointer
 3712/18FA : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of SCAN pointer
 3713/18FC : F8                                    MOV	M,A                    ;Set up pointer to occurrence of FOR directive in line
 3714/18FD : 68 51 18                              JZ	FORNXT             ;If FOR not found, have an error condition
 3715/1900 : 04 03                                 ADI	003                ;If have FOR, add three to advance pointer over FOR
 3716/1902 : 36 83                                 MVI	L, 203o               ;Set L to point to F/N pointer storage location
 3717/1904 : F8                                    MOV	M,A                    ;Set F/N pointer to character after FOR directive
 3718/1905 : 36 83                      NEXT7:     MVI	L, 203o               ;Set L to point to FIN pointer storage location
 3719/1907 : 46 A0 02                              CALL	GETCHR             ;Fetch a character from position pointed to by FIN pntr
 3720/190A : 68 17 19                              JZ	NEXT8              ;If character is a space, ignore it
 3721/190D : 3C BD                                 CPI	275o               ;Else, test to see if character is "=" sign
 3722/190F : 68 22 19                              JZ	NEXT9              ;If yes, have picked up variable name, jump ahead
 3723/1912 : 36 64                                 MVI	L, 144o               ;If not, set L to the start of the AUX SYMBOL BUFFER
 3724/1914 : 46 CC 02                              CALL	CONCT1             ;And store the character in the AUX SYMBOL BUFFER
 3725/1917 : 36 83                      NEXT8:     MVI	L, 203o               ;Load L with address of the F/N pointer
 3726/1919 : 46 03 03                              CALL	LOOP               ;Increment the pointer and see if end of the line
 3727/191C : 48 05 19                              JNZ	NEXT7              ;If not, continue fetching characters
 3728/191F : 44 51 18                              JMP	FORNXT             ;If end of line before "=" sign then have error condx
 3729/1922 : 36 82                      NEXT9:     MVI	L, 202o               ;Load L with address of SCAN pointer
 3730/1924 : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of SCAN pointer
 3731/1926 : C7                                    MOV	A,M                    ;Fetch pointer value to ACC (points to start of FOR
 3732/1927 : 04 03                                 ADI	003                ;Directive) and add three to move pointer over FOR
 3733/1929 : 36 BE                                 MVI	L, 276o               ;Directive. Change L to EVAL pointer storage location
 3734/192B : F8                                    MOV	M,A                    ;Set EVAL pointer to character after FOR in line
 3735/192C : 36 83                                 MVI	L, 203o               ;Load L with address of FIN pointer storage location
 3736/192E : CF                                    MOV	B,M                    ;Fetch pointer to register B (points to "=" sign) and
 3737/192F : 09                                    DCR	B                    ;Decrement the pointer (to character before "=" sign)
 3738/1930 : 36 BF                                 MVI	L, 277o               ;Load L with address of EVAL FINISH pointer
 3739/1932 : F9                                    MOV	M,B                    ;Set EVAL FINISH pointer
 3740/1933 : 46 94 03                              CALL	EVAL               ;Call subroutine to obtain current value of the variable
 3741/1936 : 36 C4                                 MVI	L, 304o               ;Load L with address of start of F/N STEP registers
 3742/1938 : 2E 01                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to page of F/N STEP registers
 3743/193A : 46 BF 12                              CALL	FACXOP             ;Call subroutine to set up FP registers for addition
 3744/193D : 46 89 10                              CALL	FPADD              ;Add FIN STEP size to current VARIABLE value
 3745/1940 : 36 CC                                 MVI	L, 314o               ;Load L with address of FIN TEMP storage registers
 3746/1942 : 2E 01                                 MVI	H,PG01 ;\HB\OLDPG1    ;**Set H to page of FIN TEMP storage registers
 3747/1944 : 46 AD 12                              CALL	FSTORE             ;Save the result of the addition in F/N TEMP registers
 3748/1947 : 36 C8                                 MVI	L, 310o               ;Load L with starting address of F/N LIMIT registers
 3749/1949 : 46 BF 12                              CALL	FACXOP             ;Call subroutine to set up FP registers for subtraction
 3750/194C : 46 1A 11                              CALL	FPSUB              ;Subtract F/N LIMIT value from VARIABLE value
 3751/194F : 36 C6                                 MVI	L, 306o               ;Set pointer to MSW of F/N STEP registers
 3752/1951 : C7                                    MOV	A,M                    ;Fetch this value into the ACC
 3753/1952 : A0                                    ANA	A                    ;Test to see if STEP value might be zero
 3754/1953 : 36 56                                 MVI	L, 126o               ;Load L with address of MSW of FPACC
 3755/1955 : C7                                    MOV	A,M                    ;Fetch this value into the ACC
 3756/1956 : 68 51 18                              JZ	FORNXT             ;If STEP size was zero, then endless loop, an error condx
 3757/1959 : 70 78 19                              JM	NEXT11             ;If STEP size less than zero make alternate test on limit
 3758/195C : A0                                    ANA	A                    ;Test the contents of the MSW of the FPACC
 3759/195D : 70 7F 19                              JM	NEXT12             ;Continue FORINEXT loop if current variable value is
 3760/1960 : 68 7F 19                              JZ	NEXT12             ;Less than or equal to the F/N LIMIT value
 3761/1963 : 36 F3                      NEXT10:    MVI	L, 363o               ;If out of LIMIT range, load L with address of the AUX
 3762/1965 : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** PGM LINE pointer. (Contains pointer to the NEXT
 3763/1967 : E7                                    MOV	E,M                    ;Statement line that initiated this routine.) Fetch the
 3764/1968 : 31                                    DCR	L                    ;Low part of the address into E, decrement the memory
 3765/1969 : DF                                    MOV	D,M                    ;And get the page part of the address into CPU register
 3766/196A : 31                                    DCR	L                    ;Decrement memory pointer to the low portion of the
 3767/196B : FC                                    MOV	M,E                    ;User pgm buffer line pointer (regular pointer) and set it
 3768/196C : 31                                    DCR	L                    ;With the value from the AUX line pntr, decrement the
 3769/196D : FB                                    MOV	M,D                    ;Pointer and do the same for the page portion
 3770/196E : 36 85                                 MVI	L, 205o               ;Set L to address of FOR/NEXT STACK pointer
 3771/1970 : 2E 17                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Set H to page of FOR/NEXT STACK pointer
 3772/1972 : CF                                    MOV	B,M                    ;Fetch and decrement the
 3773/1973 : 09                                    DCR	B                    ;FOR/NEXT STACK pointer value
 3774/1974 : F9                                    MOV	M,B                    ;To perform effective popping operation
 3775/1975 : 44 4E 0B                              JMP	NXTLIN             ;Statement line after NEXT statement is done next
 3776/1978 : A0                         NEXT11:    ANA	A                    ;When F/N STEP is negative, reverse test so that if the
 3777/1979 : 50 7F 19                              JP	NEXT12             ;Variable value is greater than or equal to the F/N LIMIT
 3778/197C : 44 63 19                              JMP	NEXT10             ;The FOR/NEXT loop continues. Else it is finished.
 3779/197F : 36 CC                      NEXT12:    MVI	L, 314o               ;Load L with address of FIN TEMP storage registers
 3780/1981 : 2E 01                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to FIN TEMP storage registers page
 3781/1983 : 46 A4 12                              CALL	FLOAD              ;Transfer the updated variable value to the FPACC
 3782/1986 : 46 AA 08                              CALL	RESTSY             ;Restore the variable name and value
 3783/1989 : 46 2D 08                              CALL	STOSYM             ;In the VARIABLES table. Exit routine so that
 3784/198C : 44 4E 0B                              JMP	NXTLIN             ;Statement line after FOR statement is done next
 3785/198F :                            
 3786/198F :                            ;;; The label BACKSP SHOULD BE AT 31 217 198fh
 3787/198F :                            
 3788/198F : 06 8D                      BACKSP:    MVI	A, 215o               ;Load ASCII code for carriage-return into the ACC
 3789/1991 : 46 82 03                              CALL	ECHO               ;Display the carriage-return
 3790/1994 : 46 82 03                              CALL	ECHO               ;Repeat to provide extra time if TTY
 3791/1997 : 36 23                                 MVI	L, 043o               ;Load L with address of COLUMN COUNTER
 3792/1999 : 2E 01                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to page of COLUMN COUNTER
 3793/199B : 3E 01                                 MVI	M, 001                ;Set COLUMN COUNTER to first column
 3794/199D : 36 54                                 MVI	L, 124o               ;Set L to address containing desired TAB position
 3795/199F : C7                                    MOV	A,M                    ;Fetch the desired TAB position value
 3796/19A0 : A0                                    ANA	A                    ;Test to see if it is
 3797/19A1 : 33                                    RM                    ;Negative or zero
 3798/19A2 : 2B                                    RZ                    ;In which case return to caller
 3799/19A3 : 44 12 08                              JMP	TAB1               ;Else, proceed to perform the TAB operation.
 3800/19A6 :                            
 3801/19A6 :                            	
 3802/19A6 :                            ;;; The label FOR5 SHOULD START AT 31 246 19a6h
 3803/19A6 :                            	
 3804/19A6 : 36 85                      FOR5:      MVI	L, 205o               ;Load L with address of the FOR/NEXT STACK pointer
 3805/19A8 : 2E 17                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Load H with page of the FOR/NEXT STACK pntr
 3806/19AA : C7                                    MOV	A,M                    ;Fetch the stack pointer to the ACC.
 3807/19AB : 02                                    RLC                    ;Rotate it left to multiply by two, then rotate it again to
 3808/19AC : 02                                    RLC                    ;Multiply by four. Add this value to the base address
 3809/19AD : 04 5E                                 ADI	136o               ;Plus two of the base address to point to the next part of
 3810/19AF : E0                                    MOV	E,A                    ;The FOR/NEXT STACK. Place this value in register E.
 3811/19B0 : DD                                    MOV	D,H                    ;Set D to the FORINEXT STACK area page.
 3812/19B1 : 36 65                                 MVI	L, 145o               ;Load L with the address of the first character in the
 3813/19B3 : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** AUX SYMBOL BUFFER and set up H to this page.
 3814/19B5 : 0E 02                                 MVI	B, 002                ;Set up register B as a number of bytes to move counter.
 3815/19B7 : 46 0B 11                              CALL	MOVEIT             ;Move the variable name into the FOR/NEXT STACK.
 3816/19BA : 46 2D 08                              CALL	STOSYM             ;Store initial variable value in the VARIABLES TABLE.
 3817/19BD : 44 4E 0B                              JMP	NXTLIN             ;Continue with next line in user program buffer.
 3818/19C0 :                            
 3819/19C0 :                            
 3820/19C0 :                            ;;; The label PARSEP SHOULD START AT 31 300 19c0h
 3821/19C0 : 36 7E                      PARSEP:    MVI	L, 176o               ;Load L with PARSER TOKEN storage location. Set
 3822/19C2 : 3E 00                                 MVI	M, 000                ;The value indicating end of expression. Call the
 3823/19C4 : 46 D4 04                              CALL	PARSER             ;PARSER subroutine for final time for the expression.
 3824/19C7 : 36 97                                 MVI	L, 227o               ;Change L to point to the ARITH STACK pointer.
 3825/19C9 : 2E 01                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to the page of the ARITH STACK pointer.
 3826/19CB : C7                                    MOV	A,M                    ;Fetch the ARITH STACK pointer value.
 3827/19CC : 3C 98                                 CPI	230o               ;Should indicate only one value (answer) in stack.
 3828/19CE : 2B                                    RZ                    ;Exit with answer in FPACC if ARITH STACK is O.K.
 3829/19CF : 44 6A 09                              JMP	SYNERR             ;Else have a syntax error!
 3830/19D2 :                            
 3831/19D2 :                            
 3832/19D2 :                            ;;; THERE IS SOME BLANK ADDRESSES HERE 317-NEXT PAGE
 3833/19D2 :                            
 3834/19D2 :                            ;	db	(1a00h-$) dup 0
 3835/19D2 :                            
 3836/1A00 :                                       ORG	1a00h	; 032#000
 3837/1A00 : 36 0C                      SQRX:      MVI	L, 014o               ;Load L with address of FP TEMP registers
 3838/1A02 : 2E 01                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to page of FP TEMP. Move contents of FPACC
 3839/1A04 : 46 AD 12                              CALL	FSTORE             ;[Argument of SQR(X)] into FP TEMP for storage.
 3840/1A07 : 36 56                                 MVI	L, 126o               ;Load L with MSW of FPACC
 3841/1A09 : C7                                    MOV	A,M                    ;Fetch the MSW into the accumulator
 3842/1A0A : A0                                    ANA	A                    ;Check the sign of the number in the FPACC
 3843/1A0B : 70 8F 1A                              JM	SQRERR             ;If number negative, cannot take square root
 3844/1A0E : 68 A7 06                              JZ	CFALSE             ;If number is zero, return with zero value in FPACC
 3845/1A11 : 36 0F                                 MVI	L, 017o               ;Load L with address of FP TEMP Exponent register
 3846/1A13 : C7                                    MOV	A,M                    ;Fetch the Exponent value into the ACC
 3847/1A14 : A0                                    ANA	A                    ;Check sign of the Fxponent
 3848/1A15 : 70 21 1A                              JM	NEGEXP             ;If Exponent less than zero, process negative Exponent
 3849/1A18 : 1A                                    RAR                    ;If Exponent positive, rotate right to divide by two
 3850/1A19 : C8                                    MOV	B,A                    ;And save the result in CPU register B
 3851/1A1A : 06 00                                 MVI	A, 000                ;Clear the accumulator without disturbing Carry bit
 3852/1A1C : 12                                    RAL                    ;Rotate Carry bit into the ACC to save remainder
 3853/1A1D : F8                                    MOV	M,A                    ;Store the remainder back in FP TEMP Exponent reg.
 3854/1A1E : 44 32 1A                              JMP	SQREXP             ;Jump to continue processing
 3855/1A21 : C8                         NEGEXP:    MOV	B,A                    ;For negative Exponent, form two Is complement by
 3856/1A22 : A8                                    XRA	A                    ;Placing the positive value in CPU register B, clearing
 3857/1A23 : 91                                    SUB	B                    ;The accumulator, and then subtracting B from the ACC
 3858/1A24 : A0                                    ANA	A                    ;Clear the Carry bit after the complementing operation
 3859/1A25 : 1A                                    RAR                    ;Rotate the value right to divide by two
 3860/1A26 : C8                                    MOV	B,A                    ;Save the result in CPU register B
 3861/1A27 : 06 00                                 MVI	A, 000                ;Clear the accumulator without disturbing Carry bit
 3862/1A29 : 88                                    ADC	A                    ;Add Carry bit to the accumulator as remainder
 3863/1A2A : F8                                    MOV	M,A                    ;Store the remainder back in FP TEMP Exponent reg
 3864/1A2B : 68 2F 1A                              JZ	NOREMD             ;If remainder was zero skip ahead. If not, increment the
 3865/1A2E : 08                                    INR	B                    ;Result of the divide by two ops to compen for negative
 3866/1A2F : A8                         NOREMD:    XRA	A                    ;Clear the accumulator
 3867/1A30 : 91                                    SUB	B                    ;Subtract the quotient of the divide by two op to
 3868/1A31 : C8                                    MOV	B,A                    ;Form two's complement and save the result in register B
 3869/1A32 : 36 0B                      SQREXP:    MVI	L, 013o               ;Load L with address of TEMP register
 3870/1A34 : F9                                    MOV	M,B                    ;Store Fxponent quotient from above ops in TEMP
 3871/1A35 : 36 04                                 MVI	L, 004                ;Load L with address of FP registers containing +1.0
 3872/1A37 : 26 1C                                 MVI	E, 034o               ;Load E with address of SQR APPROX working registers
 3873/1A39 : DD                                    MOV	D,H                    ;Set D to same page as H
 3874/1A3A : 0E 04                                 MVI	B, 004                ;Set up register B as a number of bytes to move counter
 3875/1A3C : 46 0B 11                              CALL	MOVEIT             ;Transfer value +1.0 into SQR APPROX registers
 3876/1A3F : 46 A7 06                              CALL	CFALSE             ;Now clear the FPACC registers
 3877/1A42 : 36 24                                 MVI	L, 044o               ;Load L with address of LAST SQR APPROX temp regs.
 3878/1A44 : 46 AD 12                              CALL	FSTORE             ;Initialize the LAST SQR APPROX regs to value of zero
 3879/1A47 : 36 1C                      SQRLOP:    MVI	L, 034o               ;Load L with address of SQR APPROX working registers
 3880/1A49 : 46 A4 12                              CALL	FLOAD              ;Transfer SQR APPROX into the FPACC
 3881/1A4C : 36 0C                                 MVI	L, 014o               ;Load L with address of SQR ARG storage registers
 3882/1A4E : 46 B6 12                              CALL	OPLOAD             ;Transfer SQR ARG into the FPOP
 3883/1A51 : 46 D2 11                              CALL	FPDIV              ;Divde SQR ARG by SQR APPROX (Fon-n X/A)
 3884/1A54 : 36 1C                                 MVI	L, 034o               ;Load L with address of SQR APPROX registers
 3885/1A56 : 46 B6 12                              CALL	OPLOAD             ;Transfer SQR APPROX into the FPOP
 3886/1A59 : 46 89 10                              CALL	FPADD              ;Add to form value (X/A + A)
 3887/1A5C : 36 57                                 MVI	L, 127o               ;Load L with address of FPACC Exponent register
 3888/1A5E : CF                                    MOV	B,M                    ;Fetch Exponent value into CPU register B
 3889/1A5F : 09                                    DCR	B                    ;Subtract one to effectively divide FPACC by two
 3890/1A60 : F9                                    MOV	M,B                    ;Restore to memory. (Now have ((X/A + A) /2)
 3891/1A61 : 36 1C                                 MVI	L, 034o               ;Load L with address of SQR APPROX registers
 3892/1A63 : 46 AD 12                              CALL	FSTORE             ;Store contents of FPACC as new SQR APPROX
 3893/1A66 : 36 24                                 MVI	L, 044o               ;Load L with address of LAST SQR APPROX registers
 3894/1A68 : 46 B6 12                              CALL	OPLOAD             ;Transfer LAST SQR APPROX into the FPOP
 3895/1A6B : 46 1A 11                              CALL	FPSUB              ;Subtract (LAST SQR APPROX - SQR APPROX)
 3896/1A6E : 36 57                                 MVI	L, 127o               ;Load L with address of FPACC Exponent
 3897/1A70 : C7                                    MOV	A,M                    ;Fetch the Exponent into the accumulator
 3898/1A71 : 3C F7                                 CPI	367o                ;See if difference less than 2 to the minus ninth
 3899/1A73 :                            ;;; The below is changed for PATCH 2
 3900/1A73 :                            ;;; following is the original code
 3901/1A73 :                            ;;;           JTS SQRCNV             ;If so, approximation has converged
 3902/1A73 :                            ;;; Now is the new line
 3903/1A73 : 44 F4 1A                   	   JMP	PATCH2
 3904/1A76 :                            ;;;;           DCR L
 3905/1A76 :                            ;;;;           MOV A,M
 3906/1A76 :                            ;;;;           ANA A
 3907/1A76 :                            ;;;;           JZ SQRCNV             ;THIS IS PATCH #2
 3908/1A76 : 36 1C                      SQR1:	   MVI	L, 034o               ;Else, load L with address of SQR APPROX
 3909/1A78 : DD                                    MOV	D,H                    ;Set D to same page as H
 3910/1A79 : 26 24                                 MVI	E, 044o               ;And E with address of LAST SQR APPROX
 3911/1A7B : 0E 04                                 MVI	B, 004o               ;Set up register B as a number of bytes to move counter
 3912/1A7D : 46 0B 11                              CALL	MOVEIT             ;Transfer SQR APPROX into LAST SQR APPROX
 3913/1A80 : 44 47 1A                              JMP	SQRLOP             ;Continue ops until approximation converges
 3914/1A83 : 36 0B                      SQRCNV:    MVI	L, 013o               ;Load L with address of TEMP register. Fetch the
 3915/1A85 : C7                                    MOV	A,M                    ;Exponenent quotient store there into accumulator.
 3916/1A86 : 36 1F                                 MVI	L, 037o               ;Change L to point to SQR APPROX exponent.
 3917/1A88 : 87                                    ADD	M                    ;Add SQR APPROX exponent to quotient value.
 3918/1A89 : F8                                    MOV	M,A                    ;Store sum back in SQR APPROX Exponent register.
 3919/1A8A : 36 1C                                 MVI	L, 034o               ;Load L with address of SQR APPROX. Transfer the
 3920/1A8C : 44 A4 12                              JMP	FLOAD              ;SQR APPROX into FPACC as answer and exit.
 3921/1A8F : 06 D3                      SQRERR:    MVI	A, 323o               ;Load ASCII code for letter S into the accumulator.
 3922/1A91 : 16 D1                                 MVI	C, 321o               ;Load ASCII code for letter Q into CPU register C.
 3923/1A93 : 44 96 02                              JMP	ERROR              ;Display the SQuare root (SQ) error message.
 3924/1A96 :                            ;;; above instruction starts at 223
 3925/1A96 :                            ;;; some blank addresses available here.
 3926/1A96 :                            
 3927/1A96 :                            ;	db	(1aa0h-$) dup 0
 3928/1A96 :                            
 3929/1AA0 :                                       ORG	1aa0h              ; 032#240
 3930/1AA0 : 36 34                      RNDX:      MVI	L, 064o               ;Load L with address of SEED storage registers
 3931/1AA2 : 2E 01                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to page for floating point working registers
 3932/1AA4 : 46 A4 12                              CALL	FLOAD              ;Transfer SEED into the FPACC
 3933/1AA7 : 36 28                                 MVI	L, 050o               ;Load L with address of random constant A
 3934/1AA9 : 46 B6 12                              CALL	OPLOAD             ;Transfer random constant A into the FPOP
 3935/1AAC : 46 26 11                              CALL	FPMULT             ;Multiply to form (SEED * A)
 3936/1AAF : 36 30                                 MVI	L, 060o               ;Load L with address of random constant C
 3937/1AB1 : 46 B6 12                              CALL	OPLOAD             ;Transfer random constant C into the FPOP
 3938/1AB4 : 46 89 10                              CALL	FPADD              ;Add to fom (SEED * A) + C
 3939/1AB7 : 36 34                                 MVI	L, 064o               ;Load L with address of SEED storage registers
 3940/1AB9 : 46 AD 12                              CALL	FSTORE             ;Store I (SEED * A) + C] in former SEED registers
 3941/1ABC : 36 57                                 MVI	L, 127o               ;Load L with address of FPACC Exponent register
 3942/1ABE : C7                                    MOV	A,M                    ;Fetch Exponent value into the accumulator
 3943/1ABF : 14 10                                 SUI	020o               ;Subtract 16 (decimal) to effectively divide by 65,536
 3944/1AC1 : F8                                    MOV	M,A                    ;Now FPACC = [((SEED * A) + C)/65,536]
 3945/1AC2 : 46 00 10                              CALL	FPFIX              ;Convert floating to fixed point to obtain integer part
 3946/1AC5 : 36 53                                 MVI	L, 123o               ;Load L with address of FPACC Extension register
 3947/1AC7 : 3E 00                                 MVI	M, 000                ;Clear the FPACC Extension register
 3948/1AC9 : 36 57                                 MVI	L, 127o               ;Load L with address of FPACC Exponent
 3949/1ACB : 3E 00                                 MVI	M, 000                ;Clear the FPACC Exponent register
 3950/1ACD : 46 34 10                              CALL	FPFLT              ;Fetch INT(((SEED * A) + C)/65,536) into the FPACC
 3951/1AD0 : 36 57                                 MVI	L, 127o               ;Load L with address of FPACC Exponent
 3952/1AD2 : C7                                    MOV	A,M                    ;Fetch FPACC Exponent into the accumulator
 3953/1AD3 : 04 10                                 ADI	020o               ;Add 16 (decimal) to effectively multiply by 65,536
 3954/1AD5 : F8                                    MOV	M,A                    ;(65,536 * INT[ ((SEED * A) + C)/65,5361) in FPACC
 3955/1AD6 : 36 34                                 MVI	L, 064o               ;Load L with address of [(SEED * A) + C]
 3956/1AD8 : 46 B6 12                              CALL	OPLOAD             ;Transfer it into FPOP. Subtract FPACC to form
 3957/1ADB : 46 1A 11                              CALL	FPSUB              ;[(SEED * A) + C] MOD 65,536
 3958/1ADE : 36 34                                 MVI	L, 064o               ;Load L with address of former SEED registers
 3959/1AE0 : 46 AD 12                              CALL	FSTORE             ;Store SEED MOD 65,536 in place of [(SEED * A) + Cl
 3960/1AE3 : 36 57                                 MVI	L, 127o               ;Load L with address of FPACC Exponent
 3961/1AE5 : C7                                    MOV	A,M                    ;Fetch FPACC Exponent into the ACC and subtract
 3962/1AE6 : 14 10                                 SUI	020o               ;16 (decimal) to form (SEED MOD 65,536)/65,536
 3963/1AE8 : F8                                    MOV	M,A                    ;So that random number in FPACC is between
 3964/1AE9 : 07                                    RET                    ;0.0 and +1.0 and exit to calling routine
 3965/1AEA :                            ;;; THE ABOVE RETURN SHOULD BE 32 351 1ae9h
 3966/1AEA :                            
 3967/1AEA :                            
 3968/1AEA :                            ;;; NOTE OPEN ADDRESSES TO END OF PAGE 32
 3969/1AEA :                            
 3970/1AEA :                            ;;; following is PATCH 2
 3971/1AEA :                            
 3972/1AEA :                            ;	db	(1af4h-$) dup 0
 3973/1AEA :                            
 3974/1AF4 :                            	ORG	1af4h	; 032#364
 3975/1AF4 : 70 83 1A                   PATCH2	JM	SQRCNV
 3976/1AF7 : 31                         	DCR	L
 3977/1AF8 : C7                         	MOV	A,M
 3978/1AF9 : A0                         	ANA	A
 3979/1AFA : 68 83 1A                   	JZ	SQRCNV
 3980/1AFD : 44 76 1A                   	JMP	SQR1
 3981/1B00 :                            ;;; The above jump should start at 32 375 1afdh
 3982/1B00 :                            	
 3983/1B00 :                            
 3984/1B00 :                            	;; PAGES 33 TO REMAINDER OF MEMORY
 3985/1B00 :                            	;; OR START OF OPTIONAL ARRAY HANDLING
 3986/1B00 :                            	;; ROUTINES USED AS USER PROGRAM BUFFER
 3987/1B00 :                            
 3988/1B00 :                            
 3989/1B00 :                            
 3990/1B00 :                            	;; OPTIONAL ARRAY ROUTINES ASSEMBLED FOR OPERATION
 3991/1B00 :                            	;; IN THE UPPER 3 PAGES OF A 12K SYSTEM ARE LISTED HERE.
 3992/1B00 :                            
 3993/1B00 :                            ;	db	(2d00h-$) dup 0
 3994/1B00 :                            
 3995/2D00 :                                       ORG 2d00h              ; 055#000
 3996/2D00 :                            
 3997/2D00 : 36 56                      PRIGH1:    MVI	L, 126o               ;Load L with address of the MSW in the FPACC
 3998/2D02 : 2E 01                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to page of FPACC
 3999/2D04 : C7                                    MOV	A,M                    ;Fetch MSW of FPACC into the ACC.
 4000/2D05 : A0                                    ANA	A                    ;Test to see if value in FPACC is positive.
 4001/2D06 : 70 5E 2D                              JM	OUTRNG             ;If not, go display error message.
 4002/2D09 : 46 00 10                              CALL	FPFIX              ;If O.K. then convert floating point to fixed point
 4003/2D0C : 36 54                                 MVI	L, 124o               ;Load L with address of LSAL of converted value
 4004/2D0E : C7                                    MOV	A,M                    ;Fetch the LSW of the value into the ACC
 4005/2D0F : 14 01                                 SUI	001                ;Subtract one from the value to establish proper
 4006/2D11 : 02                                    RLC                    ;Origin for future ops. Now rotate the value twice
 4007/2D12 : 02                                    RLC                    ;To effectively multiply by four. Save the
 4008/2D13 : D0                                    MOV	C,A                    ;Calculated result in CPU register C
 4009/2D14 : 36 83                                 MVI	L, 203o               ;Load L with address of F/A STACK TEMP
 4010/2D16 : 2E 17                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Load H with page of F/A STACK TEMP
 4011/2D18 : C7                                    MOV	A,M                    ;Fetch the value into the accumulator
 4012/2D19 : 2C FF                                 XRI	377o               ;Complement the value
 4013/2D1B : 02                                    RLC                    ;Rotate the value twice to multiply by four (the number
 4014/2D1C : 02                                    RLC                    ;Of bytes per entry in the ARRAY VARIABLES table).
 4015/2D1D : 04 50                                 ADI	120o               ;Add the starting address of the ARRAY VARIABLES
 4016/2D1F : 2E 17                                 MVI	H,PG27 ;\HB\OLDPG27   ;** TABLE to forin pointer. Set page address in H.
 4017/2D21 : F0                                    MOV	L,A                    ;Point to the name in the ARRAY VARIABLES
 4018/2D22 : 30                                    INR	L                    ;Increment the pointer value twice to move over the
 4019/2D23 : 30                                    INR	L                    ;Name in the table and point to starting address for the
 4020/2D24 : C7                                    MOV	A,M                    ;Array values in the ARRAY VALUES table. Fetch this
 4021/2D25 : 82                                    ADD	C                    ;Address to the ACC. Now add in the figure calculated
 4022/2D26 : F0                                    MOV	L,A                    ;To reach desired subscripted data storage location. Set
 4023/2D27 : 2E 2F                                 MVI	H,PG57 ;\HB\OLDPG57   ;tt The pointer to that location. Load the floating point
 4024/2D29 : 44 A4 12                              JMP	FLOAD              ;Value stored there into the FPACC and exit to caller.
 4025/2D2C :                            
 4026/2D2C :                            
 4027/2D2C :                            ;;; The label FUNAR2 SHOULD START AT 55-054 2d2ch
 4028/2D2C : 36 82                      FUNAR2:    MVI	L, 202o               ;Load L with address of TEMP COUNTER
 4029/2D2E : 2E 17                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Load H with page of counter
 4030/2D30 : CF                                    MOV	B,M                    ;Fetch the counter value
 4031/2D31 : 08                                    INR	B                    ;Increment the value
 4032/2D32 : F9                                    MOV	M,B                    ;Restore the value to memory
 4033/2D33 : 16 02                                 MVI	C, 002                ;Initialize register C to a value of two for future ops
 4034/2D35 : 36 4C                                 MVI	L, 114o               ;Load L with address of start of ARRAY VARIABLES
 4035/2D37 : 2E 17                                 MVI	H,PG27 ;\HB\OLDPG27   ;** TABLE (less four). Set H to page of the table.
 4036/2D39 : 46 98 07                              CALL	TABADR             ;Calculate address of start of next narne in table.
 4037/2D3C : 1E 16                                 MVI	D,PG26 ;\HB\OLDPG26   ;** Load D with page of the SYMBOL BUFFER
 4038/2D3E : 26 50                                 MVI	E, 120o               ;Set E to starting address of the SYMBOL BUFFER
 4039/2D40 : 46 DA 02                              CALL	STRCP              ;Compare name in ARRAY VARIABLES table to the
 4040/2D43 : 68 54 2D                              JZ	FUNAR3             ;Contents of the SYMBOL BUFFER. If match, go set up
 4041/2D46 : 36 82                                 MVI	L, 202o               ;Array token value. Else, reset L to address of TEMP
 4042/2D48 : 2E 17                                 MVI	H,PG27 ;\HB\OLDPG27   ;** COUNTER. Set H to page of TEMP COUNTER.
 4043/2D4A : C7                                    MOV	A,M                    ;Fetch the counter value into the accumulator.
 4044/2D4B : 36 3D                                 MVI	L, 075o               ;Change L to number of arrays storage location.
 4045/2D4D : BF                                    CMP	M                    ;Compare number of entries checked against number
 4046/2D4E : 48 2C 2D                              JNZ	FUNAR2             ;Possible. Keep searching table if not finished.
 4047/2D51 : 44 7A 07                              JMP	FAERR              ;If finished and no match than have F/A error condx.
 4048/2D54 : 36 82                      FUNAR3:    MVI	L, 202o               ;Load L with address of TEMP COUNTER
 4049/2D56 : 2E 17                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Load H with page of counter.
 4050/2D58 : A8                                    XRA	A                    ;Clear the accumulator. Subtract the value in the TEMP
 4051/2D59 : 9F                                    SBB	M                    ;COUNTER from zero to obtain two's complement.
 4052/2D5A : F8                                    MOV	M,A                    ;Place this back in counter location as ARRAY TOKEN
 4053/2D5B : 44 87 07                              JMP	FUNAR4             ;VALUE (negative). Go place the value on F/A STACK.
 4054/2D5E :                            
 4055/2D5E :                            
 4056/2D5E :                            ;;; The label OUTRNG STARTS AT 55 136 2d5eh
 4057/2D5E : 06 CF                      OUTRNG:    MVI	A, 317o               ;Load the ASCII code for letter 0 into the accumulator
 4058/2D60 : 16 D2                                 MVI	C, 322o               ;Load the ASCII code for letter R into register C
 4059/2D62 : 44 96 02                              JMP	ERROR              ;Go display Out of Range (OR) error message.
 4060/2D65 :                            
 4061/2D65 :                            
 4062/2D65 :                            
 4063/2D65 :                            
 4064/2D65 : 46 AA 08                   ARRAY:     CALL	RESTSY             ;Transfer contents of AUX SYMBOL BUFFER into the
 4065/2D68 : 44 70 2D                              JMP	ARRAY2             ;SYMBOL BUFFER. (Entry when have actual LET)
 4066/2D6B : 36 82                      ARRAY1:    MVI	L, 202o               ;Load L with address of SCAN pointer
 4067/2D6D : 44 72 2D                              JMP	ARRAY3             ;Proceed to process. (Entry point for IMPLIED LET)
 4068/2D70 : 36 83                      ARRAY2:    MVI	L, 203o               ;Load L with address of LET pointer
 4069/2D72 : 2E 16                      ARRAY3:    MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to pointer page
 4070/2D74 : CF                                    MOV	B,M                    ;Fetch pointer to location where "(" found in statement
 4071/2D75 : 08                                    INR	B                    ;Line. Increment it to point to next character in the line.
 4072/2D76 : 36 BE                                 MVI	L, 276o               ;Load L with address of EVAL pointer and load it with
 4073/2D78 : F9                                    MOV	M,B                    ;The starting address for the EVAL routine
 4074/2D79 : 36 86                                 MVI	L, 206o               ;Change L to address of ARRAY SETUP pointer
 4075/2D7B : F9                                    MOV	M,B                    ;And also store address in that location
 4076/2D7C : 36 86                      ARRAY4:    MVI	L, 206o               ;Load L with address of ARRAY SETUP pointer
 4077/2D7E : 46 A0 02                              CALL	GETCHR             ;Fetch character pointed to by ARRAY SETUP pntr
 4078/2D81 : 3C A9                                 CPI	251o               ;See if character is ")" ? If so, then have located
 4079/2D83 : 68 95 2D                              JZ	ARRAY5             ;End of the subscript. If not, reset
 4080/2D86 : 36 86                                 MVI	L, 206o               ;to the ARRAY SETUP pointer. Increment the
 4081/2D88 : 46 03 03                              CALL	LOOP               ;Pointer and test for the end of the statement line.
 4082/2D8B : 48 7C 2D                              JNZ	ARRAY4             ;If not end of line, continue looking for right paren.
 4083/2D8E : 06 C1                                 MVI	A, 301o               ;If reach end of line before right parenthesis than load
 4084/2D90 : 16 C6                                 MVI	C, 306o               ;ASCII code for letters A and F and display message
 4085/2D92 : 44 96 02                              JMP	ERROR              ;Indicating Array Forrnat (AF) error condition
 4086/2D95 : 36 86                      ARRAY5:    MVI	L, 206o               ;Load L with address of ARRAY SETUP pointer
 4087/2D97 : CF                                    MOV	B,M                    ;Fetch pointer (pointing to ")"sign) into register B
 4088/2D98 : 09                                    DCR	B                    ;Decrement it to move back to end of subscript number
 4089/2D99 : 36 BF                                 MVI	L, 277o               ;Load L with address of EVAL FINISH pointer location
 4090/2D9B : F9                                    MOV	M,B                    ;Place the pointer value in the EVAL FINISH pointer
 4091/2D9C : 36 87                                 MVI	L, 207o               ;Load L with address of LOOP COUNTER
 4092/2D9E : 3E 00                                 MVI	M, 000                ;Initialize LOOP COUNTER to value of zero
 4093/2DA0 : 36 87                      ARRAY6:    MVI	L, 207o               ;Load L with address of LOOP COUNTER
 4094/2DA2 : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of LOOP COUNTER
 4095/2DA4 : CF                                    MOV	B,M                    ;Fetch the counter value
 4096/2DA5 : 08                                    INR	B                    ;Increment it
 4097/2DA6 : F9                                    MOV	M,B                    ;Restore the counter value to memory
 4098/2DA7 : 16 02                                 MVI	C, 002                ;Set up counter in register C for future ops
 4099/2DA9 : 36 4C                                 MVI	L, 114o               ;Load L with address of start of ARRAY VARIABLES
 4100/2DAB : 2E 17                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Table less four). Set H to page of the table.
 4101/2DAD : 46 98 07                              CALL	TABADR             ;Calculate the address of next entry in the table
 4102/2DB0 : 26 50                                 MVI	E, 120o               ;Load register E with starting address of SYMBOL BUFF
 4103/2DB2 : 1E 16                                 MVI	D,PG26 ;\HB\OLDPG26   ;** Set D to page of SYMBOL BUFFER
 4104/2DB4 : 46 DA 02                              CALL	STRCP              ;Compare entry in table against contents of SYMBOL BF
 4105/2DB7 : 68 CA 2D                              JZ	ARRAY7             ;If match, have found array naine in the table.
 4106/2DBA : 36 87                                 MVI	L, 207o               ;Else, set L to address of the LOOP COUNTER
 4107/2DBC : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of the LOOP COUNTER
 4108/2DBE : C7                                    MOV	A,M                    ;Fetch the counter value to the ACC
 4109/2DBF : 36 3D                                 MVI	L, 075o               ;Change L to the counter containing number of arrays
 4110/2DC1 : 2E 17                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Set H to the proper page
 4111/2DC3 : BF                                    CMP	M                    ;Compare number of arrays to count in LOOP CNTR
 4112/2DC4 : 48 A0 2D                              JNZ	ARRAY6             ;If more entries in the table, continue looking for match
 4113/2DC7 : 44 7A 07                              JMP	FAERR              ;If no matching name in table then have an error condx.
 4114/2DCA : 46 94 03                   ARRAY7:    CALL	EVAL               ;Call subroutine to evaluate subscript expression
 4115/2DCD : 46 00 10                              CALL	FPFIX              ;Convert the subscript value obtained to fixed forrnat
 4116/2DD0 : 36 87                                 MVI	L, 207o               ;Load L with address of LOOP COUNTER
 4117/2DD2 : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of the LOOP COUNTER
 4118/2DD4 : CF                                    MOV	B,M                    ;Fetch the value in the LOOP COUNTER into the ACC
 4119/2DD5 : 16 02                                 MVI	C, 002                ;Set up counter in register C future ops
 4120/2DD7 : 36 4C                                 MVI	L, 114o               ;Load L with address of ARRAY VARIABLES
 4121/2DD9 : 2E 17                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Table less four). Set H to page of the table.
 4122/2DDB : 46 98 07                              CALL	TABADR             ;Calculate the address of entry in the table
 4123/2DDE : 30                                    INR	L                    ;Advance the ARRAY VARIABLES table pointer twice
 4124/2DDF : 30                                    INR	L                    ;To advance pointer over array name.
 4125/2DE0 : D7                                    MOV	C,M                    ;Fetch array base address in ARRAY VALUES table
 4126/2DE1 : 36 54                                 MVI	L, 124o               ;Load L with address of subscript value
 4127/2DE3 : 2E 01                                 MVI	H,PG01 ;\HB\OLDPG1    ;** Set H to page of subscript value
 4128/2DE5 : C7                                    MOV	A,M                    ;Fetch the subscript value into the accumulator
 4129/2DE6 : 14 01                                 SUI	001                ;Subtract one from subscript value to allow for zero
 4130/2DE8 : 02                                    RLC                    ;Origin. Now multiply by four
 4131/2DE9 : 02                                    RLC                    ;Using rotates (number of bytes required for each entry
 4132/2DEA : 82                                    ADD	C                    ;In the ARRAY VALUES table). Add in base address to
 4133/2DEB : 36 84                                 MVI	L, 204o               ;The calculated value to form final address in the
 4134/2DED : 2E 17                                 MVI	H,PG27 ;\HB\OLDPG27   ;** ARRAY VALUES table. Now set H & L to TEMP
 4135/2DEF : F8                                    MOV	M,A                    ;ARRAY ELEMENT storage location & store the addr.
 4136/2DF0 : 36 81                                 MVI	L, 201o               ;Change L to point to ARRAY FLAG
 4137/2DF2 : 3E FF                                 MVI	M, 377o               ;Set the ARRAY FLAG for future use
 4138/2DF4 : 07                                    RET                    ;Exit to calling routine
 4139/2DF5 :                            
 4140/2DF5 :                            
 4141/2DF5 :                            ;;; The label DIM SHOULD START AT 55 365 2df5h
 4142/2DF5 : 46 AD 02                   DIM:       CALL	CLESYM             ;Initialize the SYMBOL BUFFER to cleared condition
 4143/2DF8 : 36 82                                 MVI	L, 202o               ;Load L with address of SCAN pointer
 4144/2DFA : CF                                    MOV	B,M                    ;Fetch SCAN pointer value into register B
 4145/2DFB : 08                                    INR	B                    ;Add one to the SCAN pointer value
 4146/2DFC : 36 83                                 MVI	L, 203o               ;Change L to DIM pointer (formerly TOKEN) storage
 4147/2DFE : F9                                    MOV	M,B                    ;Store the updated SCAN pointer as the DIM pointer
 4148/2DFF : 36 83                      DIM1:      MVI	L, 203o               ;Load L with the address of DIM pointer storage location
 4149/2E01 : 46 A0 02                              CALL	GETCHR             ;Fetch a character from the line input buffer
 4150/2E04 : 68 0F 2E                              JZ	DIM2               ;If character fetched is a space, ignore it
 4151/2E07 : 3C A8                                 CPI	250o               ;Else see if character is "(" left parenthesis
 4152/2E09 : 68 1A 2E                              JZ	DIM3               ;If so, should have ARRAY VARIABLE naine in buffer
 4153/2E0C : 46 C8 02                              CALL	CONCTS             ;If not, append the character to the SYMBOL BUFFER
 4154/2E0F : 36 83                      DIM2:      MVI	L, 203o               ;Load L with the address of DIM pointer stomge location
 4155/2E11 : 46 03 03                              CALL	LOOP               ;Increment the pointer and see if end of line
 4156/2E14 : 48 FF 2D                              JNZ	DIM1               ;If not end of line, fetch next character
 4157/2E17 : 44 DF 2E                              JMP	DIMERR             ;Else have a DIMension error condition
 4158/2E1A : 36 86                      DIM3:      MVI	L, 206o               ;Load L with address of ARRAY pointer storage loc
 4159/2E1C : 3E 00                                 MVI	M, 000                ;Initialize ARRAY pointer to starting value of zero
 4160/2E1E : 36 86                      DIM4:      MVI	L, 206o               ;Load L with address of ARRAY pointer storage loc
 4161/2E20 : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of ARRAY pointer storage location
 4162/2E22 : C7                                    MOV	A,M                    ;Fetch value in ARRAY pointer to ACC (effectively
 4163/2E23 : 02                                    RLC                    ;Represents number of arrays defined in pgm). Rotate
 4164/2E24 : 02                                    RLC                    ;Left twice to multiply by four (niunber of bytes per
 4165/2E25 : 04 4C                                 ADI	114o               ;entry in ARRAY VARIABLES table). Add to base
 4166/2E27 : 2E 17                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Address to form pointer to ARRAY VARIA.BLES
 4167/2E29 : F0                                    MOV	L,A                    ;Table and set up H & L as the memory pointer.
 4168/2E2A : 26 50                                 MVI	E, 120o               ;Load E with starting address of the SYMBOL BUFFER
 4169/2E2C : 1E 16                                 MVI	D,PG26 ;\HB\OLDPG26   ;** Load D with the page address of the SYMBOL BUFF
 4170/2E2E : 46 DA 02                              CALL	STRCP              ;Compare contents of SYMBOL BF to entry in ARRAY
 4171/2E31 : 68 C1 2E                              JZ	DIM9               ;VARIABLES table. If same, have duplicate array name.
 4172/2E34 : 36 86                                 MVI	L, 206o               ;Else, load L with address of ARRAY pointer storage
 4173/2E36 : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of ARRAY pointer storage
 4174/2E38 : CF                                    MOV	B,M                    ;Fetch the ARRAY pointer value to register B
 4175/2E39 : 08                                    INR	B                    ;Increment the value
 4176/2E3A : F9                                    MOV	M,B                    ;Restore it to ARRAY pointer storage location
 4177/2E3B : 36 3D                                 MVI	L, 075o               ;Change L to number of arrays storage location
 4178/2E3D : 2E 17                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Set H to page of the number of arrays stomge loc
 4179/2E3F : C7                                    MOV	A,M                    ;Fetch the number of arrays value to the ACC
 4180/2E40 : 09                                    DCR	B                    ;Restore B to previous count
 4181/2E41 : B9                                    CMP	B                    ;Compare number of arrays tested against nr defined
 4182/2E42 : 48 1E 2E                              JNZ	DIM4               ;If not equal, continue searching ARRAY VARIABLES
 4183/2E45 : 36 3D                                 MVI	L, 075o               ;Table. When table searched with no match, then must
 4184/2E47 : 2E 17                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Append naine to table. First set pointer to number
 4185/2E49 : CF                                    MOV	B,M                    ;Of arrays storage location. Fetch that value and
 4186/2E4A : 08                                    INR	B                    ;Add one to account for new name being added.
 4187/2E4B : F9                                    MOV	M,B                    ;Restore the updated value back to memory.
 4188/2E4C : 36 3E                                 MVI	L, 076o               ;Change pointer to ARRAY TEMP pointer storage
 4189/2E4E : F9                                    MOV	M,B                    ;Store pointer to current array in ARRAY TEMP too.
 4190/2E4F : 36 86                                 MVI	L, 206o               ;Load L with address of ARRAY pointer stomge loc.
 4191/2E51 : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of ARRAY pointer storage location
 4192/2E53 : F9                                    MOV	M,B                    ;And update it also for new array being added.
 4193/2E54 : C7                                    MOV	A,M                    ;Fetch the current ARRAY pointer value to the ACC
 4194/2E55 : 02                                    RLC                    ;Multiply it times four by performing two rotate left
 4195/2E56 : 02                                    RLC                    ;Operations and add it to base value to form address in
 4196/2E57 : 04 4C                                 ADI	114o               ;The ARRAY VARIABLES table. Place the low part
 4197/2E59 : E0                                    MOV	E,A                    ;Of this calculated address value into register E.
 4198/2E5A : 1E 17                                 MVI	D,PG27 ;\HB\OLDPG27   ;** Set register D to the page of the table.
 4199/2E5C : 36 50                                 MVI	L, 120o               ;Load L with the start of the SYMBOL BUFFER
 4200/2E5E : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with the page of the SYMBOL BUFFER
 4201/2E60 : 46 26 0A                              CALL	MOVEC              ;Move the array name from the SYMBOL BUFFER to
 4202/2E63 : 46 AD 02                              CALL	CLESYM             ;The ARRAY VARIABLES table. Then clear the
 4203/2E66 : 36 83                                 MVI	L, 203o               ;SYMBOL BUFFER. Reset L to the DIM pointer storage
 4204/2E68 : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Location. Set H to the DIM pointer page.
 4205/2E6A : CF                                    MOV	B,M                    ;Fetch the pointer value (points to "(" part of DIM
 4206/2E6B : 08                                    INR	B                    ;Statement). Increment the pointer to next character in
 4207/2E6C : 36 84                                 MVI	L, 204o               ;The line input buffer. Cbange L to DIMEN pointer.
 4208/2E6E : F9                                    MOV	M,B                    ;Store the updated DIM pointer in DIMEN storage loc.
 4209/2E6F : 36 84                      DIM5:      MVI	L, 204o               ;Set L to DIMEN pointer storage location
 4210/2E71 : 46 A0 02                              CALL	GETCHR             ;Fetch character in line input buffer
 4211/2E74 : 68 89 2E                              JZ	DIM6               ;Ignore character for space
 4212/2E77 : 3C A9                                 CPI	251o               ;If not space, see if character is right parenthesis
 4213/2E79 : 68 94 2E                              JZ	DIM7               ;If yes, process DIMension size (array length)
 4214/2E7C : 3C B0                                 CPI	260o               ;If not, see if character is a valid decimal number
 4215/2E7E : 70 DF 2E                              JM	DIMERR             ;If not valid number, have DIMension error condition
 4216/2E81 : 3C BA                                 CPI	272o               ;Continue testing for valid decitnal number
 4217/2E83 : 50 DF 2E                              JP	DIMERR             ;If not valid number, then DIMension error condition
 4218/2E86 : 46 C8 02                              CALL	CONCTS             ;If valid decirnal number, append digit to SYMBOL BF
 4219/2E89 : 36 84                      DIM6:      MVI	L, 204o               ;Set L to DIMEN pointer storage location
 4220/2E8B : 46 03 03                              CALL	LOOP               ;Advance the pointer value and check for end of the line
 4221/2E8E : 48 6F 2E                              JNZ	DIM5               ;If not end of line, continue fetching DIMension size
 4222/2E91 : 44 DF 2E                              JMP	DIMERR             ;If end of line before right parenthesis, have error condx.
 4223/2E94 : 36 50                      DIM7:      MVI	L, 120o               ;Load L with address of start of SYMBOL BUFFER
 4224/2E96 : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Load H with page of SYMBOL BUFFER. (Now
 4225/2E98 : 46 24 13                              CALL	DINPUT             ;Contains DIMension size.) Convert buffer to floating
 4226/2E9B : 46 00 10                              CALL	FPFIX              ;Point number and then reformat to fixed point.
 4227/2E9E : 36 54                                 MVI	L, 124o               ;Load L with address of LSW of fixed point number
 4228/2EA0 : C7                                    MOV	A,M                    ; And fetch the low order byte of the nr into the ACC
 4229/2EA1 : 02                                    RLC                    ;Rotate it left two tirnes to multiply it by four (the
 4230/2EA2 : 02                                    RLC                    ;Number of bytes required to store a floating point nr).
 4231/2EA3 : D0                                    MOV	C,A                    ;Store this value in CPU register C temporarily
 4232/2EA4 : 36 3E                                 MVI	L, 076o               ;Set L to ARRAY TEMP storage location.
 4233/2EA6 : 2E 17                                 MVI	H,PG27 ;\HB\OLDPG27   ;** Set H to ARRAY TEMP pointer page.
 4234/2EA8 : C7                                    MOV	A,M                    ;Fetch the value in ARRAY TEMP (points to ARRAY
 4235/2EA9 : 14 01                                 SUI	001                ;VARIABLES table). Subtract one from the pointer
 4236/2EAB : 02                                    RLC                    ;Value and multiply the result by four using rotate left
 4237/2EAC : 02                                    RLC                    ;Instructions. Add this value to a base address
 4238/2EAD : 04 52                                 ADI	122o               ;(Augmented by two) to point to ARRAY VALUES
 4239/2EAF : F0                                    MOV	L,A                    ;Pointer storage location in the ARRAY VARIABLES
 4240/2EB0 : 2E 17                                 MVI	H,PG27 ;\HB\OLDPG27   ;Table and set the pointer up in registers H & L.
 4241/2EB2 : CF                                    MOV	B,M                    ;Fetch the starting address in the ARRAY VALUES
 4242/2EB3 : 04 04                                 ADI	004                ;Table for the previous array into register B. Now add
 4243/2EB5 : F0                                    MOV	L,A                    ;Four to the ARRAY VARIABLES table pointer to
 4244/2EB6 : C1                                    MOV	A,B                    ;Point to curront ARRAY VALUES starting address.
 4245/2EB7 : 82                                    ADD	C                    ;Add the previous array starting address plus number of
 4246/2EB8 : F8                                    MOV	M,A                    ;Bytes required and store as starting loc for next array
 4247/2EB9 : 36 84                      DIM8:      MVI	L, 204o               ;Set L to address of DIMEN pointer storage location
 4248/2EBB : 2E 16                                 MVI	H,PG26 ;\HB\OLDPG26   ;** Set H to page of DIMEN pointer
 4249/2EBD : CF                                    MOV	B,M                    ;Fetch pointer value (points to ") " in line)
 4250/2EBE : 36 83                                 MVI	L, 203o               ;Change L to DIM pointer storage location
 4251/2EC0 : F9                                    MOV	M,B                    ;Store former DIMEN value back in DIM pointer
 4252/2EC1 : 36 83                      DIM9:      MVI	L, 203o               ;Load L with address of DIM pointer storage location
 4253/2EC3 : 46 A0 02                              CALL	GETCHR             ;Fetch a character from the line input buffer
 4254/2EC6 : 3C AC                                 CPI	254o               ;See if character is a comma (,) sign
 4255/2EC8 : 68 D6 2E                              JZ	DIM10              ;If yes, have another array being defined on the line
 4256/2ECB : 36 83                                 MVI	L, 203o               ;If not, reset L to the DIM pointer
 4257/2ECD : 46 03 03                              CALL	LOOP               ;Increment the pointer and see if end of the line
 4258/2ED0 : 48 C1 2E                              JNZ	DIM9               ;If not end of the line, keep looking for a comma
 4259/2ED3 : 44 4E 0B                              JMP	NXTLIN             ;Else exit the DIM statement routine to continue pgm
 4260/2ED6 : 36 83                      DIM10:     MVI	L, 203o               ;Set L to DIM pointer storage location
 4261/2ED8 : CF                                    MOV	B,M                    ;Fetch pointer value (points to comma sign just found)
 4262/2ED9 : 36 82                                 MVI	L, 202o               ;Load L with address of SCAN pointer storage location
 4263/2EDB : F9                                    MOV	M,B                    ;Place DIM pointer into the-SCAN pointer
 4264/2EDC : 44 F5 2D                              JMP	DIM                ;Continue processing DIM statement line for next array
 4265/2EDF : 06 C4                      DIMERR:    MVI	A, 304o               ;On error condition, load ASCII code for letter D in ACC
 4266/2EE1 : 16 C5                                 MVI	C, 305o               ;And ASCII code for letter E in CPU register C
 4267/2EE3 : 44 96 02                              JMP	ERROR              ;Go display the Dirnension Error (DE) message.
 4268/2EE6 :                            
 4269/2EE6 :                            ;##################################################################################################
 4270/2EE6 :                            
 4271/2EE6 : =0H                        IN_STATUS	EQU 	00
 4272/2EE6 : =1H                        IN_DATA		EQU	01
 4273/2EE6 : =10H                       OUT_DATA	EQU 	10H
 4274/2EE6 :                            
 4275/3000 :                            		ORG	3000H
 4276/3000 :                            
 4277/3000 : 40                         OPN:		DB	OPN_MSG1 - OPN_MSG
 4278/3001 : 46 61 73 74 65 72 20 53 43 OPN_MSG:	DB	"Faster SCELBAL (2012)",0dh,0ah
      300A : 45 4C 42 41 4C 20 28 32 30
      3013 : 31 32 29 0D 0A            
 4279/3018 : 49 4F 20 61 6E 64 20 73 74 		DB	"IO and start up routine by Gazelle 2025",0dh,0ah
      3021 : 61 72 74 20 75 70 20 72 6F
      302A : 75 74 69 6E 65 20 62 79 20
      3033 : 47 61 7A 65 6C 6C 65 20 32
      303C : 30 32 35 0D 0A            
 4280/3041 : 00                         OPN_MSG1:	DB	0
 4281/3042 :                            
 4282/3042 :                            START3000:
 4283/3042 : =>FALSE                     IF FOR8080
 4284/3042 :                            		LXI	SP,4000H
 4285/3042 :                            		LHLD	1
 4286/3042 :                            		LXI	B,3
 4287/3042 :                            		DAD	B
 4288/3042 :                            		SHLD	CIN_ST+1
 4289/3042 :                            		DAD	B
 4290/3042 :                            		SHLD	CIN_IN+1
 4291/3042 :                            		DAD	B
 4292/3042 :                            		SHLD	CIN_OUT+1
 4293/3042 :                            		SHLD	CP_1+1
 4294/3042 :                            		SHLD	CP_2+1
 4295/3042 :                            		SHLD	CP_3+1
 4296/3042 : [4283]                      ENDIF
 4297/3042 : 2E 30                      		MVI	H,OPN / 256		;30H
 4298/3044 : 36 00                      		MVI	L,OPN - OPN/256*256	;00H
 4299/3046 : 46 51 03                   		CALL	TEXTC
 4300/3049 : 2E 01                      		MVI	H,1
 4301/304B : A8                         		XRA	A
 4302/304C : F0                         		MOV	L,A
 4303/304D : F8                         		MOV	M,A
 4304/304E : 30                         		INR	L
 4305/304F : F8                         		MOV	M,A
 4306/3050 : 30                         		INR	L
 4307/3051 : F8                         		MOV	M,A
 4308/3052 : 44 0A 09                   		JMP	ENTRY_SCR
 4309/3055 :                            ;---------------------------------------------------------------------
 4310/3055 :                            ;;; no user defined functions yet, stop here if we see one.
 4311/3055 : 07                         UDEFX:		RET
 4312/3056 :                            
 4313/3056 :                            ;##################################################################################################
 4314/3056 :                            ;
 4315/3056 :                            ;		HARDWARE DEPENDENT ROUTINE
 4316/3056 :                            ;
 4317/3056 : =>TRUE                      IF		FOR8008
 4318/3056 :                            SAVE:
 4319/3056 : 7F                         LOAD:		OUT	1FH	; Exit from emulator.
 4320/3057 : [4317]                      ENDIF
 4321/3057 :                            
 4322/3057 : =>FALSE                     IF		FOR8080
 4323/3057 :                            SAVE:
 4324/3057 :                            LOAD:
 4325/3057 :                            		LXI	D,EXIT_MSG
 4326/3057 :                            		MVI	C,9
 4327/3057 :                            		CALL	5
 4328/3057 :                            		JMP	0	; Exit from emulator.(reboot CP/M)
 4329/3057 :                            EXIT_MSG	DB	'Exit from SCELBAL BASIC',0dh,0ah,'$'
 4330/3057 : [4322]                      ENDIF
 4331/3057 :                            
 4332/3057 :                            ;;; HERE IS THE USER DEFINED CHARACTER INPUT TO READ FROM SERIAL PORT
 4333/3057 :                            
 4334/3057 : =>TRUE                      IF		FOR8008
 4335/3057 :                            
 4336/3057 : 43                         CINP:		IN	IN_DATA
 4337/3058 : 3C 08                      		CPI	08H
 4338/305A : 68 61 30                   		JZ	CINP_BS
 4339/305D : 61                         		OUT	OUT_DATA
 4340/305E : 34 80                      		ORI	80H
 4341/3060 : 07                         		RET
 4342/3061 :                            
 4343/3061 : 06 FF                      CINP_BS:	MVI	A,0FFH
 4344/3063 : 07                         		RET
 4345/3064 : [4334]                      ENDIF
 4346/3064 :                            
 4347/3064 : =>FALSE                     IF		FOR8080
 4348/3064 :                            CINP:
 4349/3064 :                            		PUSH	B
 4350/3064 :                            		PUSH	D
 4351/3064 :                            		PUSH	H
 4352/3064 :                            CINP0:
 4353/3064 :                            CIN_ST:		CALL	0FA06H
 4354/3064 :                            		ANA	A
 4355/3064 :                            		JZ	CINP0
 4356/3064 :                            CIN_IN:		CALL	0FA09H
 4357/3064 :                            		CPI	08H
 4358/3064 :                            		JZ	CINP_BS
 4359/3064 :                            		PUSH	PSW
 4360/3064 :                            		MOV	C,A
 4361/3064 :                            CIN_OUT		CALL	0FA0CH
 4362/3064 :                            		POP	PSW
 4363/3064 :                            		ORI	80H
 4364/3064 :                            		POP	H
 4365/3064 :                            		POP	D
 4366/3064 :                            		POP	B
 4367/3064 :                            		RET
 4368/3064 :                            
 4369/3064 :                            CINP_BS:	MVI	A,0FFH
 4370/3064 :                            		POP	H
 4371/3064 :                            		POP	D
 4372/3064 :                            		POP	B
 4373/3064 :                            		RET
 4374/3064 : [4347]                      ENDIF
 4375/3064 :                            ;---------------------------------------------------------------------
 4376/3064 :                            ;;; HERE IS THE USER DEFINED PRINT ROUTINE FOR A SERIAL PORT
 4377/3064 :                            
 4378/3064 : =>TRUE                      IF		FOR8008
 4379/3064 :                            CPRINT:
 4380/3064 : 3C DC                      		CPI	0DCH
 4381/3066 : 68 7C 30                   		JZ	CP_BS
 4382/3069 : 24 7F                      		ANI	7Fh
 4383/306B : 3C 0D                      		CPI	0DH
 4384/306D : 68 7A 30                   		JZ	CP_OK
 4385/3070 : 3C 0A                      		CPI	0AH
 4386/3072 : 68 7A 30                   		JZ	CP_OK
 4387/3075 : 3C 20                      		CPI	20H
 4388/3077 : 60 7B 30                   		JC	CP_NO
 4389/307A : 61                         CP_OK:		OUT	OUT_DATA
 4390/307B : 07                         CP_NO:		RET
 4391/307C :                            
 4392/307C : 06 08                      CP_BS:		MVI	A,08H
 4393/307E : 61                         		OUT	OUT_DATA
 4394/307F : 06 20                      		MVI	A,20H
 4395/3081 : 61                         		OUT	OUT_DATA
 4396/3082 : 06 08                      		MVI	A,08H
 4397/3084 : 61                         		OUT	OUT_DATA
 4398/3085 : 07                         		RET
 4399/3086 : [4378]                      ENDIF
 4400/3086 :                            
 4401/3086 : =>FALSE                     IF		FOR8080
 4402/3086 :                            CPRINT:
 4403/3086 :                            		PUSH	PSW
 4404/3086 :                            		PUSH	B
 4405/3086 :                            		PUSH	D
 4406/3086 :                            		PUSH	H
 4407/3086 :                            		CPI	0DCH
 4408/3086 :                            		JZ	CP_BS
 4409/3086 :                            		ANI	7Fh
 4410/3086 :                            		CPI	0DH
 4411/3086 :                            		JZ	CP_OK
 4412/3086 :                            		CPI	0AH
 4413/3086 :                            		JZ	CP_OK
 4414/3086 :                            		CPI	20H
 4415/3086 :                            		JC	CP_NO
 4416/3086 :                            CP_OK:		MOV	C,A
 4417/3086 :                            CP_1:		CALL	0FA0CH
 4418/3086 :                            CP_NO:		POP	H
 4419/3086 :                            		POP	D
 4420/3086 :                            		POP	B
 4421/3086 :                            		POP	PSW
 4422/3086 :                            		RET
 4423/3086 :                            
 4424/3086 :                            CP_BS:		MVI	C,08H
 4425/3086 :                            CP_2:		CALL	0FA0CH
 4426/3086 :                            		MVI	C,20H
 4427/3086 :                            CP_3:		CALL	0FA0CH
 4428/3086 :                            		MVI	C,08H
 4429/3086 :                            		JMP	CP_1
 4430/3086 :                            
 4431/3086 : [4401]                      ENDIF
 4432/3086 :                            ;------------------------------------------------------------------------
 4433/3086 :                            
 AS V1.42 Beta [Bld 271] - Source File sc1.asm - Page 3 - 6/7/2025 16:50:52


  Symbol Table (* = unused):
  --------------------------

 ABSX :                                   7E6 C |  ACCSET :                                1076 C |
 ACNONZ :                                1063 C |  ACZERT :                                1050 C |
 AD4DE :                                  6AE C |  ADBDE :                                 0AC5 C |
 ADDER :                                 1257 C | *ADDEXP :                                1129 C |
 ADDMOR :                                1258 C |  ADOPPP :                                11B8 C |
 ADV :                                    2FF C |  ADVDE :                                 0B34 C |
 AHEAD1 :                                1490 C |  AHEAD2 :                                15DB C |
*ARCHITECTURE :          "i386-unknown-win32" - |  ARRAY :                                 2D65 C |
 ARRAY1 :                                2D6B C |  ARRAY2 :                                2D70 C |
 ARRAY3 :                                2D72 C |  ARRAY4 :                                2D7C C |
 ARRAY5 :                                2D95 C |  ARRAY6 :                                2DA0 C |
 ARRAY7 :                                2DCA C |  BACKSP :                                198F C |
 BGNPGRAM :                                1B - |  BIGERR :                                 292 C |
*BRING1 :                                1107 C | *CASESENSITIVE :                            0 - |
 CFALSE :                                 6A7 C |  CHRX :                                   7FF C |
 CINP :                                  3057 C |  CINPUT :                                 391 C |
 CINP_BS :                               3061 C |  CKDECP :                                155F C |
*CKEQEX :                                10A2 C |  CKSIGN :                                1176 C |
 CLESYM :                                 2AD C |  CLRNEX :                                117D C |
 CLRNX1 :                                1187 C |  CLRNX2 :                                132D C |
 CLRNX3 :                                1337 C | *CLROPL :                                1183 C |
 COMPEN :                                1508 C |  COMPLM :                                1268 C |
 CONCT1 :                                 2CC C | *CONCTA :                                 2B4 C |
 CONCTE :                                 2D7 C |  CONCTN :                                 2BE C |
 CONCTS :                                 2C8 C | *CONSTPI :                  3.141592653589793 - |
 CONTIN :                                0A3B C |  CPHLDE :                                0ABF C |
 CPRINT :                                3064 C |  CP_BS :                                 307C C |
 CP_NO :                                 307B C |  CP_OK :                                 307A C |
 CRLF :                                   361 C |  CROUND :                                11C7 C |
 CTRLC :                                 0ACB C |  CTRUE :                                  6A2 C |
*DATE :                            "6/7/2025" - |  DEC :                                    374 C |
 DECBIN :                                142E C |  DECEXD :                                14DE C |
 DECEXT :                                14BF C |  DECNO :                                  37A C |
 DECOUT :                                14F0 C |  DECRDG :                                154A C |
 DECREP :                                14D7 C |  DIM :                                   2DF5 C |
 DIM1 :                                  2DFF C |  DIM10 :                                 2ED6 C |
 DIM2 :                                  2E0F C |  DIM3 :                                  2E1A C |
 DIM4 :                                  2E1E C |  DIM5 :                                  2E6F C |
 DIM6 :                                  2E89 C |  DIM7 :                                  2E94 C |
*DIM8 :                                  2EB9 C |  DIM9 :                                  2EC1 C |
 DIMERR :                                2EDF C |  DINPUT :                                1324 C |
 DIRECT :                                0B89 C |  DIVIDE :                                11E9 C |
 DVERR :                                 0AEF C |  DVEXIT :                                1238 C |
 DVLOOP :                                 6F2 C |  ECHO :                                   382 C |
 ENDINP :                                13C9 C |  ENDPGRAM :                                2D - |
 ENTRY_SCR :                              90A C |  EQ :                                     65E C |
 ERROR :                                  296 C |  EVAL :                                   394 C |
 EXEC :                                   8B6 C |  EXEC1 :                                  8BD C |
 EXMLDV :                                1166 C |  EXOUTN :                                15D4 C |
 EXPINP :                                13A1 C |  EXPOK :                                 1400 C |
 EXPOUT :                                15C0 C |  FACXOP :                                12BF C |
 FAERR :                                  77A C | *FALSE :                                    0 - |
 FINER1 :                                0AE9 C |  FINERR :                                0AD2 C |
 FININP :                                13D7 C |  FIXERR :                                0AF6 C |
 FLOAD :                                 12A4 C |  FNDEXP :                                1391 C |
 FOR :                                   0F74 C |  FOR1 :                                  0FAA C |
 FOR2 :                                  0FB6 C |  FOR3 :                                  0FC8 C |
 FOR4 :                                  0FD3 C |  FOR5 :                                  19A6 C |
 FOR8008 :                                  1 - |  FOR8080 :                                  0 - |
 FORERR :                                0FA3 C |  FORNXT :                                1851 C |
 FP0 :                                   0F6F C |  FPADD :                                 1089 C |
 FPCOMP :                                1082 C |  FPD10 :                                 141B C |
 FPDIV :                                 11D2 C |  FPFIX :                                 1000 C |
 FPFIXL :                                101B C |  FPFLT :                                 1034 C |
 FPMULT :                                1126 C |  FPNORM :                                1036 C |
 FPONE :                                  6A2 C |  FPOPER :                                 5F4 C |
 FPOUT :                                 1475 C |  FPSUB :                                 111A C |
 FPX10 :                                 1408 C |  FPZERO :                                1029 C |
 FRAC :                                  0CE8 C | *FSHIFT :                                1102 C |
 FSTORE :                                12AD C |  FUNAR1 :                                 74D C |
 FUNAR2 :                                2D2C C |  FUNAR3 :                                2D54 C |
 FUNAR4 :                                 787 C |  FUNARR :                                 740 C |
 GE :                                     68B C |  GETAU0 :                                 989 C |
 GETAU1 :                                 9A2 C |  GETAU2 :                                 9B7 C |
 GETAUX :                                 97F C |  GETCHP :                                0A53 C |
 GETCHR :                                 2A0 C |  GETINP :                                12F5 C |
 GOSERR :                                0EE7 C |  GOSUB :                                 0E9E C |
 GOSUB1 :                                0EAD C |  GOTO :                                  0D7C C |
 GOTO1 :                                 0D89 C |  GOTO2 :                                 0DA0 C |
 GOTO3 :                                 0DA8 C |  GOTO4 :                                 0DB1 C |
 GOTO5 :                                 0DB8 C |  GOTO6 :                                 0DCD C |
 GOTO7 :                                 0DE0 C | *GOTOER :                                0E10 C |
 GT :                                     66B C | *HAS64 :                                    0 - |
 IF :                                    0E17 C |  IF1 :                                   0E42 C |
 IF2 :                                   0E63 C |  IF3 :                                   0E76 C |
 IF4 :                                   0E80 C |  IFERR :                                 0E3B C |
*INCLIN :                                0AAD C |  INDEXB :                                 37C C |
 INDEXC :                                131E C |  INPUT :                                 0EF5 C |
 INPUT1 :                                0EFF C |  INPUT2 :                                0F1F C |
 INPUT3 :                                0F22 C |  INPUT4 :                                0F33 C |
 INPUTN :                                0F60 C |  INPUTX :                                0F44 C |
 INSER1 :                                0A99 C |  INSER3 :                                0AAD C |
 INSERT :                                0A85 C |  INSTR :                                 0B0A C |
 INSTR1 :                                0B0E C |  INSTR2 :                                0B31 C |
 INT1 :                                   7D7 C |  INT2 :                                   7E1 C |
 INTEXP :                                 6B3 C |  INTX :                                   7A3 C |
 IN_DATA :                                  1 - |  IN_DIGIT_CC_L :                           45 - |
*IN_DIGIT_CC_L0 :                         145 C | *IN_STATUS :                                0 - |
 LE :                                     67B C |  LET :                                   0D19 C |
 LET0 :                                  0D0B C |  LET1 :                                  0D22 C |
 LET2 :                                  0D2B C |  LET3 :                                  0D4B C |
 LET4 :                                  0D52 C |  LET5 :                                  0D61 C |
*LETERR :                                0D5A C |  LINEUP :                                10C3 C |
 LIST :                                   8DB C | *LISTON :                                   1 - |
 LOAD :                                  3056 C |  LOOK0 :                                 1054 C |
 LOOKU1 :                                 531 C |  LOOKU2 :                                 549 C |
 LOOKU4 :                                 581 C |  LOOKUP :                                 51B C |
 LOOP :                                   303 C |  LT :                                     651 C |
*MACEXP :                                   7 - |  MINEXP :                                141B C |
*MOMCPU :                               8008E - | *MOMCPUNAME :                       "8008NEW" - |
 MORACC :                                10CB C |  MORCOM :                                126D C |
 MOROP :                                 10D8 C |  MOVEC :                                 0A26 C |
 MOVECP :                                 8B1 C |  MOVEIT :                                110B C |
 MOVEPG :                                0A28 C |  MOVOP :                                 1092 C |
 MROUND :                                11C2 C |  MULOOP :                                 6E1 C |
 MULTIP :                                1136 C |  NE :                                     698 C |
 NEGEXP :                                1A21 C |  NEGFPA :                                11A9 C |
*NESTMAX :                                100 - |  NEXT :                                  180B C |
 NEXT1 :                                 1818 C |  NEXT10 :                                1963 C |
 NEXT11 :                                1978 C |  NEXT12 :                                197F C |
 NEXT2 :                                 1825 C |  NEXT3 :                                 1839 C |
 NEXT4 :                                 1858 C |  NEXT5 :                                 18C0 C |
 NEXT6 :                                 18E9 C |  NEXT7 :                                 1905 C |
 NEXT8 :                                 1917 C |  NEXT9 :                                 1922 C |
 NINPUT :                                134D C |  NODECP :                                156C C |
 NOEXC0 :                                1040 C |  NOEXPO :                                 505 C |
 NOEXPS :                                13A4 C |  NOGO :                                  11FE C |
 NOLIST :                                 8EC C |  NONZAC :                                109D C |
 NOREMD :                                1A2F C |  NOSAME :                                0A05 C |
 NOSCR :                                  939 C |  NOT0 :                                  1308 C |
 NOTDEL :                                 325 C |  NOTEND :                                 9DE C |
 NOTPLM :                                1350 C |  NUMERR :                                0AFD C |
 NXTLIN :                                0B4E C |  OPLOAD :                                12B6 C |
 OPN :                                   3000 C |  OPN_MSG :                               3001 C |
 OPN_MSG1 :                              3041 C |  OPSGNT :                                1198 C |
 OUTDGS :                                1525 C |  OUTDGX :                                1545 C |
 OUTDIG :                                151A C |  OUTFIX :                                14B9 C |
 OUTFLT :                                14AB C |  OUTNEG :                                1487 C |
 OUTRNG :                                2D5E C |  OUTX10 :                                1593 C |
 OUTZER :                                1544 C |  OUT_DATA :                                10 - |
 PARNER :                                 644 C |  PARNUM :                                 4EE C |
 PARSE :                                  599 C |  PARSE1 :                                 5C7 C |
 PARSE2 :                                 5DA C |  PARSEP :                                19C0 C |
 PARSER :                                 4D4 C |  PATCH1 :                                1800 C |
 PATCH2 :                                1AF4 C |  PATCH3 :                                 9C7 C |
 PCOM1 :                                 0D03 C |  PCOMMA :                                0CEF C |
 PERIOD :                                1381 C |  PFPOUT :                                0CCC C |
 PG01 :                                     1 - |  PG26 :                                    16 - |
 PG27 :                                    17 - |  PG57 :                                    2F - |
 POSEXP :                                13F5 C |  PRIGH1 :                                2D00 C |
 PRIGHT :                                 703 C |  PRINT :                                 0BE5 C |
 PRINT1 :                                0BF6 C |  PRINT2 :                                0C02 C |
 PRINT3 :                                0C23 C |  PRINT4 :                                0C3D C |
*PRINT5 :                                0C4C C |  PRINT6 :                                0C55 C |
 PUSHIT :                                1559 C |  QUOROT :                                11FF C |
 QUOTE :                                 0C83 C |  QUOTE1 :                                0C90 C |
 QUOTE2 :                                0CB3 C | *QUOTER :                                0CA6 C |
*RELAXED :                                  0 - |  REMOV1 :                                0A77 C |
 REMOVE :                                0A64 C |  RESIGN :                                107D C |
 RESTHL :                                12DF C |  RESTSY :                                 8AA C |
 RETERR :                                0EEE C |  RETURN :                                0EC4 C |
 RNDX :                                  1AA0 C |  ROTATL :                                127F C |
 ROTATR :                                1289 C |  ROTL :                                  1280 C |
 ROTR :                                  128A C |  RUN :                                   0B38 C |
 SAMLIN :                                0B6E C |  SAVE :                                  3056 C |
 SAVEHL :                                12CF C |  SAVESY :                                 8A0 C |
 SCAN1 :                                  3AC C |  SCAN10 :                                 4C1 C |
 SCAN11 :                                 463 C |  SCAN12 :                                 486 C |
 SCAN13 :                                 4A9 C |  SCAN14 :                                 4B0 C |
 SCAN15 :                                 4B7 C |  SCAN16 :                                 4BE C |
 SCAN2 :                                  3C0 C |  SCAN3 :                                  3E5 C |
 SCAN4 :                                  3EF C |  SCAN5 :                                  3FB C |
 SCAN6 :                                  407 C |  SCAN7 :                                  41B C |
 SCAN8 :                                  434 C |  SCAN9 :                                  440 C |
 SCANFN :                                 3E9 C |  SCRLOP :                                 930 C |
*SETDCT :                                11E5 C |  SETIT :                                 12BA C |
*SETMCT :                                1132 C |  SETSUB :                                1241 C |
 SGNX :                                   7F0 C |  SHACOP :                                10E1 C |
 SHIFT0 :                                10D7 C |  SHLOOP :                                10FC C |
 SKPNEG :                                10B4 C |  SQR1 :                                  1A76 C |
 SQRCNV :                                1A83 C |  SQRERR :                                1A8F C |
 SQREXP :                                1A32 C |  SQRLOP :                                1A47 C |
 SQRX :                                  1A00 C |  START3000 :                             3042 C |
 STOSY1 :                                 840 C |  STOSY2 :                                 856 C |
 STOSY3 :                                 86E C |  STOSY5 :                                 897 C |
 STOSYM :                                 82D C |  STRCP :                                  2DA C |
 STRCPC :                                 2F8 C |  STRCPE :                                 2EE C |
 STRCPL :                                 2E4 C |  STRIN :                                  30C C |
 STRIN1 :                                 30E C |  STRINF :                                 342 C |
 SUB12 :                                 15E1 C |  SUBBER :                                1293 C |
*SUBEXP :                                11DC C |  SUBHL :                                  34B C |
 SUBTRA :                                1294 C |  SWITCH :                                12EE C |
 SYNERR :                                 96A C |  SYNTAX :                                 200 C |
 SYNTOK :                                 971 C |  SYNTX1 :                                 20D C |
 SYNTX2 :                                 224 C |  SYNTX3 :                                 231 C |
 SYNTX4 :                                 237 C |  SYNTX5 :                                 25C C |
 SYNTX6 :                                 254 C |  SYNTX7 :                                 288 C |
 SYNTX8 :                                 28D C |  SYNTXL :                                 267 C |
 TAB1 :                                   812 C |  TABAD1 :                                 799 C |
 TABADR :                                 798 C | *TABC :                                   822 C |
 TABLOP :                                 825 C |  TABX :                                   80F C |
 TEXTC :                                  351 C |  TEXTCL :                                 355 C |
*TIME :                            "16:50:52" - |  TOMUCH :                                15EB C |
*TRUE :                                     1 - |  UDEFX :                                 3055 C |
*VERSION :                               142F - | *Z80SYNTAX :                                0 - |
 ZERO :                                  0CDE C |  ZERODG :                                1575 C |

    412 symbols
     34 unused symbols

 AS V1.42 Beta [Bld 271] - Source File sc1.asm - Page 4 - 6/7/2025 16:50:52


  Code Pages:
  ----------

STANDARD (0 changed characters)

1 code page

0.15 seconds assembly time

   4433 lines source file
      2 passes
      0 errors
      0 warnings
